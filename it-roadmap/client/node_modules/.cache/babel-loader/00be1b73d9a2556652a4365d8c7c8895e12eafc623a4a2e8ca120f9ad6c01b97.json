{"ast":null,"code":"import api from \"./api\";\n\n// Get roadmap data for a course (nodes and edges)\nexport const getCourseRoadmap = async courseId => {\n  try {\n    console.log(`Fetching roadmap data for course ${courseId}`);\n\n    // Get the course data to find associated roadmap\n    const courseResponse = await api.get(`/courses/${courseId}`);\n    const courseData = courseResponse.data;\n\n    // Check if this course has an associated roadmap\n    let roadmapId = courseData.roadmapId;\n    let roadmapData = null;\n\n    // If no roadmap associated, create one for this course\n    if (!roadmapId) {\n      console.log(`Course ${courseId} has no associated roadmap, creating one`);\n      try {\n        // Create a new roadmap for this course\n        const createResponse = await api.post(\"/roadmaps\", {\n          title: `Roadmap for ${courseData.title}`,\n          description: `Learning roadmap for course: ${courseData.title}`,\n          categoryId: courseData.categoryId,\n          skillId: courseData.skillId,\n          userId: courseData.userId || 1 // Default to user 1 if not specified\n        });\n        roadmapId = createResponse.data.id;\n\n        // Associate the roadmap with the course\n        await api.put(`/courses/${courseId}`, {\n          roadmapId: roadmapId\n        });\n        console.log(`Created and associated new roadmap ID: ${roadmapId}`);\n\n        // Initialize with empty roadmap\n        roadmapData = {\n          ...createResponse.data,\n          nodes: [],\n          edges: []\n        };\n      } catch (error) {\n        console.error(\"Error creating new roadmap:\", error);\n        throw new Error(\"Could not create a roadmap for this course\");\n      }\n    } else {\n      // Fetch the existing roadmap with its nodes and edges\n      console.log(`Course has roadmap ID: ${roadmapId}, fetching data directly`);\n      try {\n        // Get complete roadmap data\n        const roadmapResponse = await api.get(`/roadmaps/${roadmapId}`);\n        const baseRoadmap = roadmapResponse.data;\n\n        // Get nodes\n        const nodesResponse = await api.get(`/roadmaps/${roadmapId}/nodes`);\n        const nodes = nodesResponse.data && Array.isArray(nodesResponse.data) ? transformNodesToClientFormat(nodesResponse.data) : [];\n\n        // Get edges\n        const edgesResponse = await api.get(`/roadmaps/${roadmapId}/edges`);\n        const edges = edgesResponse.data && Array.isArray(edgesResponse.data) ? transformEdgesToClientFormat(edgesResponse.data) : [];\n        console.log(`Got ${nodes.length} nodes and ${edges.length} edges from roadmap ${roadmapId}`);\n\n        // Combine roadmap data\n        roadmapData = {\n          ...baseRoadmap,\n          nodes,\n          edges\n        };\n      } catch (error) {\n        console.error(`Error fetching roadmap ${roadmapId} data:`, error);\n        throw new Error(`Failed to fetch roadmap ${roadmapId}`);\n      }\n    }\n\n    // Return combined data with course info\n    return {\n      ...courseData,\n      roadmap: roadmapData,\n      nodes: roadmapData.nodes,\n      edges: roadmapData.edges\n    };\n  } catch (error) {\n    console.error(`Error fetching roadmap for course ${courseId}:`, error);\n    throw error;\n  }\n};\n\n// Save roadmap data directly to roadmap entity\nexport const saveCourseRoadmap = async (courseId, roadmapData) => {\n  try {\n    console.log(`Saving roadmap data for course ${courseId}`);\n    if (!courseId || isNaN(Number(courseId))) {\n      throw new Error(`Invalid course ID: ${courseId}`);\n    }\n    const numericCourseId = Number(courseId);\n    const {\n      nodes = [],\n      edges = []\n    } = roadmapData;\n    console.log(\"Nodes to save:\", nodes.length);\n    console.log(\"Edges to save:\", edges.length);\n\n    // Validate nodes and edges\n    if (!Array.isArray(nodes)) {\n      throw new Error(\"Nodes must be an array\");\n    }\n    if (!Array.isArray(edges)) {\n      throw new Error(\"Edges must be an array\");\n    }\n\n    // Step 1: Get or create a roadmap for this course\n    console.log(`Step 1: Getting/creating roadmap for course ${numericCourseId}`);\n    let roadmapId;\n\n    // First check if course has a roadmap\n    const courseResponse = await api.get(`/courses/${numericCourseId}`);\n    const courseData = courseResponse.data;\n    if (courseData.roadmapId) {\n      roadmapId = courseData.roadmapId;\n      console.log(`Using existing roadmap ID: ${roadmapId}`);\n    } else {\n      // Create new roadmap if course doesn't have one\n      const createResponse = await api.post(\"/roadmaps\", {\n        title: `Roadmap for ${courseData.title}`,\n        description: `Learning roadmap for course: ${courseData.title}`,\n        categoryId: courseData.categoryId,\n        skillId: courseData.skillId,\n        userId: courseData.userId || 1 // Default to user 1 if not specified\n      });\n      roadmapId = createResponse.data.id;\n\n      // Associate roadmap with course\n      await api.put(`/courses/${numericCourseId}`, {\n        roadmapId: roadmapId\n      });\n      console.log(`Created and associated new roadmap ID: ${roadmapId}`);\n    }\n\n    // Step 2: Transform nodes and edges to server format\n    console.log(`Step 2: Transforming nodes and edges for roadmap ${roadmapId}`);\n\n    // Ensure each node has required properties\n    const processedNodes = nodes.map(node => {\n      if (!node.id) {\n        node.id = `node_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n      }\n      return node;\n    });\n\n    // Ensure each edge has required properties\n    const processedEdges = edges.map(edge => {\n      if (!edge.id) {\n        edge.id = `edge_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n      }\n      return edge;\n    });\n    const transformedNodes = transformNodesToServerFormat(processedNodes);\n    const transformedEdges = transformEdgesToServerFormat(processedEdges);\n    console.log(`Transformed ${transformedNodes.length} nodes and ${transformedEdges.length} edges`);\n\n    // Perform a deep validation to ensure no malformed data\n    const validNodes = transformedNodes.filter(node => {\n      if (!node.nodeIdentifier) {\n        console.warn(\"Skipping node without identifier\");\n        return false;\n      }\n      return true;\n    });\n    const validEdges = transformedEdges.filter(edge => {\n      if (!edge.edgeIdentifier || !edge.source || !edge.target) {\n        console.warn(\"Skipping edge with missing properties:\", edge);\n        return false;\n      }\n      return true;\n    });\n\n    // Step 3: Save nodes to the roadmap\n    console.log(`Step 3: Saving ${validNodes.length} nodes and ${validEdges.length} edges to roadmap ${roadmapId}`);\n    try {\n      // Method 1: Save both nodes and edges at once using updateNodesAndEdges\n      console.log(\"Attempting to save nodes and edges in one request\");\n      const response = await api.put(`/roadmaps/${roadmapId}/nodes-edges`, {\n        nodes: validNodes,\n        edges: validEdges\n      });\n      console.log(\"Nodes and edges saved successfully in one request\");\n      console.log(\"Server response:\", response.status);\n\n      // Return updated data\n      return await getRoadmapById(roadmapId);\n    } catch (error) {\n      console.error(\"Combined update failed:\", error);\n\n      // Method 2: If direct update fails, fall back to separate endpoints\n      console.warn(\"Trying individual updates as fallback\");\n      try {\n        // Save nodes\n        console.log(`Saving ${validNodes.length} nodes separately`);\n        await api.put(`/roadmaps/${roadmapId}/nodes`, {\n          nodes: validNodes\n        });\n        console.log(`Nodes saved successfully`);\n      } catch (nodeError) {\n        var _nodeError$response, _nodeError$response$d;\n        console.error(\"Error saving nodes:\", nodeError);\n        throw new Error(`Failed to save nodes: ${((_nodeError$response = nodeError.response) === null || _nodeError$response === void 0 ? void 0 : (_nodeError$response$d = _nodeError$response.data) === null || _nodeError$response$d === void 0 ? void 0 : _nodeError$response$d.message) || nodeError.message}`);\n      }\n      try {\n        // Save edges\n        console.log(`Saving ${validEdges.length} edges separately`);\n        await api.put(`/roadmaps/${roadmapId}/edges`, {\n          edges: validEdges\n        });\n        console.log(`Edges saved successfully`);\n      } catch (edgeError) {\n        var _edgeError$response, _edgeError$response$d;\n        console.error(\"Error saving edges:\", edgeError);\n        throw new Error(`Failed to save edges: ${((_edgeError$response = edgeError.response) === null || _edgeError$response === void 0 ? void 0 : (_edgeError$response$d = _edgeError$response.data) === null || _edgeError$response$d === void 0 ? void 0 : _edgeError$response$d.message) || edgeError.message}`);\n      }\n\n      // Return updated data\n      return await getRoadmapById(roadmapId);\n    }\n  } catch (error) {\n    console.error(`Error saving roadmap for course ${courseId}:`, error);\n    throw error;\n  }\n};\n\n// Get roadmap by ID directly (not through a course)\nexport const getRoadmapById = async roadmapId => {\n  try {\n    console.log(`Fetching roadmap data for ID ${roadmapId}`);\n\n    // Get the base roadmap data\n    const roadmapResponse = await api.get(`/roadmaps/${roadmapId}`);\n    const baseRoadmap = roadmapResponse.data;\n\n    // Get nodes\n    const nodesResponse = await api.get(`/roadmaps/${roadmapId}/nodes`);\n    const nodes = nodesResponse.data && Array.isArray(nodesResponse.data) ? transformNodesToClientFormat(nodesResponse.data) : [];\n\n    // Get edges\n    const edgesResponse = await api.get(`/roadmaps/${roadmapId}/edges`);\n    const edges = edgesResponse.data && Array.isArray(edgesResponse.data) ? transformEdgesToClientFormat(edgesResponse.data) : [];\n    console.log(`Got ${nodes.length} nodes and ${edges.length} edges from roadmap ${roadmapId}`);\n\n    // Return combined data\n    return {\n      ...baseRoadmap,\n      nodes,\n      edges\n    };\n  } catch (error) {\n    console.error(`Error fetching roadmap ${roadmapId}:`, error);\n    throw error;\n  }\n};\n\n// Create a new course with roadmap data\nexport const createCourseWithRoadmap = async courseData => {\n  try {\n    console.log(\"Creating new course with roadmap data\");\n    const {\n      nodes,\n      edges,\n      ...courseDetails\n    } = courseData;\n\n    // Create the course first\n    const courseResponse = await api.post(\"/courses\", courseDetails);\n    const newCourse = courseResponse.data;\n    const courseId = newCourse.id;\n\n    // Then create and save roadmap if nodes/edges provided\n    if (nodes && nodes.length > 0 || edges && edges.length > 0) {\n      await saveCourseRoadmap(courseId, {\n        nodes,\n        edges\n      });\n    }\n\n    // Return the full course with roadmap data\n    return await getCourseRoadmap(courseId);\n  } catch (error) {\n    console.error(\"Error creating course with roadmap:\", error);\n    throw error;\n  }\n};\n\n// Transform nodes from server format to client format\nexport const transformNodesToClientFormat = nodes => {\n  return nodes.map(node => {\n    try {\n      // If node already has client format, return as is\n      if (node.type && node.position && node.data) {\n        return node;\n      }\n\n      // Parse the data if it's a string\n      let nodeData = node.data;\n      if (typeof node.data === \"string\") {\n        try {\n          nodeData = JSON.parse(node.data);\n        } catch (e) {\n          nodeData = {\n            label: node.data\n          };\n        }\n      }\n      return {\n        id: node.nodeIdentifier,\n        type: \"courseNode\",\n        // Default node type\n        position: {\n          x: node.positionX || 0,\n          y: node.positionY || 0\n        },\n        data: {\n          ...nodeData,\n          id: node.nodeIdentifier\n        }\n      };\n    } catch (error) {\n      console.error(\"Error transforming node to client format:\", error, node);\n      return null;\n    }\n  }).filter(Boolean);\n};\n\n// Transform nodes from client format to server format\nexport const transformNodesToServerFormat = nodes => {\n  if (!Array.isArray(nodes)) {\n    console.error(\"Nodes is not an array:\", nodes);\n    return [];\n  }\n  return nodes.map(node => {\n    try {\n      var _node$position, _node$position2;\n      if (!node) {\n        console.warn(\"Null or undefined node found\");\n        return null;\n      }\n      if (!node.id) {\n        console.warn(\"Node missing ID:\", node);\n        return null;\n      }\n\n      // Make sure position exists and has valid x, y values\n      const posX = parseFloat((_node$position = node.position) === null || _node$position === void 0 ? void 0 : _node$position.x) || 0;\n      const posY = parseFloat((_node$position2 = node.position) === null || _node$position2 === void 0 ? void 0 : _node$position2.y) || 0;\n\n      // Process data object\n      let processedData;\n      if (typeof node.data === \"object\" && node.data !== null) {\n        // Make a clean copy without circular references\n        const safeData = {\n          ...(node.data || {}),\n          label: node.data.label || node.id\n        };\n\n        // Remove any potentially problematic properties\n        delete safeData.events;\n        delete safeData.__proto__;\n        delete safeData.constructor;\n        processedData = safeData;\n      } else if (typeof node.data === \"string\") {\n        try {\n          // Try to parse if it's a JSON string\n          processedData = JSON.parse(node.data);\n        } catch (e) {\n          // If not valid JSON, use as label\n          processedData = {\n            label: node.data\n          };\n        }\n      } else {\n        // Default data\n        processedData = {\n          label: node.id\n        };\n      }\n\n      // Return in the format expected by the server\n      return {\n        nodeIdentifier: node.id,\n        positionX: posX,\n        positionY: posY,\n        data: JSON.stringify(processedData),\n        courseId: processedData.courseId || node.courseId || null,\n        roadmapId: node.roadmapId || null\n      };\n    } catch (error) {\n      console.error(\"Error transforming node to server format:\", error, node);\n      return null;\n    }\n  }).filter(Boolean);\n};\n\n// Transform edges from server format to client format\nexport const transformEdgesToClientFormat = edges => {\n  return edges.map(edge => {\n    try {\n      // If edge already has client format, return as is\n      if (edge.source && edge.target && edge.id) {\n        return edge;\n      }\n\n      // Parse the style if it's a string\n      let edgeStyle = {};\n      if (typeof edge.style === \"string\") {\n        try {\n          edgeStyle = JSON.parse(edge.style);\n        } catch (e) {\n          edgeStyle = {};\n        }\n      } else if (typeof edge.style === \"object\") {\n        edgeStyle = edge.style;\n      }\n      return {\n        id: edge.edgeIdentifier,\n        source: edge.source,\n        target: edge.target,\n        type: edge.type || \"smoothstep\",\n        animated: edge.animated || false,\n        style: edgeStyle\n      };\n    } catch (error) {\n      console.error(\"Error transforming edge to client format:\", error, edge);\n      return null;\n    }\n  }).filter(Boolean);\n};\n\n// Transform edges from client format to server format\nexport const transformEdgesToServerFormat = edges => {\n  if (!Array.isArray(edges)) {\n    console.error(\"Edges is not an array:\", edges);\n    return [];\n  }\n  return edges.map(edge => {\n    try {\n      if (!edge) {\n        console.warn(\"Null or undefined edge found\");\n        return null;\n      }\n      if (!edge.id || !edge.source || !edge.target) {\n        console.warn(\"Edge missing required properties:\", edge);\n        return null;\n      }\n\n      // Handle edge style\n      let styleString;\n      if (typeof edge.style === \"object\" && edge.style !== null) {\n        try {\n          // Make a clean copy to avoid circular references\n          const safeStyle = {\n            ...edge.style\n          };\n          styleString = JSON.stringify(safeStyle);\n        } catch (styleError) {\n          console.warn(\"Could not stringify edge style:\", styleError);\n          styleString = \"{}\";\n        }\n      } else if (typeof edge.style === \"string\") {\n        styleString = edge.style;\n      } else {\n        styleString = \"{}\";\n      }\n\n      // Return in the format expected by the server\n      return {\n        edgeIdentifier: edge.id,\n        source: edge.source,\n        target: edge.target,\n        type: edge.type || \"smoothstep\",\n        animated: edge.animated || false,\n        style: styleString,\n        roadmapId: edge.roadmapId || null\n      };\n    } catch (error) {\n      console.error(\"Error transforming edge to server format:\", error, edge);\n      return null;\n    }\n  }).filter(Boolean);\n};\nexport default {\n  getCourseRoadmap,\n  saveCourseRoadmap,\n  getRoadmapById,\n  createCourseWithRoadmap,\n  transformNodesToClientFormat,\n  transformNodesToServerFormat,\n  transformEdgesToClientFormat,\n  transformEdgesToServerFormat\n};","map":{"version":3,"names":["api","getCourseRoadmap","courseId","console","log","courseResponse","get","courseData","data","roadmapId","roadmapData","createResponse","post","title","description","categoryId","skillId","userId","id","put","nodes","edges","error","Error","roadmapResponse","baseRoadmap","nodesResponse","Array","isArray","transformNodesToClientFormat","edgesResponse","transformEdgesToClientFormat","length","roadmap","saveCourseRoadmap","isNaN","Number","numericCourseId","processedNodes","map","node","Date","now","Math","random","toString","substring","processedEdges","edge","transformedNodes","transformNodesToServerFormat","transformedEdges","transformEdgesToServerFormat","validNodes","filter","nodeIdentifier","warn","validEdges","edgeIdentifier","source","target","response","status","getRoadmapById","nodeError","_nodeError$response","_nodeError$response$d","message","edgeError","_edgeError$response","_edgeError$response$d","createCourseWithRoadmap","courseDetails","newCourse","type","position","nodeData","JSON","parse","e","label","x","positionX","y","positionY","Boolean","_node$position","_node$position2","posX","parseFloat","posY","processedData","safeData","events","__proto__","constructor","stringify","edgeStyle","style","animated","styleString","safeStyle","styleError"],"sources":["D:/demo/DACS-jules_wip_16596734084587186652/it-roadmap/client/src/services/courseRoadmapService.js"],"sourcesContent":["import api from \"./api\";\r\n\r\n// Get roadmap data for a course (nodes and edges)\r\nexport const getCourseRoadmap = async (courseId) => {\r\n  try {\r\n    console.log(`Fetching roadmap data for course ${courseId}`);\r\n\r\n    // Get the course data to find associated roadmap\r\n    const courseResponse = await api.get(`/courses/${courseId}`);\r\n    const courseData = courseResponse.data;\r\n\r\n    // Check if this course has an associated roadmap\r\n    let roadmapId = courseData.roadmapId;\r\n    let roadmapData = null;\r\n\r\n    // If no roadmap associated, create one for this course\r\n    if (!roadmapId) {\r\n      console.log(`Course ${courseId} has no associated roadmap, creating one`);\r\n\r\n      try {\r\n        // Create a new roadmap for this course\r\n        const createResponse = await api.post(\"/roadmaps\", {\r\n          title: `Roadmap for ${courseData.title}`,\r\n          description: `Learning roadmap for course: ${courseData.title}`,\r\n          categoryId: courseData.categoryId,\r\n          skillId: courseData.skillId,\r\n          userId: courseData.userId || 1, // Default to user 1 if not specified\r\n        });\r\n\r\n        roadmapId = createResponse.data.id;\r\n\r\n        // Associate the roadmap with the course\r\n        await api.put(`/courses/${courseId}`, {\r\n          roadmapId: roadmapId,\r\n        });\r\n\r\n        console.log(`Created and associated new roadmap ID: ${roadmapId}`);\r\n\r\n        // Initialize with empty roadmap\r\n        roadmapData = {\r\n          ...createResponse.data,\r\n          nodes: [],\r\n          edges: [],\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error creating new roadmap:\", error);\r\n        throw new Error(\"Could not create a roadmap for this course\");\r\n      }\r\n    } else {\r\n      // Fetch the existing roadmap with its nodes and edges\r\n      console.log(\r\n        `Course has roadmap ID: ${roadmapId}, fetching data directly`\r\n      );\r\n      try {\r\n        // Get complete roadmap data\r\n        const roadmapResponse = await api.get(`/roadmaps/${roadmapId}`);\r\n        const baseRoadmap = roadmapResponse.data;\r\n\r\n        // Get nodes\r\n        const nodesResponse = await api.get(`/roadmaps/${roadmapId}/nodes`);\r\n        const nodes =\r\n          nodesResponse.data && Array.isArray(nodesResponse.data)\r\n            ? transformNodesToClientFormat(nodesResponse.data)\r\n            : [];\r\n\r\n        // Get edges\r\n        const edgesResponse = await api.get(`/roadmaps/${roadmapId}/edges`);\r\n        const edges =\r\n          edgesResponse.data && Array.isArray(edgesResponse.data)\r\n            ? transformEdgesToClientFormat(edgesResponse.data)\r\n            : [];\r\n\r\n        console.log(\r\n          `Got ${nodes.length} nodes and ${edges.length} edges from roadmap ${roadmapId}`\r\n        );\r\n\r\n        // Combine roadmap data\r\n        roadmapData = {\r\n          ...baseRoadmap,\r\n          nodes,\r\n          edges,\r\n        };\r\n      } catch (error) {\r\n        console.error(`Error fetching roadmap ${roadmapId} data:`, error);\r\n        throw new Error(`Failed to fetch roadmap ${roadmapId}`);\r\n      }\r\n    }\r\n\r\n    // Return combined data with course info\r\n    return {\r\n      ...courseData,\r\n      roadmap: roadmapData,\r\n      nodes: roadmapData.nodes,\r\n      edges: roadmapData.edges,\r\n    };\r\n  } catch (error) {\r\n    console.error(`Error fetching roadmap for course ${courseId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Save roadmap data directly to roadmap entity\r\nexport const saveCourseRoadmap = async (courseId, roadmapData) => {\r\n  try {\r\n    console.log(`Saving roadmap data for course ${courseId}`);\r\n\r\n    if (!courseId || isNaN(Number(courseId))) {\r\n      throw new Error(`Invalid course ID: ${courseId}`);\r\n    }\r\n\r\n    const numericCourseId = Number(courseId);\r\n    const { nodes = [], edges = [] } = roadmapData;\r\n\r\n    console.log(\"Nodes to save:\", nodes.length);\r\n    console.log(\"Edges to save:\", edges.length);\r\n\r\n    // Validate nodes and edges\r\n    if (!Array.isArray(nodes)) {\r\n      throw new Error(\"Nodes must be an array\");\r\n    }\r\n\r\n    if (!Array.isArray(edges)) {\r\n      throw new Error(\"Edges must be an array\");\r\n    }\r\n\r\n    // Step 1: Get or create a roadmap for this course\r\n    console.log(\r\n      `Step 1: Getting/creating roadmap for course ${numericCourseId}`\r\n    );\r\n    let roadmapId;\r\n\r\n    // First check if course has a roadmap\r\n    const courseResponse = await api.get(`/courses/${numericCourseId}`);\r\n    const courseData = courseResponse.data;\r\n\r\n    if (courseData.roadmapId) {\r\n      roadmapId = courseData.roadmapId;\r\n      console.log(`Using existing roadmap ID: ${roadmapId}`);\r\n    } else {\r\n      // Create new roadmap if course doesn't have one\r\n      const createResponse = await api.post(\"/roadmaps\", {\r\n        title: `Roadmap for ${courseData.title}`,\r\n        description: `Learning roadmap for course: ${courseData.title}`,\r\n        categoryId: courseData.categoryId,\r\n        skillId: courseData.skillId,\r\n        userId: courseData.userId || 1, // Default to user 1 if not specified\r\n      });\r\n\r\n      roadmapId = createResponse.data.id;\r\n\r\n      // Associate roadmap with course\r\n      await api.put(`/courses/${numericCourseId}`, {\r\n        roadmapId: roadmapId,\r\n      });\r\n\r\n      console.log(`Created and associated new roadmap ID: ${roadmapId}`);\r\n    }\r\n\r\n    // Step 2: Transform nodes and edges to server format\r\n    console.log(\r\n      `Step 2: Transforming nodes and edges for roadmap ${roadmapId}`\r\n    );\r\n\r\n    // Ensure each node has required properties\r\n    const processedNodes = nodes.map((node) => {\r\n      if (!node.id) {\r\n        node.id = `node_${Date.now()}_${Math.random()\r\n          .toString(36)\r\n          .substring(2, 9)}`;\r\n      }\r\n      return node;\r\n    });\r\n\r\n    // Ensure each edge has required properties\r\n    const processedEdges = edges.map((edge) => {\r\n      if (!edge.id) {\r\n        edge.id = `edge_${Date.now()}_${Math.random()\r\n          .toString(36)\r\n          .substring(2, 9)}`;\r\n      }\r\n      return edge;\r\n    });\r\n\r\n    const transformedNodes = transformNodesToServerFormat(processedNodes);\r\n    const transformedEdges = transformEdgesToServerFormat(processedEdges);\r\n\r\n    console.log(\r\n      `Transformed ${transformedNodes.length} nodes and ${transformedEdges.length} edges`\r\n    );\r\n\r\n    // Perform a deep validation to ensure no malformed data\r\n    const validNodes = transformedNodes.filter((node) => {\r\n      if (!node.nodeIdentifier) {\r\n        console.warn(\"Skipping node without identifier\");\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n\r\n    const validEdges = transformedEdges.filter((edge) => {\r\n      if (!edge.edgeIdentifier || !edge.source || !edge.target) {\r\n        console.warn(\"Skipping edge with missing properties:\", edge);\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n\r\n    // Step 3: Save nodes to the roadmap\r\n    console.log(\r\n      `Step 3: Saving ${validNodes.length} nodes and ${validEdges.length} edges to roadmap ${roadmapId}`\r\n    );\r\n    try {\r\n      // Method 1: Save both nodes and edges at once using updateNodesAndEdges\r\n      console.log(\"Attempting to save nodes and edges in one request\");\r\n      const response = await api.put(`/roadmaps/${roadmapId}/nodes-edges`, {\r\n        nodes: validNodes,\r\n        edges: validEdges,\r\n      });\r\n\r\n      console.log(\"Nodes and edges saved successfully in one request\");\r\n      console.log(\"Server response:\", response.status);\r\n\r\n      // Return updated data\r\n      return await getRoadmapById(roadmapId);\r\n    } catch (error) {\r\n      console.error(\"Combined update failed:\", error);\r\n\r\n      // Method 2: If direct update fails, fall back to separate endpoints\r\n      console.warn(\"Trying individual updates as fallback\");\r\n\r\n      try {\r\n        // Save nodes\r\n        console.log(`Saving ${validNodes.length} nodes separately`);\r\n        await api.put(`/roadmaps/${roadmapId}/nodes`, {\r\n          nodes: validNodes,\r\n        });\r\n        console.log(`Nodes saved successfully`);\r\n      } catch (nodeError) {\r\n        console.error(\"Error saving nodes:\", nodeError);\r\n        throw new Error(\r\n          `Failed to save nodes: ${\r\n            nodeError.response?.data?.message || nodeError.message\r\n          }`\r\n        );\r\n      }\r\n\r\n      try {\r\n        // Save edges\r\n        console.log(`Saving ${validEdges.length} edges separately`);\r\n        await api.put(`/roadmaps/${roadmapId}/edges`, {\r\n          edges: validEdges,\r\n        });\r\n        console.log(`Edges saved successfully`);\r\n      } catch (edgeError) {\r\n        console.error(\"Error saving edges:\", edgeError);\r\n        throw new Error(\r\n          `Failed to save edges: ${\r\n            edgeError.response?.data?.message || edgeError.message\r\n          }`\r\n        );\r\n      }\r\n\r\n      // Return updated data\r\n      return await getRoadmapById(roadmapId);\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error saving roadmap for course ${courseId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Get roadmap by ID directly (not through a course)\r\nexport const getRoadmapById = async (roadmapId) => {\r\n  try {\r\n    console.log(`Fetching roadmap data for ID ${roadmapId}`);\r\n\r\n    // Get the base roadmap data\r\n    const roadmapResponse = await api.get(`/roadmaps/${roadmapId}`);\r\n    const baseRoadmap = roadmapResponse.data;\r\n\r\n    // Get nodes\r\n    const nodesResponse = await api.get(`/roadmaps/${roadmapId}/nodes`);\r\n    const nodes =\r\n      nodesResponse.data && Array.isArray(nodesResponse.data)\r\n        ? transformNodesToClientFormat(nodesResponse.data)\r\n        : [];\r\n\r\n    // Get edges\r\n    const edgesResponse = await api.get(`/roadmaps/${roadmapId}/edges`);\r\n    const edges =\r\n      edgesResponse.data && Array.isArray(edgesResponse.data)\r\n        ? transformEdgesToClientFormat(edgesResponse.data)\r\n        : [];\r\n\r\n    console.log(\r\n      `Got ${nodes.length} nodes and ${edges.length} edges from roadmap ${roadmapId}`\r\n    );\r\n\r\n    // Return combined data\r\n    return {\r\n      ...baseRoadmap,\r\n      nodes,\r\n      edges,\r\n    };\r\n  } catch (error) {\r\n    console.error(`Error fetching roadmap ${roadmapId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Create a new course with roadmap data\r\nexport const createCourseWithRoadmap = async (courseData) => {\r\n  try {\r\n    console.log(\"Creating new course with roadmap data\");\r\n    const { nodes, edges, ...courseDetails } = courseData;\r\n\r\n    // Create the course first\r\n    const courseResponse = await api.post(\"/courses\", courseDetails);\r\n    const newCourse = courseResponse.data;\r\n    const courseId = newCourse.id;\r\n\r\n    // Then create and save roadmap if nodes/edges provided\r\n    if ((nodes && nodes.length > 0) || (edges && edges.length > 0)) {\r\n      await saveCourseRoadmap(courseId, { nodes, edges });\r\n    }\r\n\r\n    // Return the full course with roadmap data\r\n    return await getCourseRoadmap(courseId);\r\n  } catch (error) {\r\n    console.error(\"Error creating course with roadmap:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Transform nodes from server format to client format\r\nexport const transformNodesToClientFormat = (nodes) => {\r\n  return nodes\r\n    .map((node) => {\r\n      try {\r\n        // If node already has client format, return as is\r\n        if (node.type && node.position && node.data) {\r\n          return node;\r\n        }\r\n\r\n        // Parse the data if it's a string\r\n        let nodeData = node.data;\r\n        if (typeof node.data === \"string\") {\r\n          try {\r\n            nodeData = JSON.parse(node.data);\r\n          } catch (e) {\r\n            nodeData = { label: node.data };\r\n          }\r\n        }\r\n\r\n        return {\r\n          id: node.nodeIdentifier,\r\n          type: \"courseNode\", // Default node type\r\n          position: {\r\n            x: node.positionX || 0,\r\n            y: node.positionY || 0,\r\n          },\r\n          data: {\r\n            ...nodeData,\r\n            id: node.nodeIdentifier,\r\n          },\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming node to client format:\", error, node);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\n// Transform nodes from client format to server format\r\nexport const transformNodesToServerFormat = (nodes) => {\r\n  if (!Array.isArray(nodes)) {\r\n    console.error(\"Nodes is not an array:\", nodes);\r\n    return [];\r\n  }\r\n\r\n  return nodes\r\n    .map((node) => {\r\n      try {\r\n        if (!node) {\r\n          console.warn(\"Null or undefined node found\");\r\n          return null;\r\n        }\r\n\r\n        if (!node.id) {\r\n          console.warn(\"Node missing ID:\", node);\r\n          return null;\r\n        }\r\n\r\n        // Make sure position exists and has valid x, y values\r\n        const posX = parseFloat(node.position?.x) || 0;\r\n        const posY = parseFloat(node.position?.y) || 0;\r\n\r\n        // Process data object\r\n        let processedData;\r\n        if (typeof node.data === \"object\" && node.data !== null) {\r\n          // Make a clean copy without circular references\r\n          const safeData = {\r\n            ...(node.data || {}),\r\n            label: node.data.label || node.id,\r\n          };\r\n\r\n          // Remove any potentially problematic properties\r\n          delete safeData.events;\r\n          delete safeData.__proto__;\r\n          delete safeData.constructor;\r\n\r\n          processedData = safeData;\r\n        } else if (typeof node.data === \"string\") {\r\n          try {\r\n            // Try to parse if it's a JSON string\r\n            processedData = JSON.parse(node.data);\r\n          } catch (e) {\r\n            // If not valid JSON, use as label\r\n            processedData = { label: node.data };\r\n          }\r\n        } else {\r\n          // Default data\r\n          processedData = { label: node.id };\r\n        }\r\n\r\n        // Return in the format expected by the server\r\n        return {\r\n          nodeIdentifier: node.id,\r\n          positionX: posX,\r\n          positionY: posY,\r\n          data: JSON.stringify(processedData),\r\n          courseId: processedData.courseId || node.courseId || null,\r\n          roadmapId: node.roadmapId || null,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming node to server format:\", error, node);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\n// Transform edges from server format to client format\r\nexport const transformEdgesToClientFormat = (edges) => {\r\n  return edges\r\n    .map((edge) => {\r\n      try {\r\n        // If edge already has client format, return as is\r\n        if (edge.source && edge.target && edge.id) {\r\n          return edge;\r\n        }\r\n\r\n        // Parse the style if it's a string\r\n        let edgeStyle = {};\r\n        if (typeof edge.style === \"string\") {\r\n          try {\r\n            edgeStyle = JSON.parse(edge.style);\r\n          } catch (e) {\r\n            edgeStyle = {};\r\n          }\r\n        } else if (typeof edge.style === \"object\") {\r\n          edgeStyle = edge.style;\r\n        }\r\n\r\n        return {\r\n          id: edge.edgeIdentifier,\r\n          source: edge.source,\r\n          target: edge.target,\r\n          type: edge.type || \"smoothstep\",\r\n          animated: edge.animated || false,\r\n          style: edgeStyle,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming edge to client format:\", error, edge);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\n// Transform edges from client format to server format\r\nexport const transformEdgesToServerFormat = (edges) => {\r\n  if (!Array.isArray(edges)) {\r\n    console.error(\"Edges is not an array:\", edges);\r\n    return [];\r\n  }\r\n\r\n  return edges\r\n    .map((edge) => {\r\n      try {\r\n        if (!edge) {\r\n          console.warn(\"Null or undefined edge found\");\r\n          return null;\r\n        }\r\n\r\n        if (!edge.id || !edge.source || !edge.target) {\r\n          console.warn(\"Edge missing required properties:\", edge);\r\n          return null;\r\n        }\r\n\r\n        // Handle edge style\r\n        let styleString;\r\n        if (typeof edge.style === \"object\" && edge.style !== null) {\r\n          try {\r\n            // Make a clean copy to avoid circular references\r\n            const safeStyle = { ...edge.style };\r\n            styleString = JSON.stringify(safeStyle);\r\n          } catch (styleError) {\r\n            console.warn(\"Could not stringify edge style:\", styleError);\r\n            styleString = \"{}\";\r\n          }\r\n        } else if (typeof edge.style === \"string\") {\r\n          styleString = edge.style;\r\n        } else {\r\n          styleString = \"{}\";\r\n        }\r\n\r\n        // Return in the format expected by the server\r\n        return {\r\n          edgeIdentifier: edge.id,\r\n          source: edge.source,\r\n          target: edge.target,\r\n          type: edge.type || \"smoothstep\",\r\n          animated: edge.animated || false,\r\n          style: styleString,\r\n          roadmapId: edge.roadmapId || null,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming edge to server format:\", error, edge);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\nexport default {\r\n  getCourseRoadmap,\r\n  saveCourseRoadmap,\r\n  getRoadmapById,\r\n  createCourseWithRoadmap,\r\n  transformNodesToClientFormat,\r\n  transformNodesToServerFormat,\r\n  transformEdgesToClientFormat,\r\n  transformEdgesToServerFormat,\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}