{"ast":null,"code":"import api from \"./api\";\n\n// Get all roadmaps\nexport const getRoadmaps = async () => {\n  const response = await api.get(\"/roadmaps\");\n  return response.data;\n};\n\n// Get roadmap by ID\nexport const getRoadmapById = async id => {\n  const response = await api.get(`/roadmaps/${id}`);\n  // Format data to ensure consistent properties\n  const roadmapData = response.data;\n\n  // Make sure categoryName is available\n  if (roadmapData.category && !roadmapData.categoryName) {\n    roadmapData.categoryName = roadmapData.category.name;\n  }\n\n  // Make sure author info is available for backward compatibility\n  if (roadmapData.user && !roadmapData.author) {\n    roadmapData.author = roadmapData.user.username;\n  }\n  return roadmapData;\n};\n\n// Create new roadmap\nexport const createRoadmap = async roadmapData => {\n  const response = await api.post(\"/roadmaps\", roadmapData);\n  return response.data;\n};\n\n// Update roadmap\nexport const updateRoadmap = async (id, roadmapData) => {\n  const response = await api.put(`/roadmaps/${id}`, roadmapData);\n  return response.data;\n};\n\n// Delete roadmap\nexport const deleteRoadmap = async id => {\n  const response = await api.delete(`/roadmaps/${id}`);\n  return response.data;\n};\n\n// Get roadmap nodes - including course connections\nexport const getRoadmapNodes = async id => {\n  try {\n    console.log(`Fetching nodes for roadmap ${id}`);\n    const response = await api.get(`/roadmaps/${id}/nodes`);\n\n    // Transform server-side node format to client-side format\n    const transformedNodes = response.data.map(node => {\n      try {\n        // Parse the JSON data field\n        const nodeData = node.data ? JSON.parse(node.data) : {};\n\n        // Check if this node is linked to a course\n        let courseDetails = {};\n        if (node.courseId) {\n          // In a real implementation, you might fetch course details here\n          // or have them included in the node response\n          courseDetails = {\n            courseId: node.courseId\n            // Other course properties would be added here\n          };\n        }\n        return {\n          id: node.nodeIdentifier,\n          type: \"courseNode\",\n          // Default type for all nodes\n          position: {\n            x: node.positionX,\n            y: node.positionY\n          },\n          data: {\n            id: node.nodeIdentifier,\n            label: nodeData.label || \"\",\n            code: nodeData.code || \"\",\n            description: nodeData.description || \"\",\n            category: nodeData.category || \"\",\n            categoryId: nodeData.categoryId || null,\n            difficulty: nodeData.difficulty || \"beginner\",\n            credits: nodeData.credits || 0,\n            completed: nodeData.completed || false,\n            nodeColor: nodeData.nodeColor,\n            nodeBgColor: nodeData.nodeBgColor,\n            textColor: nodeData.textColor,\n            fontSize: nodeData.fontSize,\n            prerequisites: nodeData.prerequisites || \"\",\n            documentation: nodeData.documentation || \"\",\n            ...courseDetails\n          }\n        };\n      } catch (error) {\n        console.error(\"Error parsing node data:\", error, node);\n        return null;\n      }\n    }).filter(node => node !== null);\n    console.log(`Transformed ${transformedNodes.length} nodes`);\n    return transformedNodes;\n  } catch (error) {\n    console.error(\"Error fetching roadmap nodes:\", error);\n    throw error;\n  }\n};\n\n// Update roadmap nodes - including course connections\nexport const updateRoadmapNodes = async (id, nodes) => {\n  try {\n    var _nodes;\n    console.log(`[UPDATE] Updating ${((_nodes = nodes) === null || _nodes === void 0 ? void 0 : _nodes.length) || 0} nodes for roadmap ${id}`);\n\n    // Debug: in ra chi tiết về nodes\n    if (nodes && Array.isArray(nodes)) {\n      console.log(`[UPDATE] Nodes details: ${nodes.map(n => n.id).join(\", \")}`);\n    } else {\n      console.error(`[UPDATE] Invalid nodes data type: ${typeof nodes}`);\n      console.error(`[UPDATE] Nodes value:`, nodes);\n    }\n    if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {\n      console.warn(\"[UPDATE] Warning: No nodes provided or empty array\");\n      console.warn(\"[UPDATE] Using empty array for safety\");\n      nodes = []; // Đảm bảo luôn là mảng hợp lệ\n    }\n\n    // Transform to server format\n    const serverNodes = nodes.map(node => {\n      var _node, _node$position, _node$position2, _node$data, _serverNode$data, _serverNode$data2;\n      // Ensure all required node properties exist\n      if (!((_node = node) !== null && _node !== void 0 && _node.id)) {\n        console.error(\"[UPDATE] Node missing id:\", node);\n        // Generate a unique ID instead of throwing error\n        node = {\n          ...node,\n          id: `node_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`\n        };\n      }\n      if (!node.position) {\n        console.warn(`[UPDATE] Node ${node.id} missing position, using default`);\n        node.position = {\n          x: 0,\n          y: 0\n        };\n      }\n\n      // Ensure node data is well-formed JSON\n      let nodeDataString;\n      if (typeof node.data === \"object\") {\n        nodeDataString = JSON.stringify(node.data);\n      } else if (typeof node.data === \"string\") {\n        // Validate that it's already valid JSON\n        try {\n          JSON.parse(node.data); // Just testing if this works\n          nodeDataString = node.data;\n        } catch (e) {\n          console.error(`[UPDATE] Invalid JSON data for node ${node.id}:`, e);\n          nodeDataString = JSON.stringify({\n            label: node.data || \"Unknown\"\n          });\n        }\n      } else {\n        nodeDataString = JSON.stringify({\n          label: \"Unknown\"\n        });\n      }\n\n      // Create properly formatted server node\n      const serverNode = {\n        nodeIdentifier: node.id,\n        positionX: ((_node$position = node.position) === null || _node$position === void 0 ? void 0 : _node$position.x) || 0,\n        positionY: ((_node$position2 = node.position) === null || _node$position2 === void 0 ? void 0 : _node$position2.y) || 0,\n        data: nodeDataString,\n        courseId: ((_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.courseId) || null\n      };\n      console.log(`[UPDATE] Transformed node ${node.id} for server:`, {\n        nodeIdentifier: serverNode.nodeIdentifier,\n        positionX: serverNode.positionX,\n        positionY: serverNode.positionY,\n        dataLength: (_serverNode$data = serverNode.data) === null || _serverNode$data === void 0 ? void 0 : _serverNode$data.length,\n        dataPreview: (_serverNode$data2 = serverNode.data) === null || _serverNode$data2 === void 0 ? void 0 : _serverNode$data2.substring(0, 50),\n        courseId: serverNode.courseId\n      });\n      return serverNode;\n    });\n    console.log(`[UPDATE] Sending ${serverNodes.length} nodes to server`);\n\n    // Sử dụng endpoint tổng hợp đầu tiên\n    try {\n      const combinedResponse = await api.put(`/roadmaps/${id}/nodes-edges`, {\n        nodes: serverNodes\n      });\n      console.log(\"[UPDATE] Combined update successful:\", combinedResponse.data);\n      return combinedResponse.data;\n    } catch (combinedError) {\n      console.warn(\"[UPDATE] Combined endpoint failed, using specific endpoint:\", combinedError);\n      // Fallback to specific endpoint if combined fails\n      const response = await api.put(`/roadmaps/${id}/nodes`, {\n        nodes: serverNodes\n      });\n      console.log(\"[UPDATE] Nodes update successful:\", response.data);\n      return response.data;\n    }\n  } catch (error) {\n    console.error(\"[UPDATE] Error updating roadmap nodes:\", error);\n    throw error;\n  }\n};\n\n// Get roadmap edges\nexport const getRoadmapEdges = async id => {\n  try {\n    console.log(`Fetching edges for roadmap ${id}`);\n    const response = await api.get(`/roadmaps/${id}/edges`);\n\n    // Transform server-side edge format to client-side format\n    const transformedEdges = response.data.map(edge => {\n      try {\n        // Parse the JSON style field\n        const edgeStyle = edge.style ? JSON.parse(edge.style) : {};\n        return {\n          id: edge.edgeIdentifier,\n          source: edge.source,\n          target: edge.target,\n          type: edge.type || \"smoothstep\",\n          animated: edge.animated || false,\n          style: {\n            stroke: edgeStyle.stroke || \"#6d28d9\",\n            strokeWidth: edgeStyle.strokeWidth || 1\n          }\n        };\n      } catch (error) {\n        console.error(\"Error parsing edge data:\", error, edge);\n        return null;\n      }\n    }).filter(edge => edge !== null);\n    console.log(`Transformed ${transformedEdges.length} edges`);\n    return transformedEdges;\n  } catch (error) {\n    console.error(\"Error fetching roadmap edges:\", error);\n    throw error;\n  }\n};\n\n// Update roadmap edges\nexport const updateRoadmapEdges = async (id, edges) => {\n  try {\n    var _edges;\n    console.log(`[UPDATE] Updating ${((_edges = edges) === null || _edges === void 0 ? void 0 : _edges.length) || 0} edges for roadmap ${id}`);\n\n    // Debug: in ra chi tiết về edges\n    if (edges && Array.isArray(edges)) {\n      console.log(`[UPDATE] Edges details: ${edges.map(e => e.id).join(\", \")}`);\n    } else {\n      console.error(`[UPDATE] Invalid edges data type: ${typeof edges}`);\n      console.error(`[UPDATE] Edges value:`, edges);\n    }\n    if (!edges || !Array.isArray(edges) || edges.length === 0) {\n      console.warn(\"[UPDATE] Warning: No edges provided or empty array\");\n      console.warn(\"[UPDATE] Using empty array for safety\");\n      edges = []; // Đảm bảo luôn là mảng hợp lệ\n    }\n\n    // Transform to server format\n    const serverEdges = edges.map(edge => {\n      // Validate required edge properties\n      if (!edge.id || !edge.source || !edge.target) {\n        console.error(\"[UPDATE] Edge missing required properties:\", edge);\n        throw new Error(\"Edge is missing required properties\");\n      }\n\n      // Ensure style is well-formed JSON\n      let styleString;\n      if (typeof edge.style === \"object\") {\n        styleString = JSON.stringify(edge.style);\n      } else if (typeof edge.style === \"string\") {\n        // Validate that it's already valid JSON\n        try {\n          JSON.parse(edge.style); // Just testing if this works\n          styleString = edge.style;\n        } catch (e) {\n          console.error(`[UPDATE] Invalid JSON style for edge ${edge.id}:`, e);\n          styleString = JSON.stringify({\n            stroke: \"#999\"\n          });\n        }\n      } else {\n        styleString = JSON.stringify({\n          stroke: \"#999\"\n        });\n      }\n\n      // Create properly formatted server edge\n      const serverEdge = {\n        edgeIdentifier: edge.id,\n        source: edge.source,\n        target: edge.target,\n        type: edge.type || \"smoothstep\",\n        animated: edge.animated || false,\n        style: styleString\n      };\n      console.log(`[UPDATE] Transformed edge ${edge.id} for server:`, {\n        edgeIdentifier: serverEdge.edgeIdentifier,\n        source: serverEdge.source,\n        target: serverEdge.target,\n        type: serverEdge.type\n      });\n      return serverEdge;\n    });\n    console.log(`[UPDATE] Sending ${serverEdges.length} edges to server`);\n\n    // Sử dụng endpoint tổng hợp đầu tiên\n    try {\n      const combinedResponse = await api.put(`/roadmaps/${id}/nodes-edges`, {\n        edges: serverEdges\n      });\n      console.log(\"[UPDATE] Combined update successful:\", combinedResponse.data);\n      return combinedResponse.data;\n    } catch (combinedError) {\n      console.warn(\"[UPDATE] Combined endpoint failed, using specific endpoint:\", combinedError);\n      // Fallback to specific endpoint if combined fails\n      const response = await api.put(`/roadmaps/${id}/edges`, {\n        edges: serverEdges\n      });\n      console.log(\"[UPDATE] Edges update successful:\", response.data);\n      return response.data;\n    }\n  } catch (error) {\n    console.error(\"[UPDATE] Error updating roadmap edges:\", error);\n    throw error;\n  }\n};\n\n// Toggle favorite roadmap\nexport const toggleFavoriteRoadmap = async id => {\n  const response = await api.post(`/roadmaps/${id}/favorite`);\n  return response.data;\n};\n\n// Get user favorites\nexport const getUserFavorites = async () => {\n  const response = await api.get(\"/roadmaps/favorites\");\n  return response.data;\n};\n\n// Link a course to a roadmap node\nexport const linkCourseToNode = async (roadmapId, nodeId, courseId) => {\n  try {\n    const response = await api.post(`/roadmaps/${roadmapId}/nodes/${nodeId}/link-course`, {\n      courseId: Number(courseId)\n    });\n    return response.data;\n  } catch (error) {\n    console.error(\"Error linking course to node:\", error);\n    throw error;\n  }\n};","map":{"version":3,"names":["api","getRoadmaps","response","get","data","getRoadmapById","id","roadmapData","category","categoryName","name","user","author","username","createRoadmap","post","updateRoadmap","put","deleteRoadmap","delete","getRoadmapNodes","console","log","transformedNodes","map","node","nodeData","JSON","parse","courseDetails","courseId","nodeIdentifier","type","position","x","positionX","y","positionY","label","code","description","categoryId","difficulty","credits","completed","nodeColor","nodeBgColor","textColor","fontSize","prerequisites","documentation","error","filter","length","updateRoadmapNodes","nodes","_nodes","Array","isArray","n","join","warn","serverNodes","_node","_node$position","_node$position2","_node$data","_serverNode$data","_serverNode$data2","Date","now","Math","random","toString","substring","nodeDataString","stringify","e","serverNode","dataLength","dataPreview","combinedResponse","combinedError","getRoadmapEdges","transformedEdges","edge","edgeStyle","style","edgeIdentifier","source","target","animated","stroke","strokeWidth","updateRoadmapEdges","edges","_edges","serverEdges","Error","styleString","serverEdge","toggleFavoriteRoadmap","getUserFavorites","linkCourseToNode","roadmapId","nodeId","Number"],"sources":["D:/CyberPath/it-roadmap/client/src/services/roadmapService.js"],"sourcesContent":["import api from \"./api\";\n\n// Get all roadmaps\nexport const getRoadmaps = async () => {\n  const response = await api.get(\"/roadmaps\");\n  return response.data;\n};\n\n// Get roadmap by ID\nexport const getRoadmapById = async (id) => {\n  const response = await api.get(`/roadmaps/${id}`);\n  // Format data to ensure consistent properties\n  const roadmapData = response.data;\n\n  // Make sure categoryName is available\n  if (roadmapData.category && !roadmapData.categoryName) {\n    roadmapData.categoryName = roadmapData.category.name;\n  }\n\n  // Make sure author info is available for backward compatibility\n  if (roadmapData.user && !roadmapData.author) {\n    roadmapData.author = roadmapData.user.username;\n  }\n\n  return roadmapData;\n};\n\n// Create new roadmap\nexport const createRoadmap = async (roadmapData) => {\n  const response = await api.post(\"/roadmaps\", roadmapData);\n  return response.data;\n};\n\n// Update roadmap\nexport const updateRoadmap = async (id, roadmapData) => {\n  const response = await api.put(`/roadmaps/${id}`, roadmapData);\n  return response.data;\n};\n\n// Delete roadmap\nexport const deleteRoadmap = async (id) => {\n  const response = await api.delete(`/roadmaps/${id}`);\n  return response.data;\n};\n\n// Get roadmap nodes - including course connections\nexport const getRoadmapNodes = async (id) => {\n  try {\n    console.log(`Fetching nodes for roadmap ${id}`);\n    const response = await api.get(`/roadmaps/${id}/nodes`);\n\n    // Transform server-side node format to client-side format\n    const transformedNodes = response.data\n      .map((node) => {\n        try {\n          // Parse the JSON data field\n          const nodeData = node.data ? JSON.parse(node.data) : {};\n\n          // Check if this node is linked to a course\n          let courseDetails = {};\n          if (node.courseId) {\n            // In a real implementation, you might fetch course details here\n            // or have them included in the node response\n            courseDetails = {\n              courseId: node.courseId,\n              // Other course properties would be added here\n            };\n          }\n\n          return {\n            id: node.nodeIdentifier,\n            type: \"courseNode\", // Default type for all nodes\n            position: {\n              x: node.positionX,\n              y: node.positionY,\n            },\n            data: {\n              id: node.nodeIdentifier,\n              label: nodeData.label || \"\",\n              code: nodeData.code || \"\",\n              description: nodeData.description || \"\",\n              category: nodeData.category || \"\",\n              categoryId: nodeData.categoryId || null,\n              difficulty: nodeData.difficulty || \"beginner\",\n              credits: nodeData.credits || 0,\n              completed: nodeData.completed || false,\n              nodeColor: nodeData.nodeColor,\n              nodeBgColor: nodeData.nodeBgColor,\n              textColor: nodeData.textColor,\n              fontSize: nodeData.fontSize,\n              prerequisites: nodeData.prerequisites || \"\",\n              documentation: nodeData.documentation || \"\",\n              ...courseDetails,\n            },\n          };\n        } catch (error) {\n          console.error(\"Error parsing node data:\", error, node);\n          return null;\n        }\n      })\n      .filter((node) => node !== null);\n\n    console.log(`Transformed ${transformedNodes.length} nodes`);\n    return transformedNodes;\n  } catch (error) {\n    console.error(\"Error fetching roadmap nodes:\", error);\n    throw error;\n  }\n};\n\n// Update roadmap nodes - including course connections\nexport const updateRoadmapNodes = async (id, nodes) => {\n  try {\n    console.log(\n      `[UPDATE] Updating ${nodes?.length || 0} nodes for roadmap ${id}`\n    );\n\n    // Debug: in ra chi tiết về nodes\n    if (nodes && Array.isArray(nodes)) {\n      console.log(\n        `[UPDATE] Nodes details: ${nodes.map((n) => n.id).join(\", \")}`\n      );\n    } else {\n      console.error(`[UPDATE] Invalid nodes data type: ${typeof nodes}`);\n      console.error(`[UPDATE] Nodes value:`, nodes);\n    }\n\n    if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {\n      console.warn(\"[UPDATE] Warning: No nodes provided or empty array\");\n      console.warn(\"[UPDATE] Using empty array for safety\");\n      nodes = []; // Đảm bảo luôn là mảng hợp lệ\n    }\n\n    // Transform to server format\n    const serverNodes = nodes.map((node) => {\n      // Ensure all required node properties exist\n      if (!node?.id) {\n        console.error(\"[UPDATE] Node missing id:\", node);\n        // Generate a unique ID instead of throwing error\n        node = {\n          ...node,\n          id: `node_${Date.now()}_${Math.random()\n            .toString(36)\n            .substring(2, 9)}`,\n        };\n      }\n\n      if (!node.position) {\n        console.warn(\n          `[UPDATE] Node ${node.id} missing position, using default`\n        );\n        node.position = { x: 0, y: 0 };\n      }\n\n      // Ensure node data is well-formed JSON\n      let nodeDataString;\n      if (typeof node.data === \"object\") {\n        nodeDataString = JSON.stringify(node.data);\n      } else if (typeof node.data === \"string\") {\n        // Validate that it's already valid JSON\n        try {\n          JSON.parse(node.data); // Just testing if this works\n          nodeDataString = node.data;\n        } catch (e) {\n          console.error(`[UPDATE] Invalid JSON data for node ${node.id}:`, e);\n          nodeDataString = JSON.stringify({ label: node.data || \"Unknown\" });\n        }\n      } else {\n        nodeDataString = JSON.stringify({ label: \"Unknown\" });\n      }\n\n      // Create properly formatted server node\n      const serverNode = {\n        nodeIdentifier: node.id,\n        positionX: node.position?.x || 0,\n        positionY: node.position?.y || 0,\n        data: nodeDataString,\n        courseId: node.data?.courseId || null,\n      };\n\n      console.log(`[UPDATE] Transformed node ${node.id} for server:`, {\n        nodeIdentifier: serverNode.nodeIdentifier,\n        positionX: serverNode.positionX,\n        positionY: serverNode.positionY,\n        dataLength: serverNode.data?.length,\n        dataPreview: serverNode.data?.substring(0, 50),\n        courseId: serverNode.courseId,\n      });\n\n      return serverNode;\n    });\n\n    console.log(`[UPDATE] Sending ${serverNodes.length} nodes to server`);\n\n    // Sử dụng endpoint tổng hợp đầu tiên\n    try {\n      const combinedResponse = await api.put(`/roadmaps/${id}/nodes-edges`, {\n        nodes: serverNodes,\n      });\n      console.log(\n        \"[UPDATE] Combined update successful:\",\n        combinedResponse.data\n      );\n      return combinedResponse.data;\n    } catch (combinedError) {\n      console.warn(\n        \"[UPDATE] Combined endpoint failed, using specific endpoint:\",\n        combinedError\n      );\n      // Fallback to specific endpoint if combined fails\n      const response = await api.put(`/roadmaps/${id}/nodes`, {\n        nodes: serverNodes,\n      });\n      console.log(\"[UPDATE] Nodes update successful:\", response.data);\n      return response.data;\n    }\n  } catch (error) {\n    console.error(\"[UPDATE] Error updating roadmap nodes:\", error);\n    throw error;\n  }\n};\n\n// Get roadmap edges\nexport const getRoadmapEdges = async (id) => {\n  try {\n    console.log(`Fetching edges for roadmap ${id}`);\n    const response = await api.get(`/roadmaps/${id}/edges`);\n\n    // Transform server-side edge format to client-side format\n    const transformedEdges = response.data\n      .map((edge) => {\n        try {\n          // Parse the JSON style field\n          const edgeStyle = edge.style ? JSON.parse(edge.style) : {};\n\n          return {\n            id: edge.edgeIdentifier,\n            source: edge.source,\n            target: edge.target,\n            type: edge.type || \"smoothstep\",\n            animated: edge.animated || false,\n            style: {\n              stroke: edgeStyle.stroke || \"#6d28d9\",\n              strokeWidth: edgeStyle.strokeWidth || 1,\n            },\n          };\n        } catch (error) {\n          console.error(\"Error parsing edge data:\", error, edge);\n          return null;\n        }\n      })\n      .filter((edge) => edge !== null);\n\n    console.log(`Transformed ${transformedEdges.length} edges`);\n    return transformedEdges;\n  } catch (error) {\n    console.error(\"Error fetching roadmap edges:\", error);\n    throw error;\n  }\n};\n\n// Update roadmap edges\nexport const updateRoadmapEdges = async (id, edges) => {\n  try {\n    console.log(\n      `[UPDATE] Updating ${edges?.length || 0} edges for roadmap ${id}`\n    );\n\n    // Debug: in ra chi tiết về edges\n    if (edges && Array.isArray(edges)) {\n      console.log(\n        `[UPDATE] Edges details: ${edges.map((e) => e.id).join(\", \")}`\n      );\n    } else {\n      console.error(`[UPDATE] Invalid edges data type: ${typeof edges}`);\n      console.error(`[UPDATE] Edges value:`, edges);\n    }\n\n    if (!edges || !Array.isArray(edges) || edges.length === 0) {\n      console.warn(\"[UPDATE] Warning: No edges provided or empty array\");\n      console.warn(\"[UPDATE] Using empty array for safety\");\n      edges = []; // Đảm bảo luôn là mảng hợp lệ\n    }\n\n    // Transform to server format\n    const serverEdges = edges.map((edge) => {\n      // Validate required edge properties\n      if (!edge.id || !edge.source || !edge.target) {\n        console.error(\"[UPDATE] Edge missing required properties:\", edge);\n        throw new Error(\"Edge is missing required properties\");\n      }\n\n      // Ensure style is well-formed JSON\n      let styleString;\n      if (typeof edge.style === \"object\") {\n        styleString = JSON.stringify(edge.style);\n      } else if (typeof edge.style === \"string\") {\n        // Validate that it's already valid JSON\n        try {\n          JSON.parse(edge.style); // Just testing if this works\n          styleString = edge.style;\n        } catch (e) {\n          console.error(`[UPDATE] Invalid JSON style for edge ${edge.id}:`, e);\n          styleString = JSON.stringify({ stroke: \"#999\" });\n        }\n      } else {\n        styleString = JSON.stringify({ stroke: \"#999\" });\n      }\n\n      // Create properly formatted server edge\n      const serverEdge = {\n        edgeIdentifier: edge.id,\n        source: edge.source,\n        target: edge.target,\n        type: edge.type || \"smoothstep\",\n        animated: edge.animated || false,\n        style: styleString,\n      };\n\n      console.log(`[UPDATE] Transformed edge ${edge.id} for server:`, {\n        edgeIdentifier: serverEdge.edgeIdentifier,\n        source: serverEdge.source,\n        target: serverEdge.target,\n        type: serverEdge.type,\n      });\n\n      return serverEdge;\n    });\n\n    console.log(`[UPDATE] Sending ${serverEdges.length} edges to server`);\n\n    // Sử dụng endpoint tổng hợp đầu tiên\n    try {\n      const combinedResponse = await api.put(`/roadmaps/${id}/nodes-edges`, {\n        edges: serverEdges,\n      });\n      console.log(\n        \"[UPDATE] Combined update successful:\",\n        combinedResponse.data\n      );\n      return combinedResponse.data;\n    } catch (combinedError) {\n      console.warn(\n        \"[UPDATE] Combined endpoint failed, using specific endpoint:\",\n        combinedError\n      );\n      // Fallback to specific endpoint if combined fails\n      const response = await api.put(`/roadmaps/${id}/edges`, {\n        edges: serverEdges,\n      });\n      console.log(\"[UPDATE] Edges update successful:\", response.data);\n      return response.data;\n    }\n  } catch (error) {\n    console.error(\"[UPDATE] Error updating roadmap edges:\", error);\n    throw error;\n  }\n};\n\n// Toggle favorite roadmap\nexport const toggleFavoriteRoadmap = async (id) => {\n  const response = await api.post(`/roadmaps/${id}/favorite`);\n  return response.data;\n};\n\n// Get user favorites\nexport const getUserFavorites = async () => {\n  const response = await api.get(\"/roadmaps/favorites\");\n  return response.data;\n};\n\n// Link a course to a roadmap node\nexport const linkCourseToNode = async (roadmapId, nodeId, courseId) => {\n  try {\n    const response = await api.post(\n      `/roadmaps/${roadmapId}/nodes/${nodeId}/link-course`,\n      {\n        courseId: Number(courseId),\n      }\n    );\n    return response.data;\n  } catch (error) {\n    console.error(\"Error linking course to node:\", error);\n    throw error;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}