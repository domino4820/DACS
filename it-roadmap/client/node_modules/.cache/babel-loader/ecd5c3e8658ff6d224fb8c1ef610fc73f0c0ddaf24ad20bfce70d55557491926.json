{"ast":null,"code":"\"use client\";\n\nvar _jsxFileName = \"D:\\\\CyberPath\\\\it-roadmap\\\\client\\\\src\\\\components\\\\RoadmapView.jsx\",\n  _s = $RefreshSig$();\nimport { useState, useCallback, useEffect, useRef } from \"react\";\nimport ReactFlow, { MiniMap, Controls, Background, useNodesState, useEdgesState, addEdge, Panel, ReactFlowProvider, useReactFlow, MarkerType, Connection } from \"reactflow\";\nimport \"reactflow/dist/style.css\";\nimport { Tabs, TabsList, TabsTrigger } from \"./ui/tabs\";\nimport { Button } from \"./ui/button\";\nimport { useToast } from \"./ui/use-toast\";\nimport { PlusCircle, Save, Trash, Plus, X, Link as LinkIcon, LinkOff, Palette } from \"lucide-react\";\nimport CourseNode from \"./CourseNode\";\nimport CourseInfoPanel from \"./CourseInfoPanel\";\nimport AddCourseDialog from \"./AddCourseDialog\";\nimport RoadmapEditorPanel from \"./RoadmapEditorPanel\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst nodeTypes = {\n  courseNode: CourseNode\n};\nfunction RoadmapViewInner({\n  id,\n  initialNodes = [],\n  initialEdges = [],\n  isEditing = false,\n  readOnly = false,\n  onSave,\n  onInternalUpdate\n}) {\n  _s();\n  const {\n    toast\n  } = useToast();\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n  const [selectedNode, setSelectedNode] = useState(null);\n  const [selectedCategory, setSelectedCategory] = useState(\"all\");\n  const [isAddCourseOpen, setIsAddCourseOpen] = useState(false);\n  const [editMode, setEditMode] = useState(\"select\"); // select, connect, add, delete\n  const [connectionType, setConnectionType] = useState(\"arrow\"); // arrow, none\n  const [showEditorPanel, setShowEditorPanel] = useState(true);\n  const reactFlowWrapper = useRef(null);\n  const reactFlowInstance = useReactFlow();\n  const [undoStack, setUndoStack] = useState([]);\n  const [redoStack, setRedoStack] = useState([]);\n  const isInitialMount = useRef(true);\n  // Keep track of manually added nodes to prevent them from being lost\n  const addedNodesRef = useRef([]);\n\n  // Define handleCompleteToggle before it's used\n  const handleCompleteToggle = useCallback((nodeId, completed) => {\n    var _nodes$find;\n    if (readOnly) return;\n\n    // Get the current timestamp\n    const completedAt = completed ? new Date().toISOString() : null;\n    setNodes(nds => nds.map(node => {\n      if (node.id === nodeId) {\n        return {\n          ...node,\n          data: {\n            ...node.data,\n            completed,\n            completedAt\n          }\n        };\n      }\n      return node;\n    }));\n    toast({\n      title: completed ? \"Course marked as completed\" : \"Course marked as incomplete\",\n      description: `You've ${completed ? \"completed\" : \"unmarked\"} ${(_nodes$find = nodes.find(n => n.id === nodeId)) === null || _nodes$find === void 0 ? void 0 : _nodes$find.data.label}`\n    });\n  }, [nodes, setNodes, toast, readOnly]);\n\n  // Set initial nodes and edges when they change\n  useEffect(() => {\n    // Skip effect if no initial data\n    if (!(initialNodes !== null && initialNodes !== void 0 && initialNodes.length) && !(initialEdges !== null && initialEdges !== void 0 && initialEdges.length)) {\n      return;\n    }\n\n    // Only run this effect once on initial mount or when initialNodes actually changes\n    if (isInitialMount.current || (initialNodes === null || initialNodes === void 0 ? void 0 : initialNodes.length) > 0) {\n      console.log(\"[FLOW] Processing nodes:\", initialNodes === null || initialNodes === void 0 ? void 0 : initialNodes.length);\n      if ((initialNodes === null || initialNodes === void 0 ? void 0 : initialNodes.length) > 0) {\n        // Process nodes once with required properties for display\n        const processedNodes = initialNodes.map(node => {\n          var _node$data;\n          return {\n            ...node,\n            type: \"courseNode\",\n            // Ensure position exists\n            position: node.position || {\n              x: Math.random() * 500,\n              y: Math.random() * 300\n            },\n            data: {\n              ...node.data,\n              showQuickToggle: true,\n              onQuickToggle: handleCompleteToggle,\n              // Ensure label exists\n              label: ((_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.label) || \"Untitled Node\"\n            }\n          };\n        });\n\n        // Merge with any manually added nodes that aren't in initialNodes yet\n        const initialNodeIds = new Set(initialNodes.map(n => n.id));\n        const manuallyAddedMissingNodes = addedNodesRef.current.filter(n => !initialNodeIds.has(n.id));\n        if (manuallyAddedMissingNodes.length > 0) {\n          console.log(`[FLOW] Merging ${manuallyAddedMissingNodes.length} manually added nodes with initialNodes`);\n\n          // Set state with both initial and manually added nodes\n          setNodes([...processedNodes, ...manuallyAddedMissingNodes]);\n        } else {\n          console.log(\"[FLOW] Setting nodes from initialNodes only\");\n          setNodes(processedNodes);\n        }\n      }\n      if ((initialEdges === null || initialEdges === void 0 ? void 0 : initialEdges.length) > 0) {\n        console.log(\"[FLOW] Setting initial edges:\", initialEdges.length);\n        setEdges([...initialEdges]);\n      }\n\n      // Schedule viewport setup after nodes are rendered\n      const timeoutId = setTimeout(() => {\n        const viewportEl = document.querySelector(\".react-flow__viewport\");\n        if (viewportEl) {\n          viewportEl.style.transitionProperty = \"transform\";\n          viewportEl.style.transitionDuration = \"0.2s\";\n        }\n      }, 300);\n      isInitialMount.current = false;\n      return () => clearTimeout(timeoutId);\n    }\n  }, [initialNodes, initialEdges, setNodes, setEdges, handleCompleteToggle]);\n\n  // Separate effect to monitor changes in props vs internal state\n  useEffect(() => {\n    if (isInitialMount.current) return; // Skip on initial mount\n\n    // Check if initialNodes changed after first render (rare, but possible)\n    if (initialNodes && initialNodes.length > 0) {\n      // Compare IDs only to prevent needless updates\n      const currentIds = new Set(nodes.map(n => n.id));\n      const initialIds = new Set(initialNodes.map(n => n.id));\n\n      // Only update if different nodes are provided\n      if (initialIds.size !== currentIds.size || initialNodes.some(n => !currentIds.has(n.id))) {\n        console.log(\"[FLOW] External nodes updated, refreshing\");\n        const processedNodes = initialNodes.map(node => {\n          var _node$data2;\n          return {\n            ...node,\n            type: \"courseNode\",\n            position: node.position || {\n              x: Math.random() * 500,\n              y: Math.random() * 300\n            },\n            data: {\n              ...node.data,\n              showQuickToggle: true,\n              onQuickToggle: handleCompleteToggle,\n              label: ((_node$data2 = node.data) === null || _node$data2 === void 0 ? void 0 : _node$data2.label) || \"Untitled Node\"\n            }\n          };\n        });\n        setNodes(processedNodes);\n      }\n    }\n  }, [initialNodes, nodes, setNodes, handleCompleteToggle]);\n\n  // Update parent component with internal changes\n  useEffect(() => {\n    if (isInitialMount.current) return; // Skip during initial render\n\n    const timer = setTimeout(() => {\n      if ((nodes.length > 0 || edges.length > 0) && typeof onInternalUpdate === \"function\") {\n        console.log(\"[FLOW] Updating parent with current state\");\n        onInternalUpdate(nodes, edges);\n      }\n    }, 300);\n    return () => clearTimeout(timer);\n  }, [nodes, edges, onInternalUpdate]);\n\n  // Save current state for undo feature\n  const saveCurrentState = useCallback(() => {\n    setUndoStack(prev => [...prev, {\n      nodes: [...nodes],\n      edges: [...edges]\n    }]);\n    setRedoStack([]);\n  }, [nodes, edges]);\n  const onConnect = useCallback(params => {\n    saveCurrentState();\n    // Add marker and apply current edge style settings\n    const newEdge = {\n      ...params,\n      id: `edge-${Date.now()}`,\n      type: \"smoothstep\",\n      animated: true,\n      style: {\n        stroke: \"#6d28d9\"\n      },\n      // Only add marker if connection type is arrow\n      ...(connectionType === \"arrow\" && {\n        markerEnd: {\n          type: MarkerType.ArrowClosed,\n          width: 20,\n          height: 20,\n          color: \"#6d28d9\"\n        }\n      }),\n      data: {\n        connectionType\n      }\n    };\n    setEdges(eds => addEdge(newEdge, eds));\n    toast({\n      title: \"Connection added\",\n      description: \"A new connection has been created between nodes\"\n    });\n  }, [setEdges, saveCurrentState, toast, connectionType]);\n  const onNodeClick = useCallback((event, node) => {\n    event.stopPropagation();\n    if (editMode === \"delete\") {\n      // Delete mode: remove the node\n      saveCurrentState();\n      setNodes(nodes.filter(n => n.id !== node.id));\n      // Also remove any connected edges\n      setEdges(edges.filter(e => e.source !== node.id && e.target !== node.id));\n      toast({\n        title: \"Node deleted\",\n        description: `${node.data.label} has been removed from the roadmap`\n      });\n    } else if (editMode === \"connect\" && selectedNode) {\n      // Connect mode: create an edge between selectedNode and this node\n      if (selectedNode.id !== node.id) {\n        const newEdge = {\n          id: `edge-${Date.now()}`,\n          source: selectedNode.id,\n          target: node.id,\n          type: \"smoothstep\",\n          animated: true,\n          style: {\n            stroke: \"#6d28d9\"\n          },\n          ...(connectionType === \"arrow\" && {\n            markerEnd: {\n              type: MarkerType.ArrowClosed,\n              width: 20,\n              height: 20,\n              color: \"#6d28d9\"\n            }\n          }),\n          data: {\n            connectionType\n          }\n        };\n        saveCurrentState();\n        setEdges(eds => [...eds, newEdge]);\n        setSelectedNode(null);\n        setEditMode(\"select\");\n        toast({\n          title: \"Connection created\",\n          description: `Connected ${selectedNode.data.label} to ${node.data.label}`\n        });\n      }\n    } else if (editMode === \"select\") {\n      // Regular select mode: show node details\n      setSelectedNode(node);\n    }\n  }, [editMode, selectedNode, nodes, edges, setNodes, setEdges, saveCurrentState, toast]);\n  const onPaneClick = useCallback(() => {\n    // In regular mode, clicking the pane should deselect the node\n    setSelectedNode(null);\n\n    // If in connect mode but no node selected, return to select mode\n    if (editMode === \"connect\" && selectedNode) {\n      setEditMode(\"select\");\n      setSelectedNode(null);\n      toast({\n        title: \"Connection cancelled\",\n        description: \"Node connection has been cancelled\"\n      });\n    }\n  }, [editMode, selectedNode, toast]);\n  const handleSaveRoadmap = useCallback(() => {\n    if (onSave) {\n      console.log(\"[VIEW] Starting roadmap save process\");\n      console.log(\"[VIEW] Current nodes:\", nodes.length);\n      console.log(\"[VIEW] Current edges:\", edges.length);\n\n      // Đảm bảo không có node nào bị thiếu dữ liệu quan trọng\n      const cleanedNodes = nodes.map(node => {\n        var _node$data3;\n        if (!node.id) {\n          console.error(\"[VIEW] Node missing ID:\", node);\n          // Generate a unique ID if missing\n          node.id = `node_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n        }\n        if (!node.position) {\n          console.error(\"[VIEW] Node missing position:\", node);\n          // Default position\n          node.position = {\n            x: 0,\n            y: 0\n          };\n        }\n        if (!node.data) {\n          console.error(\"[VIEW] Node missing data:\", node);\n          // Default minimal data\n          node.data = {\n            label: \"Node \" + node.id\n          };\n        }\n\n        // Đảm bảo node có đủ thông tin cần thiết\n        return {\n          ...node,\n          type: node.type || \"courseNode\",\n          // Loại node mặc định\n          data: {\n            ...(node.data || {}),\n            id: node.id,\n            // Đảm bảo ID trong data giống với ID của node\n            label: ((_node$data3 = node.data) === null || _node$data3 === void 0 ? void 0 : _node$data3.label) || \"Untitled\" // Ít nhất phải có nhãn\n          }\n        };\n      });\n\n      // Đảm bảo các edge có đủ thông tin cần thiết\n      const cleanedEdges = edges.map(edge => {\n        if (!edge.source || !edge.target) {\n          console.error(\"[VIEW] Edge missing source or target:\", edge);\n          return null; // Skip invalid edges\n        }\n        if (!edge.id) {\n          console.error(\"[VIEW] Edge missing ID:\", edge);\n          // Generate a unique ID if missing\n          edge.id = `edge_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n        }\n        return {\n          ...edge,\n          type: edge.type || \"smoothstep\" // Loại edge mặc định\n        };\n      }).filter(Boolean); // Lọc bỏ các edge null\n\n      console.log(\"[VIEW] Cleaned nodes for saving:\", cleanedNodes.length);\n      console.log(\"[VIEW] Node data sample:\", cleanedNodes[0]);\n      console.log(\"[VIEW] Cleaned edges for saving:\", cleanedEdges.length);\n      if (cleanedEdges.length > 0) {\n        console.log(\"[VIEW] Edge data sample:\", cleanedEdges[0]);\n      }\n\n      // Thông báo cho người dùng\n      toast({\n        title: \"Saving roadmap...\",\n        description: `Saving ${cleanedNodes.length} nodes and ${cleanedEdges.length} edges`\n      });\n\n      // Lưu dữ liệu vào trạng thái cục bộ\n      setNodes(cleanedNodes);\n      setEdges(cleanedEdges);\n\n      // Gọi hàm callback onSave để lưu dữ liệu\n      console.log(\"[VIEW] Calling onSave with cleaned data\");\n      onSave(cleanedNodes, cleanedEdges);\n    } else {\n      console.warn(\"[VIEW] Save handler not provided. Cannot save roadmap.\");\n      toast({\n        title: \"Cannot save roadmap\",\n        description: \"Save handler not configured\",\n        variant: \"destructive\"\n      });\n    }\n  }, [nodes, edges, onSave, toast, setNodes, setEdges]);\n  const handleAddCourse = useCallback(courseData => {\n    saveCurrentState();\n\n    // Generate a unique node ID\n    const newNodeId = `node-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n\n    // Calculate an appropriate position for the new node\n    let position = {\n      x: Math.random() * 300 + 100,\n      y: Math.random() * 200 + 100\n    };\n\n    // If we have a reactFlowInstance, use it for better positioning\n    if (reactFlowInstance) {\n      try {\n        // Get the viewport center\n        const viewport = reactFlowInstance.getViewport();\n\n        // Convert screen center to flow position\n        const center = reactFlowInstance.screenToFlowPosition({\n          x: window.innerWidth / 2,\n          y: window.innerHeight / 2\n        });\n        position = {\n          x: center.x,\n          y: center.y\n        };\n\n        // Add some randomness to avoid direct overlap\n        position.x += (Math.random() - 0.5) * 100;\n        position.y += (Math.random() - 0.5) * 100;\n\n        // If existing nodes are nearby, move new node to avoid overlap\n        if (nodes.length > 0) {\n          const occupied = nodes.some(node => Math.abs(node.position.x - position.x) < 250 && Math.abs(node.position.y - position.y) < 100);\n          if (occupied) {\n            // Find a quadrant with fewer nodes and place there\n            const quadrants = [{\n              x: 1,\n              y: 1\n            }, {\n              x: -1,\n              y: 1\n            }, {\n              x: -1,\n              y: -1\n            }, {\n              x: 1,\n              y: -1\n            }];\n            const offset = quadrants[nodes.length % quadrants.length];\n            position.x += offset.x * 300;\n            position.y += offset.y * 200;\n          }\n        }\n      } catch (error) {\n        console.error(\"[FLOW] Error calculating node position:\", error);\n        // Fallback position if there's an error\n        position = {\n          x: 100 + nodes.length * 250,\n          y: 150 + nodes.length % 2 * 200\n        };\n      }\n    } else {\n      // Without reactFlowInstance, use basic spacing\n      position = {\n        x: 100 + nodes.length * 250,\n        y: 150 + nodes.length % 2 * 200\n      };\n    }\n    console.log(`[FLOW] Creating new node at position: x=${position.x}, y=${position.y}`);\n\n    // Create the new node with proper data\n    const newNode = {\n      id: newNodeId,\n      type: \"courseNode\",\n      position,\n      data: {\n        ...courseData,\n        completed: false,\n        completedAt: null,\n        showQuickToggle: true,\n        onQuickToggle: handleCompleteToggle,\n        id: newNodeId\n      }\n    };\n\n    // Store the new node in our ref to ensure it's not lost during state updates\n    addedNodesRef.current = [...addedNodesRef.current, newNode];\n\n    // Add node to state, ensuring we include all previously added nodes\n    setNodes(currentNodes => {\n      // Make sure we're not duplicating nodes\n      const existingIds = new Set(currentNodes.map(n => n.id));\n\n      // Filter out nodes from our ref that are already in the current nodes\n      const missingAddedNodes = addedNodesRef.current.filter(n => !existingIds.has(n.id));\n\n      // Create new nodes array with all existing + missing added nodes + new node\n      const updatedNodes = [...currentNodes];\n\n      // Only add the new node if it's not already in the array\n      if (!existingIds.has(newNode.id)) {\n        updatedNodes.push(newNode);\n      }\n      console.log(`[FLOW] Updated nodes array, now contains ${updatedNodes.length} nodes`);\n      return updatedNodes;\n    });\n\n    // Close the dialog\n    setIsAddCourseOpen(false);\n\n    // Show success toast\n    toast({\n      title: \"Course added\",\n      description: `${courseData.label} has been added to the roadmap`\n    });\n\n    // Force a fit view after node is added\n    setTimeout(() => {\n      if (reactFlowInstance) {\n        reactFlowInstance.fitView({\n          padding: 0.5\n        });\n      }\n    }, 100);\n  }, [setNodes, toast, reactFlowInstance, nodes, handleCompleteToggle, saveCurrentState]);\n\n  // Ensure manually added nodes are preserved during state updates\n  useEffect(() => {\n    if (addedNodesRef.current.length > 0 && nodes.length > 0) {\n      // Get IDs of current nodes\n      const currentIds = new Set(nodes.map(n => n.id));\n\n      // Find manually added nodes that are missing from current nodes\n      const missingNodes = addedNodesRef.current.filter(n => !currentIds.has(n.id));\n\n      // If any manually added nodes are missing, add them back\n      if (missingNodes.length > 0) {\n        console.log(`[FLOW] Restoring ${missingNodes.length} manually added nodes that were lost`);\n        setNodes(currentNodes => [...currentNodes, ...missingNodes]);\n      }\n    }\n  }, [nodes, setNodes]);\n  const handleDeleteNode = useCallback(nodeId => {\n    saveCurrentState();\n\n    // Remove the node\n    setNodes(nds => nds.filter(node => node.id !== nodeId));\n    // Remove connected edges\n    setEdges(eds => eds.filter(edge => edge.source !== nodeId && edge.target !== nodeId));\n    setSelectedNode(null);\n    toast({\n      title: \"Node deleted\",\n      description: \"The node has been removed from the roadmap\"\n    });\n  }, [setNodes, setEdges, toast, saveCurrentState]);\n  const handleUpdateNodeStyle = useCallback((nodeId, style) => {\n    setNodes(nds => nds.map(node => {\n      if (node.id === nodeId) {\n        return {\n          ...node,\n          data: {\n            ...node.data,\n            ...style\n          }\n        };\n      }\n      return node;\n    }));\n  }, [setNodes]);\n  const onEdgeClick = useCallback((event, edge) => {\n    if (editMode === \"delete\") {\n      saveCurrentState();\n\n      // Delete the edge\n      setEdges(eds => eds.filter(e => e.id !== edge.id));\n      toast({\n        title: \"Connection removed\",\n        description: \"The connection between nodes has been removed\"\n      });\n    }\n  }, [setEdges, editMode, saveCurrentState, toast]);\n  const handleUndo = useCallback(() => {\n    if (undoStack.length === 0) return;\n    const currentState = {\n      nodes: [...nodes],\n      edges: [...edges]\n    };\n    const previousState = undoStack[undoStack.length - 1];\n    setRedoStack(prev => [...prev, currentState]);\n    setUndoStack(prev => prev.slice(0, -1));\n    setNodes(previousState.nodes);\n    setEdges(previousState.edges);\n    toast({\n      title: \"Undo\",\n      description: \"Previous action undone\"\n    });\n  }, [undoStack, redoStack, nodes, edges, setNodes, setEdges, toast]);\n  const handleRedo = useCallback(() => {\n    if (redoStack.length === 0) return;\n    const currentState = {\n      nodes: [...nodes],\n      edges: [...edges]\n    };\n    const nextState = redoStack[redoStack.length - 1];\n    setUndoStack(prev => [...prev, currentState]);\n    setRedoStack(prev => prev.slice(0, -1));\n    setNodes(nextState.nodes);\n    setEdges(nextState.edges);\n    toast({\n      title: \"Redo\",\n      description: \"Action redone\"\n    });\n  }, [undoStack, redoStack, nodes, edges, setNodes, setEdges, toast]);\n\n  // Update node positions when they are dragged\n  const onNodeDragStop = useCallback(() => {\n    if (isEditing) {\n      saveCurrentState();\n    }\n  }, [isEditing, saveCurrentState]);\n\n  // Handle category filtering\n  const filteredNodes = useCallback(() => {\n    if (selectedCategory === \"all\") {\n      return nodes;\n    }\n    return nodes.filter(node => {\n      var _node$data$category;\n      return ((_node$data$category = node.data.category) === null || _node$data$category === void 0 ? void 0 : _node$data$category.toLowerCase()) === selectedCategory.toLowerCase();\n    });\n  }, [nodes, selectedCategory]);\n  const handleStyleChange = useCallback(styles => {\n    // Apply styles to selected node or default edge options\n    if (selectedNode) {\n      handleUpdateNodeStyle(selectedNode.id, styles.nodeStyle);\n    }\n\n    // Update default edge options\n    // (would be implemented in a full version)\n  }, [selectedNode, handleUpdateNodeStyle]);\n  const handleConnectionTypeChange = useCallback(type => {\n    setConnectionType(type);\n  }, []);\n\n  // Ngăn chặn cảnh báo ResizeObserver\n  useEffect(() => {\n    // Chỉ áp dụng trong môi trường phát triển\n    if (process.env.NODE_ENV !== \"production\") {\n      const originalError = console.error;\n      console.error = (...args) => {\n        var _args$, _args$$includes, _args$2, _args$2$message, _args$2$message$inclu;\n        if ((_args$ = args[0]) !== null && _args$ !== void 0 && (_args$$includes = _args$.includes) !== null && _args$$includes !== void 0 && _args$$includes.call(_args$, \"ResizeObserver loop\") || (_args$2 = args[0]) !== null && _args$2 !== void 0 && (_args$2$message = _args$2.message) !== null && _args$2$message !== void 0 && (_args$2$message$inclu = _args$2$message.includes) !== null && _args$2$message$inclu !== void 0 && _args$2$message$inclu.call(_args$2$message, \"ResizeObserver loop\")) {\n          // Bỏ qua cảnh báo ResizeObserver\n          return;\n        }\n        originalError.apply(console, args);\n      };\n      return () => {\n        console.error = originalError;\n      };\n    }\n  }, []);\n\n  // Ensure nodes are visible in the viewport\n  useEffect(() => {\n    if (!isInitialMount.current && nodes.length > 0 && reactFlowInstance) {\n      // Wait for rendering to complete, then fit view\n      const timeoutId = setTimeout(() => {\n        console.log(\"[FLOW] Fitting view to ensure nodes are visible\");\n        reactFlowInstance.fitView({\n          padding: 0.5,\n          includeHiddenNodes: true,\n          minZoom: 0.5,\n          maxZoom: 1.5\n        });\n      }, 500);\n      return () => clearTimeout(timeoutId);\n    }\n  }, [nodes.length, reactFlowInstance]);\n\n  // Add a debug useEffect to log whenever nodes change\n  useEffect(() => {\n    if (nodes.length > 0) {\n      console.log(\"[FLOW] Nodes changed, current count:\", nodes.length);\n    }\n  }, [nodes]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: reactFlowWrapper,\n    className: \"h-full w-full\",\n    children: [isEditing && showEditorPanel && /*#__PURE__*/_jsxDEV(Panel, {\n      position: \"right\",\n      className: \"w-72 mr-2\",\n      children: /*#__PURE__*/_jsxDEV(RoadmapEditorPanel, {\n        onStyleChange: handleStyleChange,\n        onConnectionTypeChange: handleConnectionTypeChange,\n        activeEdgeStyle: connectionType,\n        editMode: editMode,\n        onEditModeChange: mode => {\n          setEditMode(mode);\n          if (mode === \"connect\") {\n            toast({\n              title: \"Connect mode\",\n              description: \"Click on a source node, then click on a target node to create a connection\"\n            });\n          } else if (mode === \"delete\") {\n            toast({\n              title: \"Delete mode\",\n              description: \"Click on a node or connection to delete it\"\n            });\n          }\n        },\n        onAddNodeClick: () => setIsAddCourseOpen(true)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 785,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 784,\n      columnNumber: 9\n    }, this), isEditing && /*#__PURE__*/_jsxDEV(Panel, {\n      position: \"top-right\",\n      className: \"bg-cyberpunk-darker/90 p-3 rounded-md border border-purple-500/30 mb-4 shadow-lg mr-[300px]\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"flex gap-2 justify-end\",\n        children: [/*#__PURE__*/_jsxDEV(Button, {\n          size: \"sm\",\n          className: \"bg-cyberpunk-darker border border-purple-500/30 text-purple-300 hover:bg-purple-900/20\",\n          onClick: handleUndo,\n          disabled: undoStack.length === 0,\n          children: \"Undo\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 816,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(Button, {\n          size: \"sm\",\n          className: \"bg-cyberpunk-darker border border-purple-500/30 text-purple-300 hover:bg-purple-900/20\",\n          onClick: handleRedo,\n          disabled: redoStack.length === 0,\n          children: \"Redo\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 824,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(Button, {\n          className: \"bg-purple-600 hover:bg-purple-700 text-white\",\n          size: \"sm\",\n          onClick: handleSaveRoadmap,\n          children: [/*#__PURE__*/_jsxDEV(Save, {\n            className: \"h-4 w-4 mr-1\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 837,\n            columnNumber: 15\n          }, this), \" Save\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 832,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 815,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 811,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"h-full\",\n      children: /*#__PURE__*/_jsxDEV(ReactFlow, {\n        nodes: filteredNodes(),\n        edges: edges,\n        onNodesChange: isEditing ? onNodesChange : undefined,\n        onEdgesChange: isEditing ? onEdgesChange : undefined,\n        onConnect: isEditing ? onConnect : undefined,\n        onNodeClick: onNodeClick,\n        onEdgeClick: onEdgeClick,\n        onPaneClick: onPaneClick,\n        nodeTypes: nodeTypes,\n        onNodeDragStop: onNodeDragStop,\n        nodesDraggable: isEditing,\n        nodesConnectable: isEditing && editMode === \"connect\",\n        elementsSelectable: !readOnly,\n        defaultEdgeOptions: {\n          type: \"smoothstep\",\n          style: {\n            stroke: \"#6d28d9\"\n          },\n          animated: true,\n          ...(connectionType === \"arrow\" && {\n            markerEnd: {\n              type: MarkerType.ArrowClosed,\n              width: 20,\n              height: 20,\n              color: \"#6d28d9\"\n            }\n          }),\n          data: {\n            connectionType\n          }\n        },\n        fitView: true,\n        fitViewOptions: {\n          padding: 0.5,\n          includeHiddenNodes: true,\n          minZoom: 0.5,\n          maxZoom: 1.5\n        },\n        minZoom: 0.2,\n        maxZoom: 4,\n        snapToGrid: true,\n        snapGrid: [10, 10],\n        nodeExtent: [[-2000, -2000], [2000, 2000]],\n        proOptions: {\n          hideAttribution: true\n        },\n        disableKeyboardA11y: true,\n        autoPanOnNodeDrag: false,\n        elevateEdgesOnSelect: false,\n        onInit: instance => {\n          // Use setTimeout to ensure proper initialization\n          setTimeout(() => {\n            if (nodes.length > 0) {\n              instance.fitView({\n                padding: 0.5\n              });\n              console.log(\"[FLOW] Flow initialized with nodes:\", nodes.length);\n            }\n          }, 300);\n        },\n        children: [/*#__PURE__*/_jsxDEV(Controls, {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 907,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(MiniMap, {\n          nodeStrokeWidth: 3,\n          zoomable: true,\n          pannable: true\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 908,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(Background, {\n          variant: \"dots\",\n          gap: 12,\n          size: 1,\n          color: \"#6d28d9\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 909,\n          columnNumber: 11\n        }, this)]\n      }, `flow-${id}-${nodes.length}`, true, {\n        fileName: _jsxFileName,\n        lineNumber: 844,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 843,\n      columnNumber: 7\n    }, this), selectedNode && /*#__PURE__*/_jsxDEV(CourseInfoPanel, {\n      node: selectedNode,\n      onClose: () => setSelectedNode(null),\n      onCompleteToggle: handleCompleteToggle,\n      onDelete: isEditing ? handleDeleteNode : undefined,\n      onUpdateStyle: handleUpdateNodeStyle,\n      isAdmin: isEditing,\n      readOnly: readOnly\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 914,\n      columnNumber: 9\n    }, this), isAddCourseOpen && /*#__PURE__*/_jsxDEV(AddCourseDialog, {\n      open: isAddCourseOpen,\n      onClose: () => setIsAddCourseOpen(false),\n      onAdd: handleAddCourse\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 926,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 782,\n    columnNumber: 5\n  }, this);\n}\n_s(RoadmapViewInner, \"VE0+2p2JxYI+XZ1I8YtA+42KYMM=\", false, function () {\n  return [useToast, useNodesState, useEdgesState, useReactFlow];\n});\n_c = RoadmapViewInner;\nexport default function RoadmapView(props) {\n  var _props$initialNodes, _props$initialEdges;\n  console.log(\"[FLOW] RoadmapView wrapper rendering with props:\", {\n    id: props.id,\n    nodesCount: (_props$initialNodes = props.initialNodes) === null || _props$initialNodes === void 0 ? void 0 : _props$initialNodes.length,\n    edgesCount: (_props$initialEdges = props.initialEdges) === null || _props$initialEdges === void 0 ? void 0 : _props$initialEdges.length\n  });\n  return /*#__PURE__*/_jsxDEV(ReactFlowProvider, {\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"w-full h-full\",\n      children: /*#__PURE__*/_jsxDEV(RoadmapViewInner, {\n        ...props\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 946,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 945,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 944,\n    columnNumber: 5\n  }, this);\n}\n_c2 = RoadmapView;\nvar _c, _c2;\n$RefreshReg$(_c, \"RoadmapViewInner\");\n$RefreshReg$(_c2, \"RoadmapView\");","map":{"version":3,"names":["_jsxFileName","_s","$RefreshSig$","useState","useCallback","useEffect","useRef","ReactFlow","MiniMap","Controls","Background","useNodesState","useEdgesState","addEdge","Panel","ReactFlowProvider","useReactFlow","MarkerType","Connection","Tabs","TabsList","TabsTrigger","Button","useToast","PlusCircle","Save","Trash","Plus","X","Link","LinkIcon","LinkOff","Palette","CourseNode","CourseInfoPanel","AddCourseDialog","RoadmapEditorPanel","jsxDEV","_jsxDEV","nodeTypes","courseNode","RoadmapViewInner","id","initialNodes","initialEdges","isEditing","readOnly","onSave","onInternalUpdate","toast","nodes","setNodes","onNodesChange","edges","setEdges","onEdgesChange","selectedNode","setSelectedNode","selectedCategory","setSelectedCategory","isAddCourseOpen","setIsAddCourseOpen","editMode","setEditMode","connectionType","setConnectionType","showEditorPanel","setShowEditorPanel","reactFlowWrapper","reactFlowInstance","undoStack","setUndoStack","redoStack","setRedoStack","isInitialMount","addedNodesRef","handleCompleteToggle","nodeId","completed","_nodes$find","completedAt","Date","toISOString","nds","map","node","data","title","description","find","n","label","length","current","console","log","processedNodes","_node$data","type","position","x","Math","random","y","showQuickToggle","onQuickToggle","initialNodeIds","Set","manuallyAddedMissingNodes","filter","has","timeoutId","setTimeout","viewportEl","document","querySelector","style","transitionProperty","transitionDuration","clearTimeout","currentIds","initialIds","size","some","_node$data2","timer","saveCurrentState","prev","onConnect","params","newEdge","now","animated","stroke","markerEnd","ArrowClosed","width","height","color","eds","onNodeClick","event","stopPropagation","e","source","target","onPaneClick","handleSaveRoadmap","cleanedNodes","_node$data3","error","toString","substring","cleanedEdges","edge","Boolean","warn","variant","handleAddCourse","courseData","newNodeId","viewport","getViewport","center","screenToFlowPosition","window","innerWidth","innerHeight","occupied","abs","quadrants","offset","newNode","currentNodes","existingIds","missingAddedNodes","updatedNodes","push","fitView","padding","missingNodes","handleDeleteNode","handleUpdateNodeStyle","onEdgeClick","handleUndo","currentState","previousState","slice","handleRedo","nextState","onNodeDragStop","filteredNodes","_node$data$category","category","toLowerCase","handleStyleChange","styles","nodeStyle","handleConnectionTypeChange","process","env","NODE_ENV","originalError","args","_args$","_args$$includes","_args$2","_args$2$message","_args$2$message$inclu","includes","call","message","apply","includeHiddenNodes","minZoom","maxZoom","ref","className","children","onStyleChange","onConnectionTypeChange","activeEdgeStyle","onEditModeChange","mode","onAddNodeClick","fileName","lineNumber","columnNumber","onClick","disabled","undefined","nodesDraggable","nodesConnectable","elementsSelectable","defaultEdgeOptions","fitViewOptions","snapToGrid","snapGrid","nodeExtent","proOptions","hideAttribution","disableKeyboardA11y","autoPanOnNodeDrag","elevateEdgesOnSelect","onInit","instance","nodeStrokeWidth","zoomable","pannable","gap","onClose","onCompleteToggle","onDelete","onUpdateStyle","isAdmin","open","onAdd","_c","RoadmapView","props","_props$initialNodes","_props$initialEdges","nodesCount","edgesCount","_c2","$RefreshReg$"],"sources":["D:/CyberPath/it-roadmap/client/src/components/RoadmapView.jsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useCallback, useEffect, useRef } from \"react\";\nimport ReactFlow, {\n  MiniMap,\n  Controls,\n  Background,\n  useNodesState,\n  useEdgesState,\n  addEdge,\n  Panel,\n  ReactFlowProvider,\n  useReactFlow,\n  MarkerType,\n  Connection,\n} from \"reactflow\";\nimport \"reactflow/dist/style.css\";\nimport { Tabs, TabsList, TabsTrigger } from \"./ui/tabs\";\nimport { Button } from \"./ui/button\";\nimport { useToast } from \"./ui/use-toast\";\nimport {\n  PlusCircle,\n  Save,\n  Trash,\n  Plus,\n  X,\n  Link as LinkIcon,\n  LinkOff,\n  Palette,\n} from \"lucide-react\";\nimport CourseNode from \"./CourseNode\";\nimport CourseInfoPanel from \"./CourseInfoPanel\";\nimport AddCourseDialog from \"./AddCourseDialog\";\nimport RoadmapEditorPanel from \"./RoadmapEditorPanel\";\n\nconst nodeTypes = {\n  courseNode: CourseNode,\n};\n\nfunction RoadmapViewInner({\n  id,\n  initialNodes = [],\n  initialEdges = [],\n  isEditing = false,\n  readOnly = false,\n  onSave,\n  onInternalUpdate,\n}) {\n  const { toast } = useToast();\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n  const [selectedNode, setSelectedNode] = useState(null);\n  const [selectedCategory, setSelectedCategory] = useState(\"all\");\n  const [isAddCourseOpen, setIsAddCourseOpen] = useState(false);\n  const [editMode, setEditMode] = useState(\"select\"); // select, connect, add, delete\n  const [connectionType, setConnectionType] = useState(\"arrow\"); // arrow, none\n  const [showEditorPanel, setShowEditorPanel] = useState(true);\n  const reactFlowWrapper = useRef(null);\n  const reactFlowInstance = useReactFlow();\n  const [undoStack, setUndoStack] = useState([]);\n  const [redoStack, setRedoStack] = useState([]);\n  const isInitialMount = useRef(true);\n  // Keep track of manually added nodes to prevent them from being lost\n  const addedNodesRef = useRef([]);\n\n  // Define handleCompleteToggle before it's used\n  const handleCompleteToggle = useCallback(\n    (nodeId, completed) => {\n      if (readOnly) return;\n\n      // Get the current timestamp\n      const completedAt = completed ? new Date().toISOString() : null;\n\n      setNodes((nds) =>\n        nds.map((node) => {\n          if (node.id === nodeId) {\n            return {\n              ...node,\n              data: {\n                ...node.data,\n                completed,\n                completedAt,\n              },\n            };\n          }\n          return node;\n        })\n      );\n\n      toast({\n        title: completed\n          ? \"Course marked as completed\"\n          : \"Course marked as incomplete\",\n        description: `You've ${completed ? \"completed\" : \"unmarked\"} ${\n          nodes.find((n) => n.id === nodeId)?.data.label\n        }`,\n      });\n    },\n    [nodes, setNodes, toast, readOnly]\n  );\n\n  // Set initial nodes and edges when they change\n  useEffect(() => {\n    // Skip effect if no initial data\n    if (!initialNodes?.length && !initialEdges?.length) {\n      return;\n    }\n\n    // Only run this effect once on initial mount or when initialNodes actually changes\n    if (isInitialMount.current || initialNodes?.length > 0) {\n      console.log(\"[FLOW] Processing nodes:\", initialNodes?.length);\n\n      if (initialNodes?.length > 0) {\n        // Process nodes once with required properties for display\n        const processedNodes = initialNodes.map((node) => ({\n          ...node,\n          type: \"courseNode\",\n          // Ensure position exists\n          position: node.position || {\n            x: Math.random() * 500,\n            y: Math.random() * 300,\n          },\n          data: {\n            ...node.data,\n            showQuickToggle: true,\n            onQuickToggle: handleCompleteToggle,\n            // Ensure label exists\n            label: node.data?.label || \"Untitled Node\",\n          },\n        }));\n\n        // Merge with any manually added nodes that aren't in initialNodes yet\n        const initialNodeIds = new Set(initialNodes.map((n) => n.id));\n        const manuallyAddedMissingNodes = addedNodesRef.current.filter(\n          (n) => !initialNodeIds.has(n.id)\n        );\n\n        if (manuallyAddedMissingNodes.length > 0) {\n          console.log(\n            `[FLOW] Merging ${manuallyAddedMissingNodes.length} manually added nodes with initialNodes`\n          );\n\n          // Set state with both initial and manually added nodes\n          setNodes([...processedNodes, ...manuallyAddedMissingNodes]);\n        } else {\n          console.log(\"[FLOW] Setting nodes from initialNodes only\");\n          setNodes(processedNodes);\n        }\n      }\n\n      if (initialEdges?.length > 0) {\n        console.log(\"[FLOW] Setting initial edges:\", initialEdges.length);\n        setEdges([...initialEdges]);\n      }\n\n      // Schedule viewport setup after nodes are rendered\n      const timeoutId = setTimeout(() => {\n        const viewportEl = document.querySelector(\".react-flow__viewport\");\n        if (viewportEl) {\n          viewportEl.style.transitionProperty = \"transform\";\n          viewportEl.style.transitionDuration = \"0.2s\";\n        }\n      }, 300);\n\n      isInitialMount.current = false;\n      return () => clearTimeout(timeoutId);\n    }\n  }, [initialNodes, initialEdges, setNodes, setEdges, handleCompleteToggle]);\n\n  // Separate effect to monitor changes in props vs internal state\n  useEffect(() => {\n    if (isInitialMount.current) return; // Skip on initial mount\n\n    // Check if initialNodes changed after first render (rare, but possible)\n    if (initialNodes && initialNodes.length > 0) {\n      // Compare IDs only to prevent needless updates\n      const currentIds = new Set(nodes.map((n) => n.id));\n      const initialIds = new Set(initialNodes.map((n) => n.id));\n\n      // Only update if different nodes are provided\n      if (\n        initialIds.size !== currentIds.size ||\n        initialNodes.some((n) => !currentIds.has(n.id))\n      ) {\n        console.log(\"[FLOW] External nodes updated, refreshing\");\n\n        const processedNodes = initialNodes.map((node) => ({\n          ...node,\n          type: \"courseNode\",\n          position: node.position || {\n            x: Math.random() * 500,\n            y: Math.random() * 300,\n          },\n          data: {\n            ...node.data,\n            showQuickToggle: true,\n            onQuickToggle: handleCompleteToggle,\n            label: node.data?.label || \"Untitled Node\",\n          },\n        }));\n\n        setNodes(processedNodes);\n      }\n    }\n  }, [initialNodes, nodes, setNodes, handleCompleteToggle]);\n\n  // Update parent component with internal changes\n  useEffect(() => {\n    if (isInitialMount.current) return; // Skip during initial render\n\n    const timer = setTimeout(() => {\n      if (\n        (nodes.length > 0 || edges.length > 0) &&\n        typeof onInternalUpdate === \"function\"\n      ) {\n        console.log(\"[FLOW] Updating parent with current state\");\n        onInternalUpdate(nodes, edges);\n      }\n    }, 300);\n\n    return () => clearTimeout(timer);\n  }, [nodes, edges, onInternalUpdate]);\n\n  // Save current state for undo feature\n  const saveCurrentState = useCallback(() => {\n    setUndoStack((prev) => [...prev, { nodes: [...nodes], edges: [...edges] }]);\n    setRedoStack([]);\n  }, [nodes, edges]);\n\n  const onConnect = useCallback(\n    (params) => {\n      saveCurrentState();\n      // Add marker and apply current edge style settings\n      const newEdge = {\n        ...params,\n        id: `edge-${Date.now()}`,\n        type: \"smoothstep\",\n        animated: true,\n        style: { stroke: \"#6d28d9\" },\n        // Only add marker if connection type is arrow\n        ...(connectionType === \"arrow\" && {\n          markerEnd: {\n            type: MarkerType.ArrowClosed,\n            width: 20,\n            height: 20,\n            color: \"#6d28d9\",\n          },\n        }),\n        data: {\n          connectionType,\n        },\n      };\n      setEdges((eds) => addEdge(newEdge, eds));\n\n      toast({\n        title: \"Connection added\",\n        description: \"A new connection has been created between nodes\",\n      });\n    },\n    [setEdges, saveCurrentState, toast, connectionType]\n  );\n\n  const onNodeClick = useCallback(\n    (event, node) => {\n      event.stopPropagation();\n\n      if (editMode === \"delete\") {\n        // Delete mode: remove the node\n        saveCurrentState();\n        setNodes(nodes.filter((n) => n.id !== node.id));\n        // Also remove any connected edges\n        setEdges(\n          edges.filter((e) => e.source !== node.id && e.target !== node.id)\n        );\n\n        toast({\n          title: \"Node deleted\",\n          description: `${node.data.label} has been removed from the roadmap`,\n        });\n      } else if (editMode === \"connect\" && selectedNode) {\n        // Connect mode: create an edge between selectedNode and this node\n        if (selectedNode.id !== node.id) {\n          const newEdge = {\n            id: `edge-${Date.now()}`,\n            source: selectedNode.id,\n            target: node.id,\n            type: \"smoothstep\",\n            animated: true,\n            style: { stroke: \"#6d28d9\" },\n            ...(connectionType === \"arrow\" && {\n              markerEnd: {\n                type: MarkerType.ArrowClosed,\n                width: 20,\n                height: 20,\n                color: \"#6d28d9\",\n              },\n            }),\n            data: {\n              connectionType,\n            },\n          };\n\n          saveCurrentState();\n          setEdges((eds) => [...eds, newEdge]);\n          setSelectedNode(null);\n          setEditMode(\"select\");\n\n          toast({\n            title: \"Connection created\",\n            description: `Connected ${selectedNode.data.label} to ${node.data.label}`,\n          });\n        }\n      } else if (editMode === \"select\") {\n        // Regular select mode: show node details\n        setSelectedNode(node);\n      }\n    },\n    [\n      editMode,\n      selectedNode,\n      nodes,\n      edges,\n      setNodes,\n      setEdges,\n      saveCurrentState,\n      toast,\n    ]\n  );\n\n  const onPaneClick = useCallback(() => {\n    // In regular mode, clicking the pane should deselect the node\n    setSelectedNode(null);\n\n    // If in connect mode but no node selected, return to select mode\n    if (editMode === \"connect\" && selectedNode) {\n      setEditMode(\"select\");\n      setSelectedNode(null);\n      toast({\n        title: \"Connection cancelled\",\n        description: \"Node connection has been cancelled\",\n      });\n    }\n  }, [editMode, selectedNode, toast]);\n\n  const handleSaveRoadmap = useCallback(() => {\n    if (onSave) {\n      console.log(\"[VIEW] Starting roadmap save process\");\n      console.log(\"[VIEW] Current nodes:\", nodes.length);\n      console.log(\"[VIEW] Current edges:\", edges.length);\n\n      // Đảm bảo không có node nào bị thiếu dữ liệu quan trọng\n      const cleanedNodes = nodes.map((node) => {\n        if (!node.id) {\n          console.error(\"[VIEW] Node missing ID:\", node);\n          // Generate a unique ID if missing\n          node.id = `node_${Date.now()}_${Math.random()\n            .toString(36)\n            .substring(2, 9)}`;\n        }\n\n        if (!node.position) {\n          console.error(\"[VIEW] Node missing position:\", node);\n          // Default position\n          node.position = { x: 0, y: 0 };\n        }\n\n        if (!node.data) {\n          console.error(\"[VIEW] Node missing data:\", node);\n          // Default minimal data\n          node.data = { label: \"Node \" + node.id };\n        }\n\n        // Đảm bảo node có đủ thông tin cần thiết\n        return {\n          ...node,\n          type: node.type || \"courseNode\", // Loại node mặc định\n          data: {\n            ...(node.data || {}),\n            id: node.id, // Đảm bảo ID trong data giống với ID của node\n            label: node.data?.label || \"Untitled\", // Ít nhất phải có nhãn\n          },\n        };\n      });\n\n      // Đảm bảo các edge có đủ thông tin cần thiết\n      const cleanedEdges = edges\n        .map((edge) => {\n          if (!edge.source || !edge.target) {\n            console.error(\"[VIEW] Edge missing source or target:\", edge);\n            return null; // Skip invalid edges\n          }\n\n          if (!edge.id) {\n            console.error(\"[VIEW] Edge missing ID:\", edge);\n            // Generate a unique ID if missing\n            edge.id = `edge_${Date.now()}_${Math.random()\n              .toString(36)\n              .substring(2, 9)}`;\n          }\n\n          return {\n            ...edge,\n            type: edge.type || \"smoothstep\", // Loại edge mặc định\n          };\n        })\n        .filter(Boolean); // Lọc bỏ các edge null\n\n      console.log(\"[VIEW] Cleaned nodes for saving:\", cleanedNodes.length);\n      console.log(\"[VIEW] Node data sample:\", cleanedNodes[0]);\n      console.log(\"[VIEW] Cleaned edges for saving:\", cleanedEdges.length);\n      if (cleanedEdges.length > 0) {\n        console.log(\"[VIEW] Edge data sample:\", cleanedEdges[0]);\n      }\n\n      // Thông báo cho người dùng\n      toast({\n        title: \"Saving roadmap...\",\n        description: `Saving ${cleanedNodes.length} nodes and ${cleanedEdges.length} edges`,\n      });\n\n      // Lưu dữ liệu vào trạng thái cục bộ\n      setNodes(cleanedNodes);\n      setEdges(cleanedEdges);\n\n      // Gọi hàm callback onSave để lưu dữ liệu\n      console.log(\"[VIEW] Calling onSave with cleaned data\");\n      onSave(cleanedNodes, cleanedEdges);\n    } else {\n      console.warn(\"[VIEW] Save handler not provided. Cannot save roadmap.\");\n      toast({\n        title: \"Cannot save roadmap\",\n        description: \"Save handler not configured\",\n        variant: \"destructive\",\n      });\n    }\n  }, [nodes, edges, onSave, toast, setNodes, setEdges]);\n\n  const handleAddCourse = useCallback(\n    (courseData) => {\n      saveCurrentState();\n\n      // Generate a unique node ID\n      const newNodeId = `node-${Date.now()}-${Math.random()\n        .toString(36)\n        .substring(2, 9)}`;\n\n      // Calculate an appropriate position for the new node\n      let position = {\n        x: Math.random() * 300 + 100,\n        y: Math.random() * 200 + 100,\n      };\n\n      // If we have a reactFlowInstance, use it for better positioning\n      if (reactFlowInstance) {\n        try {\n          // Get the viewport center\n          const viewport = reactFlowInstance.getViewport();\n\n          // Convert screen center to flow position\n          const center = reactFlowInstance.screenToFlowPosition({\n            x: window.innerWidth / 2,\n            y: window.innerHeight / 2,\n          });\n\n          position = {\n            x: center.x,\n            y: center.y,\n          };\n\n          // Add some randomness to avoid direct overlap\n          position.x += (Math.random() - 0.5) * 100;\n          position.y += (Math.random() - 0.5) * 100;\n\n          // If existing nodes are nearby, move new node to avoid overlap\n          if (nodes.length > 0) {\n            const occupied = nodes.some(\n              (node) =>\n                Math.abs(node.position.x - position.x) < 250 &&\n                Math.abs(node.position.y - position.y) < 100\n            );\n\n            if (occupied) {\n              // Find a quadrant with fewer nodes and place there\n              const quadrants = [\n                { x: 1, y: 1 },\n                { x: -1, y: 1 },\n                { x: -1, y: -1 },\n                { x: 1, y: -1 },\n              ];\n\n              const offset = quadrants[nodes.length % quadrants.length];\n              position.x += offset.x * 300;\n              position.y += offset.y * 200;\n            }\n          }\n        } catch (error) {\n          console.error(\"[FLOW] Error calculating node position:\", error);\n          // Fallback position if there's an error\n          position = {\n            x: 100 + nodes.length * 250,\n            y: 150 + (nodes.length % 2) * 200,\n          };\n        }\n      } else {\n        // Without reactFlowInstance, use basic spacing\n        position = {\n          x: 100 + nodes.length * 250,\n          y: 150 + (nodes.length % 2) * 200,\n        };\n      }\n\n      console.log(\n        `[FLOW] Creating new node at position: x=${position.x}, y=${position.y}`\n      );\n\n      // Create the new node with proper data\n      const newNode = {\n        id: newNodeId,\n        type: \"courseNode\",\n        position,\n        data: {\n          ...courseData,\n          completed: false,\n          completedAt: null,\n          showQuickToggle: true,\n          onQuickToggle: handleCompleteToggle,\n          id: newNodeId,\n        },\n      };\n\n      // Store the new node in our ref to ensure it's not lost during state updates\n      addedNodesRef.current = [...addedNodesRef.current, newNode];\n\n      // Add node to state, ensuring we include all previously added nodes\n      setNodes((currentNodes) => {\n        // Make sure we're not duplicating nodes\n        const existingIds = new Set(currentNodes.map((n) => n.id));\n\n        // Filter out nodes from our ref that are already in the current nodes\n        const missingAddedNodes = addedNodesRef.current.filter(\n          (n) => !existingIds.has(n.id)\n        );\n\n        // Create new nodes array with all existing + missing added nodes + new node\n        const updatedNodes = [...currentNodes];\n\n        // Only add the new node if it's not already in the array\n        if (!existingIds.has(newNode.id)) {\n          updatedNodes.push(newNode);\n        }\n\n        console.log(\n          `[FLOW] Updated nodes array, now contains ${updatedNodes.length} nodes`\n        );\n        return updatedNodes;\n      });\n\n      // Close the dialog\n      setIsAddCourseOpen(false);\n\n      // Show success toast\n      toast({\n        title: \"Course added\",\n        description: `${courseData.label} has been added to the roadmap`,\n      });\n\n      // Force a fit view after node is added\n      setTimeout(() => {\n        if (reactFlowInstance) {\n          reactFlowInstance.fitView({ padding: 0.5 });\n        }\n      }, 100);\n    },\n    [\n      setNodes,\n      toast,\n      reactFlowInstance,\n      nodes,\n      handleCompleteToggle,\n      saveCurrentState,\n    ]\n  );\n\n  // Ensure manually added nodes are preserved during state updates\n  useEffect(() => {\n    if (addedNodesRef.current.length > 0 && nodes.length > 0) {\n      // Get IDs of current nodes\n      const currentIds = new Set(nodes.map((n) => n.id));\n\n      // Find manually added nodes that are missing from current nodes\n      const missingNodes = addedNodesRef.current.filter(\n        (n) => !currentIds.has(n.id)\n      );\n\n      // If any manually added nodes are missing, add them back\n      if (missingNodes.length > 0) {\n        console.log(\n          `[FLOW] Restoring ${missingNodes.length} manually added nodes that were lost`\n        );\n        setNodes((currentNodes) => [...currentNodes, ...missingNodes]);\n      }\n    }\n  }, [nodes, setNodes]);\n\n  const handleDeleteNode = useCallback(\n    (nodeId) => {\n      saveCurrentState();\n\n      // Remove the node\n      setNodes((nds) => nds.filter((node) => node.id !== nodeId));\n      // Remove connected edges\n      setEdges((eds) =>\n        eds.filter((edge) => edge.source !== nodeId && edge.target !== nodeId)\n      );\n\n      setSelectedNode(null);\n\n      toast({\n        title: \"Node deleted\",\n        description: \"The node has been removed from the roadmap\",\n      });\n    },\n    [setNodes, setEdges, toast, saveCurrentState]\n  );\n\n  const handleUpdateNodeStyle = useCallback(\n    (nodeId, style) => {\n      setNodes((nds) =>\n        nds.map((node) => {\n          if (node.id === nodeId) {\n            return {\n              ...node,\n              data: {\n                ...node.data,\n                ...style,\n              },\n            };\n          }\n          return node;\n        })\n      );\n    },\n    [setNodes]\n  );\n\n  const onEdgeClick = useCallback(\n    (event, edge) => {\n      if (editMode === \"delete\") {\n        saveCurrentState();\n\n        // Delete the edge\n        setEdges((eds) => eds.filter((e) => e.id !== edge.id));\n\n        toast({\n          title: \"Connection removed\",\n          description: \"The connection between nodes has been removed\",\n        });\n      }\n    },\n    [setEdges, editMode, saveCurrentState, toast]\n  );\n\n  const handleUndo = useCallback(() => {\n    if (undoStack.length === 0) return;\n\n    const currentState = { nodes: [...nodes], edges: [...edges] };\n    const previousState = undoStack[undoStack.length - 1];\n\n    setRedoStack((prev) => [...prev, currentState]);\n    setUndoStack((prev) => prev.slice(0, -1));\n\n    setNodes(previousState.nodes);\n    setEdges(previousState.edges);\n\n    toast({\n      title: \"Undo\",\n      description: \"Previous action undone\",\n    });\n  }, [undoStack, redoStack, nodes, edges, setNodes, setEdges, toast]);\n\n  const handleRedo = useCallback(() => {\n    if (redoStack.length === 0) return;\n\n    const currentState = { nodes: [...nodes], edges: [...edges] };\n    const nextState = redoStack[redoStack.length - 1];\n\n    setUndoStack((prev) => [...prev, currentState]);\n    setRedoStack((prev) => prev.slice(0, -1));\n\n    setNodes(nextState.nodes);\n    setEdges(nextState.edges);\n\n    toast({\n      title: \"Redo\",\n      description: \"Action redone\",\n    });\n  }, [undoStack, redoStack, nodes, edges, setNodes, setEdges, toast]);\n\n  // Update node positions when they are dragged\n  const onNodeDragStop = useCallback(() => {\n    if (isEditing) {\n      saveCurrentState();\n    }\n  }, [isEditing, saveCurrentState]);\n\n  // Handle category filtering\n  const filteredNodes = useCallback(() => {\n    if (selectedCategory === \"all\") {\n      return nodes;\n    }\n    return nodes.filter(\n      (node) =>\n        node.data.category?.toLowerCase() === selectedCategory.toLowerCase()\n    );\n  }, [nodes, selectedCategory]);\n\n  const handleStyleChange = useCallback(\n    (styles) => {\n      // Apply styles to selected node or default edge options\n      if (selectedNode) {\n        handleUpdateNodeStyle(selectedNode.id, styles.nodeStyle);\n      }\n\n      // Update default edge options\n      // (would be implemented in a full version)\n    },\n    [selectedNode, handleUpdateNodeStyle]\n  );\n\n  const handleConnectionTypeChange = useCallback((type) => {\n    setConnectionType(type);\n  }, []);\n\n  // Ngăn chặn cảnh báo ResizeObserver\n  useEffect(() => {\n    // Chỉ áp dụng trong môi trường phát triển\n    if (process.env.NODE_ENV !== \"production\") {\n      const originalError = console.error;\n      console.error = (...args) => {\n        if (\n          args[0]?.includes?.(\"ResizeObserver loop\") ||\n          args[0]?.message?.includes?.(\"ResizeObserver loop\")\n        ) {\n          // Bỏ qua cảnh báo ResizeObserver\n          return;\n        }\n        originalError.apply(console, args);\n      };\n\n      return () => {\n        console.error = originalError;\n      };\n    }\n  }, []);\n\n  // Ensure nodes are visible in the viewport\n  useEffect(() => {\n    if (!isInitialMount.current && nodes.length > 0 && reactFlowInstance) {\n      // Wait for rendering to complete, then fit view\n      const timeoutId = setTimeout(() => {\n        console.log(\"[FLOW] Fitting view to ensure nodes are visible\");\n        reactFlowInstance.fitView({\n          padding: 0.5,\n          includeHiddenNodes: true,\n          minZoom: 0.5,\n          maxZoom: 1.5,\n        });\n      }, 500);\n\n      return () => clearTimeout(timeoutId);\n    }\n  }, [nodes.length, reactFlowInstance]);\n\n  // Add a debug useEffect to log whenever nodes change\n  useEffect(() => {\n    if (nodes.length > 0) {\n      console.log(\"[FLOW] Nodes changed, current count:\", nodes.length);\n    }\n  }, [nodes]);\n\n  return (\n    <div ref={reactFlowWrapper} className=\"h-full w-full\">\n      {isEditing && showEditorPanel && (\n        <Panel position=\"right\" className=\"w-72 mr-2\">\n          <RoadmapEditorPanel\n            onStyleChange={handleStyleChange}\n            onConnectionTypeChange={handleConnectionTypeChange}\n            activeEdgeStyle={connectionType}\n            editMode={editMode}\n            onEditModeChange={(mode) => {\n              setEditMode(mode);\n              if (mode === \"connect\") {\n                toast({\n                  title: \"Connect mode\",\n                  description:\n                    \"Click on a source node, then click on a target node to create a connection\",\n                });\n              } else if (mode === \"delete\") {\n                toast({\n                  title: \"Delete mode\",\n                  description: \"Click on a node or connection to delete it\",\n                });\n              }\n            }}\n            onAddNodeClick={() => setIsAddCourseOpen(true)}\n          />\n        </Panel>\n      )}\n\n      {isEditing && (\n        <Panel\n          position=\"top-right\"\n          className=\"bg-cyberpunk-darker/90 p-3 rounded-md border border-purple-500/30 mb-4 shadow-lg mr-[300px]\"\n        >\n          <div className=\"flex gap-2 justify-end\">\n            <Button\n              size=\"sm\"\n              className=\"bg-cyberpunk-darker border border-purple-500/30 text-purple-300 hover:bg-purple-900/20\"\n              onClick={handleUndo}\n              disabled={undoStack.length === 0}\n            >\n              Undo\n            </Button>\n            <Button\n              size=\"sm\"\n              className=\"bg-cyberpunk-darker border border-purple-500/30 text-purple-300 hover:bg-purple-900/20\"\n              onClick={handleRedo}\n              disabled={redoStack.length === 0}\n            >\n              Redo\n            </Button>\n            <Button\n              className=\"bg-purple-600 hover:bg-purple-700 text-white\"\n              size=\"sm\"\n              onClick={handleSaveRoadmap}\n            >\n              <Save className=\"h-4 w-4 mr-1\" /> Save\n            </Button>\n          </div>\n        </Panel>\n      )}\n\n      <div className=\"h-full\">\n        <ReactFlow\n          key={`flow-${id}-${nodes.length}`}\n          nodes={filteredNodes()}\n          edges={edges}\n          onNodesChange={isEditing ? onNodesChange : undefined}\n          onEdgesChange={isEditing ? onEdgesChange : undefined}\n          onConnect={isEditing ? onConnect : undefined}\n          onNodeClick={onNodeClick}\n          onEdgeClick={onEdgeClick}\n          onPaneClick={onPaneClick}\n          nodeTypes={nodeTypes}\n          onNodeDragStop={onNodeDragStop}\n          nodesDraggable={isEditing}\n          nodesConnectable={isEditing && editMode === \"connect\"}\n          elementsSelectable={!readOnly}\n          defaultEdgeOptions={{\n            type: \"smoothstep\",\n            style: { stroke: \"#6d28d9\" },\n            animated: true,\n            ...(connectionType === \"arrow\" && {\n              markerEnd: {\n                type: MarkerType.ArrowClosed,\n                width: 20,\n                height: 20,\n                color: \"#6d28d9\",\n              },\n            }),\n            data: {\n              connectionType,\n            },\n          }}\n          fitView\n          fitViewOptions={{\n            padding: 0.5,\n            includeHiddenNodes: true,\n            minZoom: 0.5,\n            maxZoom: 1.5,\n          }}\n          minZoom={0.2}\n          maxZoom={4}\n          snapToGrid={true}\n          snapGrid={[10, 10]}\n          nodeExtent={[\n            [-2000, -2000],\n            [2000, 2000],\n          ]}\n          proOptions={{ hideAttribution: true }}\n          disableKeyboardA11y={true}\n          autoPanOnNodeDrag={false}\n          elevateEdgesOnSelect={false}\n          onInit={(instance) => {\n            // Use setTimeout to ensure proper initialization\n            setTimeout(() => {\n              if (nodes.length > 0) {\n                instance.fitView({ padding: 0.5 });\n                console.log(\n                  \"[FLOW] Flow initialized with nodes:\",\n                  nodes.length\n                );\n              }\n            }, 300);\n          }}\n        >\n          <Controls />\n          <MiniMap nodeStrokeWidth={3} zoomable pannable />\n          <Background variant=\"dots\" gap={12} size={1} color=\"#6d28d9\" />\n        </ReactFlow>\n      </div>\n\n      {selectedNode && (\n        <CourseInfoPanel\n          node={selectedNode}\n          onClose={() => setSelectedNode(null)}\n          onCompleteToggle={handleCompleteToggle}\n          onDelete={isEditing ? handleDeleteNode : undefined}\n          onUpdateStyle={handleUpdateNodeStyle}\n          isAdmin={isEditing}\n          readOnly={readOnly}\n        />\n      )}\n\n      {isAddCourseOpen && (\n        <AddCourseDialog\n          open={isAddCourseOpen}\n          onClose={() => setIsAddCourseOpen(false)}\n          onAdd={handleAddCourse}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default function RoadmapView(props) {\n  console.log(\"[FLOW] RoadmapView wrapper rendering with props:\", {\n    id: props.id,\n    nodesCount: props.initialNodes?.length,\n    edgesCount: props.initialEdges?.length,\n  });\n\n  return (\n    <ReactFlowProvider>\n      <div className=\"w-full h-full\">\n        <RoadmapViewInner {...props} />\n      </div>\n    </ReactFlowProvider>\n  );\n}\n"],"mappings":"AAAA,YAAY;;AAAC,IAAAA,YAAA;EAAAC,EAAA,GAAAC,YAAA;AAEb,SAASC,QAAQ,EAAEC,WAAW,EAAEC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAChE,OAAOC,SAAS,IACdC,OAAO,EACPC,QAAQ,EACRC,UAAU,EACVC,aAAa,EACbC,aAAa,EACbC,OAAO,EACPC,KAAK,EACLC,iBAAiB,EACjBC,YAAY,EACZC,UAAU,EACVC,UAAU,QACL,WAAW;AAClB,OAAO,0BAA0B;AACjC,SAASC,IAAI,EAAEC,QAAQ,EAAEC,WAAW,QAAQ,WAAW;AACvD,SAASC,MAAM,QAAQ,aAAa;AACpC,SAASC,QAAQ,QAAQ,gBAAgB;AACzC,SACEC,UAAU,EACVC,IAAI,EACJC,KAAK,EACLC,IAAI,EACJC,CAAC,EACDC,IAAI,IAAIC,QAAQ,EAChBC,OAAO,EACPC,OAAO,QACF,cAAc;AACrB,OAAOC,UAAU,MAAM,cAAc;AACrC,OAAOC,eAAe,MAAM,mBAAmB;AAC/C,OAAOC,eAAe,MAAM,mBAAmB;AAC/C,OAAOC,kBAAkB,MAAM,sBAAsB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEtD,MAAMC,SAAS,GAAG;EAChBC,UAAU,EAAEP;AACd,CAAC;AAED,SAASQ,gBAAgBA,CAAC;EACxBC,EAAE;EACFC,YAAY,GAAG,EAAE;EACjBC,YAAY,GAAG,EAAE;EACjBC,SAAS,GAAG,KAAK;EACjBC,QAAQ,GAAG,KAAK;EAChBC,MAAM;EACNC;AACF,CAAC,EAAE;EAAA/C,EAAA;EACD,MAAM;IAAEgD;EAAM,CAAC,GAAG1B,QAAQ,CAAC,CAAC;EAC5B,MAAM,CAAC2B,KAAK,EAAEC,QAAQ,EAAEC,aAAa,CAAC,GAAGzC,aAAa,CAACgC,YAAY,CAAC;EACpE,MAAM,CAACU,KAAK,EAAEC,QAAQ,EAAEC,aAAa,CAAC,GAAG3C,aAAa,CAACgC,YAAY,CAAC;EACpE,MAAM,CAACY,YAAY,EAAEC,eAAe,CAAC,GAAGtD,QAAQ,CAAC,IAAI,CAAC;EACtD,MAAM,CAACuD,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGxD,QAAQ,CAAC,KAAK,CAAC;EAC/D,MAAM,CAACyD,eAAe,EAAEC,kBAAkB,CAAC,GAAG1D,QAAQ,CAAC,KAAK,CAAC;EAC7D,MAAM,CAAC2D,QAAQ,EAAEC,WAAW,CAAC,GAAG5D,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;EACpD,MAAM,CAAC6D,cAAc,EAAEC,iBAAiB,CAAC,GAAG9D,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;EAC/D,MAAM,CAAC+D,eAAe,EAAEC,kBAAkB,CAAC,GAAGhE,QAAQ,CAAC,IAAI,CAAC;EAC5D,MAAMiE,gBAAgB,GAAG9D,MAAM,CAAC,IAAI,CAAC;EACrC,MAAM+D,iBAAiB,GAAGrD,YAAY,CAAC,CAAC;EACxC,MAAM,CAACsD,SAAS,EAAEC,YAAY,CAAC,GAAGpE,QAAQ,CAAC,EAAE,CAAC;EAC9C,MAAM,CAACqE,SAAS,EAAEC,YAAY,CAAC,GAAGtE,QAAQ,CAAC,EAAE,CAAC;EAC9C,MAAMuE,cAAc,GAAGpE,MAAM,CAAC,IAAI,CAAC;EACnC;EACA,MAAMqE,aAAa,GAAGrE,MAAM,CAAC,EAAE,CAAC;;EAEhC;EACA,MAAMsE,oBAAoB,GAAGxE,WAAW,CACtC,CAACyE,MAAM,EAAEC,SAAS,KAAK;IAAA,IAAAC,WAAA;IACrB,IAAIjC,QAAQ,EAAE;;IAEd;IACA,MAAMkC,WAAW,GAAGF,SAAS,GAAG,IAAIG,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAG,IAAI;IAE/D/B,QAAQ,CAAEgC,GAAG,IACXA,GAAG,CAACC,GAAG,CAAEC,IAAI,IAAK;MAChB,IAAIA,IAAI,CAAC3C,EAAE,KAAKmC,MAAM,EAAE;QACtB,OAAO;UACL,GAAGQ,IAAI;UACPC,IAAI,EAAE;YACJ,GAAGD,IAAI,CAACC,IAAI;YACZR,SAAS;YACTE;UACF;QACF,CAAC;MACH;MACA,OAAOK,IAAI;IACb,CAAC,CACH,CAAC;IAEDpC,KAAK,CAAC;MACJsC,KAAK,EAAET,SAAS,GACZ,4BAA4B,GAC5B,6BAA6B;MACjCU,WAAW,EAAE,UAAUV,SAAS,GAAG,WAAW,GAAG,UAAU,KAAAC,WAAA,GACzD7B,KAAK,CAACuC,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAAChD,EAAE,KAAKmC,MAAM,CAAC,cAAAE,WAAA,uBAAlCA,WAAA,CAAoCO,IAAI,CAACK,KAAK;IAElD,CAAC,CAAC;EACJ,CAAC,EACD,CAACzC,KAAK,EAAEC,QAAQ,EAAEF,KAAK,EAAEH,QAAQ,CACnC,CAAC;;EAED;EACAzC,SAAS,CAAC,MAAM;IACd;IACA,IAAI,EAACsC,YAAY,aAAZA,YAAY,eAAZA,YAAY,CAAEiD,MAAM,KAAI,EAAChD,YAAY,aAAZA,YAAY,eAAZA,YAAY,CAAEgD,MAAM,GAAE;MAClD;IACF;;IAEA;IACA,IAAIlB,cAAc,CAACmB,OAAO,IAAI,CAAAlD,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEiD,MAAM,IAAG,CAAC,EAAE;MACtDE,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAEpD,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEiD,MAAM,CAAC;MAE7D,IAAI,CAAAjD,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEiD,MAAM,IAAG,CAAC,EAAE;QAC5B;QACA,MAAMI,cAAc,GAAGrD,YAAY,CAACyC,GAAG,CAAEC,IAAI;UAAA,IAAAY,UAAA;UAAA,OAAM;YACjD,GAAGZ,IAAI;YACPa,IAAI,EAAE,YAAY;YAClB;YACAC,QAAQ,EAAEd,IAAI,CAACc,QAAQ,IAAI;cACzBC,CAAC,EAAEC,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG;cACtBC,CAAC,EAAEF,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG;YACrB,CAAC;YACDhB,IAAI,EAAE;cACJ,GAAGD,IAAI,CAACC,IAAI;cACZkB,eAAe,EAAE,IAAI;cACrBC,aAAa,EAAE7B,oBAAoB;cACnC;cACAe,KAAK,EAAE,EAAAM,UAAA,GAAAZ,IAAI,CAACC,IAAI,cAAAW,UAAA,uBAATA,UAAA,CAAWN,KAAK,KAAI;YAC7B;UACF,CAAC;QAAA,CAAC,CAAC;;QAEH;QACA,MAAMe,cAAc,GAAG,IAAIC,GAAG,CAAChE,YAAY,CAACyC,GAAG,CAAEM,CAAC,IAAKA,CAAC,CAAChD,EAAE,CAAC,CAAC;QAC7D,MAAMkE,yBAAyB,GAAGjC,aAAa,CAACkB,OAAO,CAACgB,MAAM,CAC3DnB,CAAC,IAAK,CAACgB,cAAc,CAACI,GAAG,CAACpB,CAAC,CAAChD,EAAE,CACjC,CAAC;QAED,IAAIkE,yBAAyB,CAAChB,MAAM,GAAG,CAAC,EAAE;UACxCE,OAAO,CAACC,GAAG,CACT,kBAAkBa,yBAAyB,CAAChB,MAAM,yCACpD,CAAC;;UAED;UACAzC,QAAQ,CAAC,CAAC,GAAG6C,cAAc,EAAE,GAAGY,yBAAyB,CAAC,CAAC;QAC7D,CAAC,MAAM;UACLd,OAAO,CAACC,GAAG,CAAC,6CAA6C,CAAC;UAC1D5C,QAAQ,CAAC6C,cAAc,CAAC;QAC1B;MACF;MAEA,IAAI,CAAApD,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEgD,MAAM,IAAG,CAAC,EAAE;QAC5BE,OAAO,CAACC,GAAG,CAAC,+BAA+B,EAAEnD,YAAY,CAACgD,MAAM,CAAC;QACjEtC,QAAQ,CAAC,CAAC,GAAGV,YAAY,CAAC,CAAC;MAC7B;;MAEA;MACA,MAAMmE,SAAS,GAAGC,UAAU,CAAC,MAAM;QACjC,MAAMC,UAAU,GAAGC,QAAQ,CAACC,aAAa,CAAC,uBAAuB,CAAC;QAClE,IAAIF,UAAU,EAAE;UACdA,UAAU,CAACG,KAAK,CAACC,kBAAkB,GAAG,WAAW;UACjDJ,UAAU,CAACG,KAAK,CAACE,kBAAkB,GAAG,MAAM;QAC9C;MACF,CAAC,EAAE,GAAG,CAAC;MAEP5C,cAAc,CAACmB,OAAO,GAAG,KAAK;MAC9B,OAAO,MAAM0B,YAAY,CAACR,SAAS,CAAC;IACtC;EACF,CAAC,EAAE,CAACpE,YAAY,EAAEC,YAAY,EAAEO,QAAQ,EAAEG,QAAQ,EAAEsB,oBAAoB,CAAC,CAAC;;EAE1E;EACAvE,SAAS,CAAC,MAAM;IACd,IAAIqE,cAAc,CAACmB,OAAO,EAAE,OAAO,CAAC;;IAEpC;IACA,IAAIlD,YAAY,IAAIA,YAAY,CAACiD,MAAM,GAAG,CAAC,EAAE;MAC3C;MACA,MAAM4B,UAAU,GAAG,IAAIb,GAAG,CAACzD,KAAK,CAACkC,GAAG,CAAEM,CAAC,IAAKA,CAAC,CAAChD,EAAE,CAAC,CAAC;MAClD,MAAM+E,UAAU,GAAG,IAAId,GAAG,CAAChE,YAAY,CAACyC,GAAG,CAAEM,CAAC,IAAKA,CAAC,CAAChD,EAAE,CAAC,CAAC;;MAEzD;MACA,IACE+E,UAAU,CAACC,IAAI,KAAKF,UAAU,CAACE,IAAI,IACnC/E,YAAY,CAACgF,IAAI,CAAEjC,CAAC,IAAK,CAAC8B,UAAU,CAACV,GAAG,CAACpB,CAAC,CAAChD,EAAE,CAAC,CAAC,EAC/C;QACAoD,OAAO,CAACC,GAAG,CAAC,2CAA2C,CAAC;QAExD,MAAMC,cAAc,GAAGrD,YAAY,CAACyC,GAAG,CAAEC,IAAI;UAAA,IAAAuC,WAAA;UAAA,OAAM;YACjD,GAAGvC,IAAI;YACPa,IAAI,EAAE,YAAY;YAClBC,QAAQ,EAAEd,IAAI,CAACc,QAAQ,IAAI;cACzBC,CAAC,EAAEC,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG;cACtBC,CAAC,EAAEF,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG;YACrB,CAAC;YACDhB,IAAI,EAAE;cACJ,GAAGD,IAAI,CAACC,IAAI;cACZkB,eAAe,EAAE,IAAI;cACrBC,aAAa,EAAE7B,oBAAoB;cACnCe,KAAK,EAAE,EAAAiC,WAAA,GAAAvC,IAAI,CAACC,IAAI,cAAAsC,WAAA,uBAATA,WAAA,CAAWjC,KAAK,KAAI;YAC7B;UACF,CAAC;QAAA,CAAC,CAAC;QAEHxC,QAAQ,CAAC6C,cAAc,CAAC;MAC1B;IACF;EACF,CAAC,EAAE,CAACrD,YAAY,EAAEO,KAAK,EAAEC,QAAQ,EAAEyB,oBAAoB,CAAC,CAAC;;EAEzD;EACAvE,SAAS,CAAC,MAAM;IACd,IAAIqE,cAAc,CAACmB,OAAO,EAAE,OAAO,CAAC;;IAEpC,MAAMgC,KAAK,GAAGb,UAAU,CAAC,MAAM;MAC7B,IACE,CAAC9D,KAAK,CAAC0C,MAAM,GAAG,CAAC,IAAIvC,KAAK,CAACuC,MAAM,GAAG,CAAC,KACrC,OAAO5C,gBAAgB,KAAK,UAAU,EACtC;QACA8C,OAAO,CAACC,GAAG,CAAC,2CAA2C,CAAC;QACxD/C,gBAAgB,CAACE,KAAK,EAAEG,KAAK,CAAC;MAChC;IACF,CAAC,EAAE,GAAG,CAAC;IAEP,OAAO,MAAMkE,YAAY,CAACM,KAAK,CAAC;EAClC,CAAC,EAAE,CAAC3E,KAAK,EAAEG,KAAK,EAAEL,gBAAgB,CAAC,CAAC;;EAEpC;EACA,MAAM8E,gBAAgB,GAAG1H,WAAW,CAAC,MAAM;IACzCmE,YAAY,CAAEwD,IAAI,IAAK,CAAC,GAAGA,IAAI,EAAE;MAAE7E,KAAK,EAAE,CAAC,GAAGA,KAAK,CAAC;MAAEG,KAAK,EAAE,CAAC,GAAGA,KAAK;IAAE,CAAC,CAAC,CAAC;IAC3EoB,YAAY,CAAC,EAAE,CAAC;EAClB,CAAC,EAAE,CAACvB,KAAK,EAAEG,KAAK,CAAC,CAAC;EAElB,MAAM2E,SAAS,GAAG5H,WAAW,CAC1B6H,MAAM,IAAK;IACVH,gBAAgB,CAAC,CAAC;IAClB;IACA,MAAMI,OAAO,GAAG;MACd,GAAGD,MAAM;MACTvF,EAAE,EAAE,QAAQuC,IAAI,CAACkD,GAAG,CAAC,CAAC,EAAE;MACxBjC,IAAI,EAAE,YAAY;MAClBkC,QAAQ,EAAE,IAAI;MACdhB,KAAK,EAAE;QAAEiB,MAAM,EAAE;MAAU,CAAC;MAC5B;MACA,IAAIrE,cAAc,KAAK,OAAO,IAAI;QAChCsE,SAAS,EAAE;UACTpC,IAAI,EAAEjF,UAAU,CAACsH,WAAW;UAC5BC,KAAK,EAAE,EAAE;UACTC,MAAM,EAAE,EAAE;UACVC,KAAK,EAAE;QACT;MACF,CAAC,CAAC;MACFpD,IAAI,EAAE;QACJtB;MACF;IACF,CAAC;IACDV,QAAQ,CAAEqF,GAAG,IAAK9H,OAAO,CAACqH,OAAO,EAAES,GAAG,CAAC,CAAC;IAExC1F,KAAK,CAAC;MACJsC,KAAK,EAAE,kBAAkB;MACzBC,WAAW,EAAE;IACf,CAAC,CAAC;EACJ,CAAC,EACD,CAAClC,QAAQ,EAAEwE,gBAAgB,EAAE7E,KAAK,EAAEe,cAAc,CACpD,CAAC;EAED,MAAM4E,WAAW,GAAGxI,WAAW,CAC7B,CAACyI,KAAK,EAAExD,IAAI,KAAK;IACfwD,KAAK,CAACC,eAAe,CAAC,CAAC;IAEvB,IAAIhF,QAAQ,KAAK,QAAQ,EAAE;MACzB;MACAgE,gBAAgB,CAAC,CAAC;MAClB3E,QAAQ,CAACD,KAAK,CAAC2D,MAAM,CAAEnB,CAAC,IAAKA,CAAC,CAAChD,EAAE,KAAK2C,IAAI,CAAC3C,EAAE,CAAC,CAAC;MAC/C;MACAY,QAAQ,CACND,KAAK,CAACwD,MAAM,CAAEkC,CAAC,IAAKA,CAAC,CAACC,MAAM,KAAK3D,IAAI,CAAC3C,EAAE,IAAIqG,CAAC,CAACE,MAAM,KAAK5D,IAAI,CAAC3C,EAAE,CAClE,CAAC;MAEDO,KAAK,CAAC;QACJsC,KAAK,EAAE,cAAc;QACrBC,WAAW,EAAE,GAAGH,IAAI,CAACC,IAAI,CAACK,KAAK;MACjC,CAAC,CAAC;IACJ,CAAC,MAAM,IAAI7B,QAAQ,KAAK,SAAS,IAAIN,YAAY,EAAE;MACjD;MACA,IAAIA,YAAY,CAACd,EAAE,KAAK2C,IAAI,CAAC3C,EAAE,EAAE;QAC/B,MAAMwF,OAAO,GAAG;UACdxF,EAAE,EAAE,QAAQuC,IAAI,CAACkD,GAAG,CAAC,CAAC,EAAE;UACxBa,MAAM,EAAExF,YAAY,CAACd,EAAE;UACvBuG,MAAM,EAAE5D,IAAI,CAAC3C,EAAE;UACfwD,IAAI,EAAE,YAAY;UAClBkC,QAAQ,EAAE,IAAI;UACdhB,KAAK,EAAE;YAAEiB,MAAM,EAAE;UAAU,CAAC;UAC5B,IAAIrE,cAAc,KAAK,OAAO,IAAI;YAChCsE,SAAS,EAAE;cACTpC,IAAI,EAAEjF,UAAU,CAACsH,WAAW;cAC5BC,KAAK,EAAE,EAAE;cACTC,MAAM,EAAE,EAAE;cACVC,KAAK,EAAE;YACT;UACF,CAAC,CAAC;UACFpD,IAAI,EAAE;YACJtB;UACF;QACF,CAAC;QAED8D,gBAAgB,CAAC,CAAC;QAClBxE,QAAQ,CAAEqF,GAAG,IAAK,CAAC,GAAGA,GAAG,EAAET,OAAO,CAAC,CAAC;QACpCzE,eAAe,CAAC,IAAI,CAAC;QACrBM,WAAW,CAAC,QAAQ,CAAC;QAErBd,KAAK,CAAC;UACJsC,KAAK,EAAE,oBAAoB;UAC3BC,WAAW,EAAE,aAAahC,YAAY,CAAC8B,IAAI,CAACK,KAAK,OAAON,IAAI,CAACC,IAAI,CAACK,KAAK;QACzE,CAAC,CAAC;MACJ;IACF,CAAC,MAAM,IAAI7B,QAAQ,KAAK,QAAQ,EAAE;MAChC;MACAL,eAAe,CAAC4B,IAAI,CAAC;IACvB;EACF,CAAC,EACD,CACEvB,QAAQ,EACRN,YAAY,EACZN,KAAK,EACLG,KAAK,EACLF,QAAQ,EACRG,QAAQ,EACRwE,gBAAgB,EAChB7E,KAAK,CAET,CAAC;EAED,MAAMiG,WAAW,GAAG9I,WAAW,CAAC,MAAM;IACpC;IACAqD,eAAe,CAAC,IAAI,CAAC;;IAErB;IACA,IAAIK,QAAQ,KAAK,SAAS,IAAIN,YAAY,EAAE;MAC1CO,WAAW,CAAC,QAAQ,CAAC;MACrBN,eAAe,CAAC,IAAI,CAAC;MACrBR,KAAK,CAAC;QACJsC,KAAK,EAAE,sBAAsB;QAC7BC,WAAW,EAAE;MACf,CAAC,CAAC;IACJ;EACF,CAAC,EAAE,CAAC1B,QAAQ,EAAEN,YAAY,EAAEP,KAAK,CAAC,CAAC;EAEnC,MAAMkG,iBAAiB,GAAG/I,WAAW,CAAC,MAAM;IAC1C,IAAI2C,MAAM,EAAE;MACV+C,OAAO,CAACC,GAAG,CAAC,sCAAsC,CAAC;MACnDD,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAE7C,KAAK,CAAC0C,MAAM,CAAC;MAClDE,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAE1C,KAAK,CAACuC,MAAM,CAAC;;MAElD;MACA,MAAMwD,YAAY,GAAGlG,KAAK,CAACkC,GAAG,CAAEC,IAAI,IAAK;QAAA,IAAAgE,WAAA;QACvC,IAAI,CAAChE,IAAI,CAAC3C,EAAE,EAAE;UACZoD,OAAO,CAACwD,KAAK,CAAC,yBAAyB,EAAEjE,IAAI,CAAC;UAC9C;UACAA,IAAI,CAAC3C,EAAE,GAAG,QAAQuC,IAAI,CAACkD,GAAG,CAAC,CAAC,IAAI9B,IAAI,CAACC,MAAM,CAAC,CAAC,CAC1CiD,QAAQ,CAAC,EAAE,CAAC,CACZC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;QACtB;QAEA,IAAI,CAACnE,IAAI,CAACc,QAAQ,EAAE;UAClBL,OAAO,CAACwD,KAAK,CAAC,+BAA+B,EAAEjE,IAAI,CAAC;UACpD;UACAA,IAAI,CAACc,QAAQ,GAAG;YAAEC,CAAC,EAAE,CAAC;YAAEG,CAAC,EAAE;UAAE,CAAC;QAChC;QAEA,IAAI,CAAClB,IAAI,CAACC,IAAI,EAAE;UACdQ,OAAO,CAACwD,KAAK,CAAC,2BAA2B,EAAEjE,IAAI,CAAC;UAChD;UACAA,IAAI,CAACC,IAAI,GAAG;YAAEK,KAAK,EAAE,OAAO,GAAGN,IAAI,CAAC3C;UAAG,CAAC;QAC1C;;QAEA;QACA,OAAO;UACL,GAAG2C,IAAI;UACPa,IAAI,EAAEb,IAAI,CAACa,IAAI,IAAI,YAAY;UAAE;UACjCZ,IAAI,EAAE;YACJ,IAAID,IAAI,CAACC,IAAI,IAAI,CAAC,CAAC,CAAC;YACpB5C,EAAE,EAAE2C,IAAI,CAAC3C,EAAE;YAAE;YACbiD,KAAK,EAAE,EAAA0D,WAAA,GAAAhE,IAAI,CAACC,IAAI,cAAA+D,WAAA,uBAATA,WAAA,CAAW1D,KAAK,KAAI,UAAU,CAAE;UACzC;QACF,CAAC;MACH,CAAC,CAAC;;MAEF;MACA,MAAM8D,YAAY,GAAGpG,KAAK,CACvB+B,GAAG,CAAEsE,IAAI,IAAK;QACb,IAAI,CAACA,IAAI,CAACV,MAAM,IAAI,CAACU,IAAI,CAACT,MAAM,EAAE;UAChCnD,OAAO,CAACwD,KAAK,CAAC,uCAAuC,EAAEI,IAAI,CAAC;UAC5D,OAAO,IAAI,CAAC,CAAC;QACf;QAEA,IAAI,CAACA,IAAI,CAAChH,EAAE,EAAE;UACZoD,OAAO,CAACwD,KAAK,CAAC,yBAAyB,EAAEI,IAAI,CAAC;UAC9C;UACAA,IAAI,CAAChH,EAAE,GAAG,QAAQuC,IAAI,CAACkD,GAAG,CAAC,CAAC,IAAI9B,IAAI,CAACC,MAAM,CAAC,CAAC,CAC1CiD,QAAQ,CAAC,EAAE,CAAC,CACZC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;QACtB;QAEA,OAAO;UACL,GAAGE,IAAI;UACPxD,IAAI,EAAEwD,IAAI,CAACxD,IAAI,IAAI,YAAY,CAAE;QACnC,CAAC;MACH,CAAC,CAAC,CACDW,MAAM,CAAC8C,OAAO,CAAC,CAAC,CAAC;;MAEpB7D,OAAO,CAACC,GAAG,CAAC,kCAAkC,EAAEqD,YAAY,CAACxD,MAAM,CAAC;MACpEE,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAEqD,YAAY,CAAC,CAAC,CAAC,CAAC;MACxDtD,OAAO,CAACC,GAAG,CAAC,kCAAkC,EAAE0D,YAAY,CAAC7D,MAAM,CAAC;MACpE,IAAI6D,YAAY,CAAC7D,MAAM,GAAG,CAAC,EAAE;QAC3BE,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAE0D,YAAY,CAAC,CAAC,CAAC,CAAC;MAC1D;;MAEA;MACAxG,KAAK,CAAC;QACJsC,KAAK,EAAE,mBAAmB;QAC1BC,WAAW,EAAE,UAAU4D,YAAY,CAACxD,MAAM,cAAc6D,YAAY,CAAC7D,MAAM;MAC7E,CAAC,CAAC;;MAEF;MACAzC,QAAQ,CAACiG,YAAY,CAAC;MACtB9F,QAAQ,CAACmG,YAAY,CAAC;;MAEtB;MACA3D,OAAO,CAACC,GAAG,CAAC,yCAAyC,CAAC;MACtDhD,MAAM,CAACqG,YAAY,EAAEK,YAAY,CAAC;IACpC,CAAC,MAAM;MACL3D,OAAO,CAAC8D,IAAI,CAAC,wDAAwD,CAAC;MACtE3G,KAAK,CAAC;QACJsC,KAAK,EAAE,qBAAqB;QAC5BC,WAAW,EAAE,6BAA6B;QAC1CqE,OAAO,EAAE;MACX,CAAC,CAAC;IACJ;EACF,CAAC,EAAE,CAAC3G,KAAK,EAAEG,KAAK,EAAEN,MAAM,EAAEE,KAAK,EAAEE,QAAQ,EAAEG,QAAQ,CAAC,CAAC;EAErD,MAAMwG,eAAe,GAAG1J,WAAW,CAChC2J,UAAU,IAAK;IACdjC,gBAAgB,CAAC,CAAC;;IAElB;IACA,MAAMkC,SAAS,GAAG,QAAQ/E,IAAI,CAACkD,GAAG,CAAC,CAAC,IAAI9B,IAAI,CAACC,MAAM,CAAC,CAAC,CAClDiD,QAAQ,CAAC,EAAE,CAAC,CACZC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;;IAEpB;IACA,IAAIrD,QAAQ,GAAG;MACbC,CAAC,EAAEC,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG;MAC5BC,CAAC,EAAEF,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG;IAC3B,CAAC;;IAED;IACA,IAAIjC,iBAAiB,EAAE;MACrB,IAAI;QACF;QACA,MAAM4F,QAAQ,GAAG5F,iBAAiB,CAAC6F,WAAW,CAAC,CAAC;;QAEhD;QACA,MAAMC,MAAM,GAAG9F,iBAAiB,CAAC+F,oBAAoB,CAAC;UACpDhE,CAAC,EAAEiE,MAAM,CAACC,UAAU,GAAG,CAAC;UACxB/D,CAAC,EAAE8D,MAAM,CAACE,WAAW,GAAG;QAC1B,CAAC,CAAC;QAEFpE,QAAQ,GAAG;UACTC,CAAC,EAAE+D,MAAM,CAAC/D,CAAC;UACXG,CAAC,EAAE4D,MAAM,CAAC5D;QACZ,CAAC;;QAED;QACAJ,QAAQ,CAACC,CAAC,IAAI,CAACC,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,IAAI,GAAG;QACzCH,QAAQ,CAACI,CAAC,IAAI,CAACF,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,IAAI,GAAG;;QAEzC;QACA,IAAIpD,KAAK,CAAC0C,MAAM,GAAG,CAAC,EAAE;UACpB,MAAM4E,QAAQ,GAAGtH,KAAK,CAACyE,IAAI,CACxBtC,IAAI,IACHgB,IAAI,CAACoE,GAAG,CAACpF,IAAI,CAACc,QAAQ,CAACC,CAAC,GAAGD,QAAQ,CAACC,CAAC,CAAC,GAAG,GAAG,IAC5CC,IAAI,CAACoE,GAAG,CAACpF,IAAI,CAACc,QAAQ,CAACI,CAAC,GAAGJ,QAAQ,CAACI,CAAC,CAAC,GAAG,GAC7C,CAAC;UAED,IAAIiE,QAAQ,EAAE;YACZ;YACA,MAAME,SAAS,GAAG,CAChB;cAAEtE,CAAC,EAAE,CAAC;cAAEG,CAAC,EAAE;YAAE,CAAC,EACd;cAAEH,CAAC,EAAE,CAAC,CAAC;cAAEG,CAAC,EAAE;YAAE,CAAC,EACf;cAAEH,CAAC,EAAE,CAAC,CAAC;cAAEG,CAAC,EAAE,CAAC;YAAE,CAAC,EAChB;cAAEH,CAAC,EAAE,CAAC;cAAEG,CAAC,EAAE,CAAC;YAAE,CAAC,CAChB;YAED,MAAMoE,MAAM,GAAGD,SAAS,CAACxH,KAAK,CAAC0C,MAAM,GAAG8E,SAAS,CAAC9E,MAAM,CAAC;YACzDO,QAAQ,CAACC,CAAC,IAAIuE,MAAM,CAACvE,CAAC,GAAG,GAAG;YAC5BD,QAAQ,CAACI,CAAC,IAAIoE,MAAM,CAACpE,CAAC,GAAG,GAAG;UAC9B;QACF;MACF,CAAC,CAAC,OAAO+C,KAAK,EAAE;QACdxD,OAAO,CAACwD,KAAK,CAAC,yCAAyC,EAAEA,KAAK,CAAC;QAC/D;QACAnD,QAAQ,GAAG;UACTC,CAAC,EAAE,GAAG,GAAGlD,KAAK,CAAC0C,MAAM,GAAG,GAAG;UAC3BW,CAAC,EAAE,GAAG,GAAIrD,KAAK,CAAC0C,MAAM,GAAG,CAAC,GAAI;QAChC,CAAC;MACH;IACF,CAAC,MAAM;MACL;MACAO,QAAQ,GAAG;QACTC,CAAC,EAAE,GAAG,GAAGlD,KAAK,CAAC0C,MAAM,GAAG,GAAG;QAC3BW,CAAC,EAAE,GAAG,GAAIrD,KAAK,CAAC0C,MAAM,GAAG,CAAC,GAAI;MAChC,CAAC;IACH;IAEAE,OAAO,CAACC,GAAG,CACT,2CAA2CI,QAAQ,CAACC,CAAC,OAAOD,QAAQ,CAACI,CAAC,EACxE,CAAC;;IAED;IACA,MAAMqE,OAAO,GAAG;MACdlI,EAAE,EAAEsH,SAAS;MACb9D,IAAI,EAAE,YAAY;MAClBC,QAAQ;MACRb,IAAI,EAAE;QACJ,GAAGyE,UAAU;QACbjF,SAAS,EAAE,KAAK;QAChBE,WAAW,EAAE,IAAI;QACjBwB,eAAe,EAAE,IAAI;QACrBC,aAAa,EAAE7B,oBAAoB;QACnClC,EAAE,EAAEsH;MACN;IACF,CAAC;;IAED;IACArF,aAAa,CAACkB,OAAO,GAAG,CAAC,GAAGlB,aAAa,CAACkB,OAAO,EAAE+E,OAAO,CAAC;;IAE3D;IACAzH,QAAQ,CAAE0H,YAAY,IAAK;MACzB;MACA,MAAMC,WAAW,GAAG,IAAInE,GAAG,CAACkE,YAAY,CAACzF,GAAG,CAAEM,CAAC,IAAKA,CAAC,CAAChD,EAAE,CAAC,CAAC;;MAE1D;MACA,MAAMqI,iBAAiB,GAAGpG,aAAa,CAACkB,OAAO,CAACgB,MAAM,CACnDnB,CAAC,IAAK,CAACoF,WAAW,CAAChE,GAAG,CAACpB,CAAC,CAAChD,EAAE,CAC9B,CAAC;;MAED;MACA,MAAMsI,YAAY,GAAG,CAAC,GAAGH,YAAY,CAAC;;MAEtC;MACA,IAAI,CAACC,WAAW,CAAChE,GAAG,CAAC8D,OAAO,CAAClI,EAAE,CAAC,EAAE;QAChCsI,YAAY,CAACC,IAAI,CAACL,OAAO,CAAC;MAC5B;MAEA9E,OAAO,CAACC,GAAG,CACT,4CAA4CiF,YAAY,CAACpF,MAAM,QACjE,CAAC;MACD,OAAOoF,YAAY;IACrB,CAAC,CAAC;;IAEF;IACAnH,kBAAkB,CAAC,KAAK,CAAC;;IAEzB;IACAZ,KAAK,CAAC;MACJsC,KAAK,EAAE,cAAc;MACrBC,WAAW,EAAE,GAAGuE,UAAU,CAACpE,KAAK;IAClC,CAAC,CAAC;;IAEF;IACAqB,UAAU,CAAC,MAAM;MACf,IAAI3C,iBAAiB,EAAE;QACrBA,iBAAiB,CAAC6G,OAAO,CAAC;UAAEC,OAAO,EAAE;QAAI,CAAC,CAAC;MAC7C;IACF,CAAC,EAAE,GAAG,CAAC;EACT,CAAC,EACD,CACEhI,QAAQ,EACRF,KAAK,EACLoB,iBAAiB,EACjBnB,KAAK,EACL0B,oBAAoB,EACpBkD,gBAAgB,CAEpB,CAAC;;EAED;EACAzH,SAAS,CAAC,MAAM;IACd,IAAIsE,aAAa,CAACkB,OAAO,CAACD,MAAM,GAAG,CAAC,IAAI1C,KAAK,CAAC0C,MAAM,GAAG,CAAC,EAAE;MACxD;MACA,MAAM4B,UAAU,GAAG,IAAIb,GAAG,CAACzD,KAAK,CAACkC,GAAG,CAAEM,CAAC,IAAKA,CAAC,CAAChD,EAAE,CAAC,CAAC;;MAElD;MACA,MAAM0I,YAAY,GAAGzG,aAAa,CAACkB,OAAO,CAACgB,MAAM,CAC9CnB,CAAC,IAAK,CAAC8B,UAAU,CAACV,GAAG,CAACpB,CAAC,CAAChD,EAAE,CAC7B,CAAC;;MAED;MACA,IAAI0I,YAAY,CAACxF,MAAM,GAAG,CAAC,EAAE;QAC3BE,OAAO,CAACC,GAAG,CACT,oBAAoBqF,YAAY,CAACxF,MAAM,sCACzC,CAAC;QACDzC,QAAQ,CAAE0H,YAAY,IAAK,CAAC,GAAGA,YAAY,EAAE,GAAGO,YAAY,CAAC,CAAC;MAChE;IACF;EACF,CAAC,EAAE,CAAClI,KAAK,EAAEC,QAAQ,CAAC,CAAC;EAErB,MAAMkI,gBAAgB,GAAGjL,WAAW,CACjCyE,MAAM,IAAK;IACViD,gBAAgB,CAAC,CAAC;;IAElB;IACA3E,QAAQ,CAAEgC,GAAG,IAAKA,GAAG,CAAC0B,MAAM,CAAExB,IAAI,IAAKA,IAAI,CAAC3C,EAAE,KAAKmC,MAAM,CAAC,CAAC;IAC3D;IACAvB,QAAQ,CAAEqF,GAAG,IACXA,GAAG,CAAC9B,MAAM,CAAE6C,IAAI,IAAKA,IAAI,CAACV,MAAM,KAAKnE,MAAM,IAAI6E,IAAI,CAACT,MAAM,KAAKpE,MAAM,CACvE,CAAC;IAEDpB,eAAe,CAAC,IAAI,CAAC;IAErBR,KAAK,CAAC;MACJsC,KAAK,EAAE,cAAc;MACrBC,WAAW,EAAE;IACf,CAAC,CAAC;EACJ,CAAC,EACD,CAACrC,QAAQ,EAAEG,QAAQ,EAAEL,KAAK,EAAE6E,gBAAgB,CAC9C,CAAC;EAED,MAAMwD,qBAAqB,GAAGlL,WAAW,CACvC,CAACyE,MAAM,EAAEuC,KAAK,KAAK;IACjBjE,QAAQ,CAAEgC,GAAG,IACXA,GAAG,CAACC,GAAG,CAAEC,IAAI,IAAK;MAChB,IAAIA,IAAI,CAAC3C,EAAE,KAAKmC,MAAM,EAAE;QACtB,OAAO;UACL,GAAGQ,IAAI;UACPC,IAAI,EAAE;YACJ,GAAGD,IAAI,CAACC,IAAI;YACZ,GAAG8B;UACL;QACF,CAAC;MACH;MACA,OAAO/B,IAAI;IACb,CAAC,CACH,CAAC;EACH,CAAC,EACD,CAAClC,QAAQ,CACX,CAAC;EAED,MAAMoI,WAAW,GAAGnL,WAAW,CAC7B,CAACyI,KAAK,EAAEa,IAAI,KAAK;IACf,IAAI5F,QAAQ,KAAK,QAAQ,EAAE;MACzBgE,gBAAgB,CAAC,CAAC;;MAElB;MACAxE,QAAQ,CAAEqF,GAAG,IAAKA,GAAG,CAAC9B,MAAM,CAAEkC,CAAC,IAAKA,CAAC,CAACrG,EAAE,KAAKgH,IAAI,CAAChH,EAAE,CAAC,CAAC;MAEtDO,KAAK,CAAC;QACJsC,KAAK,EAAE,oBAAoB;QAC3BC,WAAW,EAAE;MACf,CAAC,CAAC;IACJ;EACF,CAAC,EACD,CAAClC,QAAQ,EAAEQ,QAAQ,EAAEgE,gBAAgB,EAAE7E,KAAK,CAC9C,CAAC;EAED,MAAMuI,UAAU,GAAGpL,WAAW,CAAC,MAAM;IACnC,IAAIkE,SAAS,CAACsB,MAAM,KAAK,CAAC,EAAE;IAE5B,MAAM6F,YAAY,GAAG;MAAEvI,KAAK,EAAE,CAAC,GAAGA,KAAK,CAAC;MAAEG,KAAK,EAAE,CAAC,GAAGA,KAAK;IAAE,CAAC;IAC7D,MAAMqI,aAAa,GAAGpH,SAAS,CAACA,SAAS,CAACsB,MAAM,GAAG,CAAC,CAAC;IAErDnB,YAAY,CAAEsD,IAAI,IAAK,CAAC,GAAGA,IAAI,EAAE0D,YAAY,CAAC,CAAC;IAC/ClH,YAAY,CAAEwD,IAAI,IAAKA,IAAI,CAAC4D,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IAEzCxI,QAAQ,CAACuI,aAAa,CAACxI,KAAK,CAAC;IAC7BI,QAAQ,CAACoI,aAAa,CAACrI,KAAK,CAAC;IAE7BJ,KAAK,CAAC;MACJsC,KAAK,EAAE,MAAM;MACbC,WAAW,EAAE;IACf,CAAC,CAAC;EACJ,CAAC,EAAE,CAAClB,SAAS,EAAEE,SAAS,EAAEtB,KAAK,EAAEG,KAAK,EAAEF,QAAQ,EAAEG,QAAQ,EAAEL,KAAK,CAAC,CAAC;EAEnE,MAAM2I,UAAU,GAAGxL,WAAW,CAAC,MAAM;IACnC,IAAIoE,SAAS,CAACoB,MAAM,KAAK,CAAC,EAAE;IAE5B,MAAM6F,YAAY,GAAG;MAAEvI,KAAK,EAAE,CAAC,GAAGA,KAAK,CAAC;MAAEG,KAAK,EAAE,CAAC,GAAGA,KAAK;IAAE,CAAC;IAC7D,MAAMwI,SAAS,GAAGrH,SAAS,CAACA,SAAS,CAACoB,MAAM,GAAG,CAAC,CAAC;IAEjDrB,YAAY,CAAEwD,IAAI,IAAK,CAAC,GAAGA,IAAI,EAAE0D,YAAY,CAAC,CAAC;IAC/ChH,YAAY,CAAEsD,IAAI,IAAKA,IAAI,CAAC4D,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IAEzCxI,QAAQ,CAAC0I,SAAS,CAAC3I,KAAK,CAAC;IACzBI,QAAQ,CAACuI,SAAS,CAACxI,KAAK,CAAC;IAEzBJ,KAAK,CAAC;MACJsC,KAAK,EAAE,MAAM;MACbC,WAAW,EAAE;IACf,CAAC,CAAC;EACJ,CAAC,EAAE,CAAClB,SAAS,EAAEE,SAAS,EAAEtB,KAAK,EAAEG,KAAK,EAAEF,QAAQ,EAAEG,QAAQ,EAAEL,KAAK,CAAC,CAAC;;EAEnE;EACA,MAAM6I,cAAc,GAAG1L,WAAW,CAAC,MAAM;IACvC,IAAIyC,SAAS,EAAE;MACbiF,gBAAgB,CAAC,CAAC;IACpB;EACF,CAAC,EAAE,CAACjF,SAAS,EAAEiF,gBAAgB,CAAC,CAAC;;EAEjC;EACA,MAAMiE,aAAa,GAAG3L,WAAW,CAAC,MAAM;IACtC,IAAIsD,gBAAgB,KAAK,KAAK,EAAE;MAC9B,OAAOR,KAAK;IACd;IACA,OAAOA,KAAK,CAAC2D,MAAM,CAChBxB,IAAI;MAAA,IAAA2G,mBAAA;MAAA,OACH,EAAAA,mBAAA,GAAA3G,IAAI,CAACC,IAAI,CAAC2G,QAAQ,cAAAD,mBAAA,uBAAlBA,mBAAA,CAAoBE,WAAW,CAAC,CAAC,MAAKxI,gBAAgB,CAACwI,WAAW,CAAC,CAAC;IAAA,CACxE,CAAC;EACH,CAAC,EAAE,CAAChJ,KAAK,EAAEQ,gBAAgB,CAAC,CAAC;EAE7B,MAAMyI,iBAAiB,GAAG/L,WAAW,CAClCgM,MAAM,IAAK;IACV;IACA,IAAI5I,YAAY,EAAE;MAChB8H,qBAAqB,CAAC9H,YAAY,CAACd,EAAE,EAAE0J,MAAM,CAACC,SAAS,CAAC;IAC1D;;IAEA;IACA;EACF,CAAC,EACD,CAAC7I,YAAY,EAAE8H,qBAAqB,CACtC,CAAC;EAED,MAAMgB,0BAA0B,GAAGlM,WAAW,CAAE8F,IAAI,IAAK;IACvDjC,iBAAiB,CAACiC,IAAI,CAAC;EACzB,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA7F,SAAS,CAAC,MAAM;IACd;IACA,IAAIkM,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC,MAAMC,aAAa,GAAG5G,OAAO,CAACwD,KAAK;MACnCxD,OAAO,CAACwD,KAAK,GAAG,CAAC,GAAGqD,IAAI,KAAK;QAAA,IAAAC,MAAA,EAAAC,eAAA,EAAAC,OAAA,EAAAC,eAAA,EAAAC,qBAAA;QAC3B,IACE,CAAAJ,MAAA,GAAAD,IAAI,CAAC,CAAC,CAAC,cAAAC,MAAA,gBAAAC,eAAA,GAAPD,MAAA,CAASK,QAAQ,cAAAJ,eAAA,eAAjBA,eAAA,CAAAK,IAAA,CAAAN,MAAA,EAAoB,qBAAqB,CAAC,KAAAE,OAAA,GAC1CH,IAAI,CAAC,CAAC,CAAC,cAAAG,OAAA,gBAAAC,eAAA,GAAPD,OAAA,CAASK,OAAO,cAAAJ,eAAA,gBAAAC,qBAAA,GAAhBD,eAAA,CAAkBE,QAAQ,cAAAD,qBAAA,eAA1BA,qBAAA,CAAAE,IAAA,CAAAH,eAAA,EAA6B,qBAAqB,CAAC,EACnD;UACA;UACA;QACF;QACAL,aAAa,CAACU,KAAK,CAACtH,OAAO,EAAE6G,IAAI,CAAC;MACpC,CAAC;MAED,OAAO,MAAM;QACX7G,OAAO,CAACwD,KAAK,GAAGoD,aAAa;MAC/B,CAAC;IACH;EACF,CAAC,EAAE,EAAE,CAAC;;EAEN;EACArM,SAAS,CAAC,MAAM;IACd,IAAI,CAACqE,cAAc,CAACmB,OAAO,IAAI3C,KAAK,CAAC0C,MAAM,GAAG,CAAC,IAAIvB,iBAAiB,EAAE;MACpE;MACA,MAAM0C,SAAS,GAAGC,UAAU,CAAC,MAAM;QACjClB,OAAO,CAACC,GAAG,CAAC,iDAAiD,CAAC;QAC9D1B,iBAAiB,CAAC6G,OAAO,CAAC;UACxBC,OAAO,EAAE,GAAG;UACZkC,kBAAkB,EAAE,IAAI;UACxBC,OAAO,EAAE,GAAG;UACZC,OAAO,EAAE;QACX,CAAC,CAAC;MACJ,CAAC,EAAE,GAAG,CAAC;MAEP,OAAO,MAAMhG,YAAY,CAACR,SAAS,CAAC;IACtC;EACF,CAAC,EAAE,CAAC7D,KAAK,CAAC0C,MAAM,EAAEvB,iBAAiB,CAAC,CAAC;;EAErC;EACAhE,SAAS,CAAC,MAAM;IACd,IAAI6C,KAAK,CAAC0C,MAAM,GAAG,CAAC,EAAE;MACpBE,OAAO,CAACC,GAAG,CAAC,sCAAsC,EAAE7C,KAAK,CAAC0C,MAAM,CAAC;IACnE;EACF,CAAC,EAAE,CAAC1C,KAAK,CAAC,CAAC;EAEX,oBACEZ,OAAA;IAAKkL,GAAG,EAAEpJ,gBAAiB;IAACqJ,SAAS,EAAC,eAAe;IAAAC,QAAA,GAClD7K,SAAS,IAAIqB,eAAe,iBAC3B5B,OAAA,CAACxB,KAAK;MAACqF,QAAQ,EAAC,OAAO;MAACsH,SAAS,EAAC,WAAW;MAAAC,QAAA,eAC3CpL,OAAA,CAACF,kBAAkB;QACjBuL,aAAa,EAAExB,iBAAkB;QACjCyB,sBAAsB,EAAEtB,0BAA2B;QACnDuB,eAAe,EAAE7J,cAAe;QAChCF,QAAQ,EAAEA,QAAS;QACnBgK,gBAAgB,EAAGC,IAAI,IAAK;UAC1BhK,WAAW,CAACgK,IAAI,CAAC;UACjB,IAAIA,IAAI,KAAK,SAAS,EAAE;YACtB9K,KAAK,CAAC;cACJsC,KAAK,EAAE,cAAc;cACrBC,WAAW,EACT;YACJ,CAAC,CAAC;UACJ,CAAC,MAAM,IAAIuI,IAAI,KAAK,QAAQ,EAAE;YAC5B9K,KAAK,CAAC;cACJsC,KAAK,EAAE,aAAa;cACpBC,WAAW,EAAE;YACf,CAAC,CAAC;UACJ;QACF,CAAE;QACFwI,cAAc,EAAEA,CAAA,KAAMnK,kBAAkB,CAAC,IAAI;MAAE;QAAAoK,QAAA,EAAAjO,YAAA;QAAAkO,UAAA;QAAAC,YAAA;MAAA,OAChD;IAAC;MAAAF,QAAA,EAAAjO,YAAA;MAAAkO,UAAA;MAAAC,YAAA;IAAA,OACG,CACR,EAEAtL,SAAS,iBACRP,OAAA,CAACxB,KAAK;MACJqF,QAAQ,EAAC,WAAW;MACpBsH,SAAS,EAAC,6FAA6F;MAAAC,QAAA,eAEvGpL,OAAA;QAAKmL,SAAS,EAAC,wBAAwB;QAAAC,QAAA,gBACrCpL,OAAA,CAAChB,MAAM;UACLoG,IAAI,EAAC,IAAI;UACT+F,SAAS,EAAC,wFAAwF;UAClGW,OAAO,EAAE5C,UAAW;UACpB6C,QAAQ,EAAE/J,SAAS,CAACsB,MAAM,KAAK,CAAE;UAAA8H,QAAA,EAClC;QAED;UAAAO,QAAA,EAAAjO,YAAA;UAAAkO,UAAA;UAAAC,YAAA;QAAA,OAAQ,CAAC,eACT7L,OAAA,CAAChB,MAAM;UACLoG,IAAI,EAAC,IAAI;UACT+F,SAAS,EAAC,wFAAwF;UAClGW,OAAO,EAAExC,UAAW;UACpByC,QAAQ,EAAE7J,SAAS,CAACoB,MAAM,KAAK,CAAE;UAAA8H,QAAA,EAClC;QAED;UAAAO,QAAA,EAAAjO,YAAA;UAAAkO,UAAA;UAAAC,YAAA;QAAA,OAAQ,CAAC,eACT7L,OAAA,CAAChB,MAAM;UACLmM,SAAS,EAAC,8CAA8C;UACxD/F,IAAI,EAAC,IAAI;UACT0G,OAAO,EAAEjF,iBAAkB;UAAAuE,QAAA,gBAE3BpL,OAAA,CAACb,IAAI;YAACgM,SAAS,EAAC;UAAc;YAAAQ,QAAA,EAAAjO,YAAA;YAAAkO,UAAA;YAAAC,YAAA;UAAA,OAAE,CAAC,SACnC;QAAA;UAAAF,QAAA,EAAAjO,YAAA;UAAAkO,UAAA;UAAAC,YAAA;QAAA,OAAQ,CAAC;MAAA;QAAAF,QAAA,EAAAjO,YAAA;QAAAkO,UAAA;QAAAC,YAAA;MAAA,OACN;IAAC;MAAAF,QAAA,EAAAjO,YAAA;MAAAkO,UAAA;MAAAC,YAAA;IAAA,OACD,CACR,eAED7L,OAAA;MAAKmL,SAAS,EAAC,QAAQ;MAAAC,QAAA,eACrBpL,OAAA,CAAC/B,SAAS;QAER2C,KAAK,EAAE6I,aAAa,CAAC,CAAE;QACvB1I,KAAK,EAAEA,KAAM;QACbD,aAAa,EAAEP,SAAS,GAAGO,aAAa,GAAGkL,SAAU;QACrD/K,aAAa,EAAEV,SAAS,GAAGU,aAAa,GAAG+K,SAAU;QACrDtG,SAAS,EAAEnF,SAAS,GAAGmF,SAAS,GAAGsG,SAAU;QAC7C1F,WAAW,EAAEA,WAAY;QACzB2C,WAAW,EAAEA,WAAY;QACzBrC,WAAW,EAAEA,WAAY;QACzB3G,SAAS,EAAEA,SAAU;QACrBuJ,cAAc,EAAEA,cAAe;QAC/ByC,cAAc,EAAE1L,SAAU;QAC1B2L,gBAAgB,EAAE3L,SAAS,IAAIiB,QAAQ,KAAK,SAAU;QACtD2K,kBAAkB,EAAE,CAAC3L,QAAS;QAC9B4L,kBAAkB,EAAE;UAClBxI,IAAI,EAAE,YAAY;UAClBkB,KAAK,EAAE;YAAEiB,MAAM,EAAE;UAAU,CAAC;UAC5BD,QAAQ,EAAE,IAAI;UACd,IAAIpE,cAAc,KAAK,OAAO,IAAI;YAChCsE,SAAS,EAAE;cACTpC,IAAI,EAAEjF,UAAU,CAACsH,WAAW;cAC5BC,KAAK,EAAE,EAAE;cACTC,MAAM,EAAE,EAAE;cACVC,KAAK,EAAE;YACT;UACF,CAAC,CAAC;UACFpD,IAAI,EAAE;YACJtB;UACF;QACF,CAAE;QACFkH,OAAO;QACPyD,cAAc,EAAE;UACdxD,OAAO,EAAE,GAAG;UACZkC,kBAAkB,EAAE,IAAI;UACxBC,OAAO,EAAE,GAAG;UACZC,OAAO,EAAE;QACX,CAAE;QACFD,OAAO,EAAE,GAAI;QACbC,OAAO,EAAE,CAAE;QACXqB,UAAU,EAAE,IAAK;QACjBC,QAAQ,EAAE,CAAC,EAAE,EAAE,EAAE,CAAE;QACnBC,UAAU,EAAE,CACV,CAAC,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,EACd,CAAC,IAAI,EAAE,IAAI,CAAC,CACZ;QACFC,UAAU,EAAE;UAAEC,eAAe,EAAE;QAAK,CAAE;QACtCC,mBAAmB,EAAE,IAAK;QAC1BC,iBAAiB,EAAE,KAAM;QACzBC,oBAAoB,EAAE,KAAM;QAC5BC,MAAM,EAAGC,QAAQ,IAAK;UACpB;UACArI,UAAU,CAAC,MAAM;YACf,IAAI9D,KAAK,CAAC0C,MAAM,GAAG,CAAC,EAAE;cACpByJ,QAAQ,CAACnE,OAAO,CAAC;gBAAEC,OAAO,EAAE;cAAI,CAAC,CAAC;cAClCrF,OAAO,CAACC,GAAG,CACT,qCAAqC,EACrC7C,KAAK,CAAC0C,MACR,CAAC;YACH;UACF,CAAC,EAAE,GAAG,CAAC;QACT,CAAE;QAAA8H,QAAA,gBAEFpL,OAAA,CAAC7B,QAAQ;UAAAwN,QAAA,EAAAjO,YAAA;UAAAkO,UAAA;UAAAC,YAAA;QAAA,OAAE,CAAC,eACZ7L,OAAA,CAAC9B,OAAO;UAAC8O,eAAe,EAAE,CAAE;UAACC,QAAQ;UAACC,QAAQ;QAAA;UAAAvB,QAAA,EAAAjO,YAAA;UAAAkO,UAAA;UAAAC,YAAA;QAAA,OAAE,CAAC,eACjD7L,OAAA,CAAC5B,UAAU;UAACmJ,OAAO,EAAC,MAAM;UAAC4F,GAAG,EAAE,EAAG;UAAC/H,IAAI,EAAE,CAAE;UAACgB,KAAK,EAAC;QAAS;UAAAuF,QAAA,EAAAjO,YAAA;UAAAkO,UAAA;UAAAC,YAAA;QAAA,OAAE,CAAC;MAAA,GAhE1D,QAAQzL,EAAE,IAAIQ,KAAK,CAAC0C,MAAM,EAAE;QAAAqI,QAAA,EAAAjO,YAAA;QAAAkO,UAAA;QAAAC,YAAA;MAAA,OAiExB;IAAC;MAAAF,QAAA,EAAAjO,YAAA;MAAAkO,UAAA;MAAAC,YAAA;IAAA,OACT,CAAC,EAEL3K,YAAY,iBACXlB,OAAA,CAACJ,eAAe;MACdmD,IAAI,EAAE7B,YAAa;MACnBkM,OAAO,EAAEA,CAAA,KAAMjM,eAAe,CAAC,IAAI,CAAE;MACrCkM,gBAAgB,EAAE/K,oBAAqB;MACvCgL,QAAQ,EAAE/M,SAAS,GAAGwI,gBAAgB,GAAGiD,SAAU;MACnDuB,aAAa,EAAEvE,qBAAsB;MACrCwE,OAAO,EAAEjN,SAAU;MACnBC,QAAQ,EAAEA;IAAS;MAAAmL,QAAA,EAAAjO,YAAA;MAAAkO,UAAA;MAAAC,YAAA;IAAA,OACpB,CACF,EAEAvK,eAAe,iBACdtB,OAAA,CAACH,eAAe;MACd4N,IAAI,EAAEnM,eAAgB;MACtB8L,OAAO,EAAEA,CAAA,KAAM7L,kBAAkB,CAAC,KAAK,CAAE;MACzCmM,KAAK,EAAElG;IAAgB;MAAAmE,QAAA,EAAAjO,YAAA;MAAAkO,UAAA;MAAAC,YAAA;IAAA,OACxB,CACF;EAAA;IAAAF,QAAA,EAAAjO,YAAA;IAAAkO,UAAA;IAAAC,YAAA;EAAA,OACE,CAAC;AAEV;AAAClO,EAAA,CA93BQwC,gBAAgB;EAAA,QASLlB,QAAQ,EACeZ,aAAa,EACbC,aAAa,EAQ5BI,YAAY;AAAA;AAAAiP,EAAA,GAnB/BxN,gBAAgB;AAg4BzB,eAAe,SAASyN,WAAWA,CAACC,KAAK,EAAE;EAAA,IAAAC,mBAAA,EAAAC,mBAAA;EACzCvK,OAAO,CAACC,GAAG,CAAC,kDAAkD,EAAE;IAC9DrD,EAAE,EAAEyN,KAAK,CAACzN,EAAE;IACZ4N,UAAU,GAAAF,mBAAA,GAAED,KAAK,CAACxN,YAAY,cAAAyN,mBAAA,uBAAlBA,mBAAA,CAAoBxK,MAAM;IACtC2K,UAAU,GAAAF,mBAAA,GAAEF,KAAK,CAACvN,YAAY,cAAAyN,mBAAA,uBAAlBA,mBAAA,CAAoBzK;EAClC,CAAC,CAAC;EAEF,oBACEtD,OAAA,CAACvB,iBAAiB;IAAA2M,QAAA,eAChBpL,OAAA;MAAKmL,SAAS,EAAC,eAAe;MAAAC,QAAA,eAC5BpL,OAAA,CAACG,gBAAgB;QAAA,GAAK0N;MAAK;QAAAlC,QAAA,EAAAjO,YAAA;QAAAkO,UAAA;QAAAC,YAAA;MAAA,OAAG;IAAC;MAAAF,QAAA,EAAAjO,YAAA;MAAAkO,UAAA;MAAAC,YAAA;IAAA,OAC5B;EAAC;IAAAF,QAAA,EAAAjO,YAAA;IAAAkO,UAAA;IAAAC,YAAA;EAAA,OACW,CAAC;AAExB;AAACqC,GAAA,GAduBN,WAAW;AAAA,IAAAD,EAAA,EAAAO,GAAA;AAAAC,YAAA,CAAAR,EAAA;AAAAQ,YAAA,CAAAD,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}