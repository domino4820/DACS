{"ast":null,"code":"import _objectWithoutProperties from\"D:/CyberPath/it-roadmap/client/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";import _objectSpread from\"D:/CyberPath/it-roadmap/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";const _excluded=[\"nodes\",\"edges\"];import api from\"./api\";// Get roadmap data for a course (nodes and edges)\nexport const getCourseRoadmap=async courseId=>{try{console.log(\"Fetching roadmap data for course \".concat(courseId));// Get the course data to find associated roadmap\nconst courseResponse=await api.get(\"/courses/\".concat(courseId));const courseData=courseResponse.data;// Check if this course has an associated roadmap\nlet roadmapId=courseData.roadmapId;let roadmapData=null;// If no roadmap associated, create one for this course\nif(!roadmapId){console.log(\"Course \".concat(courseId,\" has no associated roadmap, creating one\"));try{// Create a new roadmap for this course\nconst createResponse=await api.post(\"/roadmaps\",{title:\"Roadmap for \".concat(courseData.title),description:\"Learning roadmap for course: \".concat(courseData.title),categoryId:courseData.categoryId,skillId:courseData.skillId,userId:courseData.userId||1// Default to user 1 if not specified\n});roadmapId=createResponse.data.id;// Associate the roadmap with the course\nawait api.put(\"/courses/\".concat(courseId),{roadmapId:roadmapId});console.log(\"Created and associated new roadmap ID: \".concat(roadmapId));// Initialize with empty roadmap\nroadmapData=_objectSpread(_objectSpread({},createResponse.data),{},{nodes:[],edges:[]});}catch(error){console.error(\"Error creating new roadmap:\",error);throw new Error(\"Could not create a roadmap for this course\");}}else{// Fetch the existing roadmap with its nodes and edges\nconsole.log(\"Course has roadmap ID: \".concat(roadmapId,\", fetching data directly\"));try{// Get complete roadmap data\nconst roadmapResponse=await api.get(\"/roadmaps/\".concat(roadmapId));const baseRoadmap=roadmapResponse.data;// Get nodes\nconst nodesResponse=await api.get(\"/roadmaps/\".concat(roadmapId,\"/nodes\"));const nodes=nodesResponse.data&&Array.isArray(nodesResponse.data)?transformNodesToClientFormat(nodesResponse.data):[];// Get edges\nconst edgesResponse=await api.get(\"/roadmaps/\".concat(roadmapId,\"/edges\"));const edges=edgesResponse.data&&Array.isArray(edgesResponse.data)?transformEdgesToClientFormat(edgesResponse.data):[];console.log(\"Got \".concat(nodes.length,\" nodes and \").concat(edges.length,\" edges from roadmap \").concat(roadmapId));// Combine roadmap data\nroadmapData=_objectSpread(_objectSpread({},baseRoadmap),{},{nodes,edges});}catch(error){console.error(\"Error fetching roadmap \".concat(roadmapId,\" data:\"),error);throw new Error(\"Failed to fetch roadmap \".concat(roadmapId));}}// Return combined data with course info\nreturn _objectSpread(_objectSpread({},courseData),{},{roadmap:roadmapData,nodes:roadmapData.nodes,edges:roadmapData.edges});}catch(error){console.error(\"Error fetching roadmap for course \".concat(courseId,\":\"),error);throw error;}};// Save roadmap data directly to roadmap entity\nexport const saveCourseRoadmap=async(courseId,roadmapData)=>{try{console.log(\"Saving roadmap data for course \".concat(courseId));if(!courseId||isNaN(Number(courseId))){throw new Error(\"Invalid course ID: \".concat(courseId));}const numericCourseId=Number(courseId);const{nodes=[],edges=[]}=roadmapData;console.log(\"Nodes to save:\",nodes.length);console.log(\"Edges to save:\",edges.length);// Validate nodes and edges\nif(!Array.isArray(nodes)){throw new Error(\"Nodes must be an array\");}if(!Array.isArray(edges)){throw new Error(\"Edges must be an array\");}// Step 1: Get or create a roadmap for this course\nconsole.log(\"Step 1: Getting/creating roadmap for course \".concat(numericCourseId));let roadmapId;// First check if course has a roadmap\nconst courseResponse=await api.get(\"/courses/\".concat(numericCourseId));const courseData=courseResponse.data;if(courseData.roadmapId){roadmapId=courseData.roadmapId;console.log(\"Using existing roadmap ID: \".concat(roadmapId));}else{// Create new roadmap if course doesn't have one\nconst createResponse=await api.post(\"/roadmaps\",{title:\"Roadmap for \".concat(courseData.title),description:\"Learning roadmap for course: \".concat(courseData.title),categoryId:courseData.categoryId,skillId:courseData.skillId,userId:courseData.userId||1// Default to user 1 if not specified\n});roadmapId=createResponse.data.id;// Associate roadmap with course\nawait api.put(\"/courses/\".concat(numericCourseId),{roadmapId:roadmapId});console.log(\"Created and associated new roadmap ID: \".concat(roadmapId));}// Step 2: Transform nodes and edges to server format\nconsole.log(\"Step 2: Transforming nodes and edges for roadmap \".concat(roadmapId));// Ensure each node has required properties\nconst processedNodes=nodes.map(node=>{if(!node.id){node.id=\"node_\".concat(Date.now(),\"_\").concat(Math.random().toString(36).substring(2,9));}return node;});// Ensure each edge has required properties\nconst processedEdges=edges.map(edge=>{if(!edge.id){edge.id=\"edge_\".concat(Date.now(),\"_\").concat(Math.random().toString(36).substring(2,9));}return edge;});const transformedNodes=transformNodesToServerFormat(processedNodes);const transformedEdges=transformEdgesToServerFormat(processedEdges);console.log(\"Transformed \".concat(transformedNodes.length,\" nodes and \").concat(transformedEdges.length,\" edges\"));// Perform a deep validation to ensure no malformed data\nconst validNodes=transformedNodes.filter(node=>{if(!node.nodeIdentifier){console.warn(\"Skipping node without identifier\");return false;}return true;});const validEdges=transformedEdges.filter(edge=>{if(!edge.edgeIdentifier||!edge.source||!edge.target){console.warn(\"Skipping edge with missing properties:\",edge);return false;}return true;});// Step 3: Save nodes to the roadmap\nconsole.log(\"Step 3: Saving \".concat(validNodes.length,\" nodes and \").concat(validEdges.length,\" edges to roadmap \").concat(roadmapId));try{// Method 1: Save both nodes and edges at once using updateNodesAndEdges\nconsole.log(\"Attempting to save nodes and edges in one request\");const response=await api.put(\"/roadmaps/\".concat(roadmapId,\"/nodes-edges\"),{nodes:validNodes,edges:validEdges});console.log(\"Nodes and edges saved successfully in one request\");console.log(\"Server response:\",response.status);// Return updated data\nreturn await getRoadmapById(roadmapId);}catch(error){console.error(\"Combined update failed:\",error);// Method 2: If direct update fails, fall back to separate endpoints\nconsole.warn(\"Trying individual updates as fallback\");try{// Save nodes\nconsole.log(\"Saving \".concat(validNodes.length,\" nodes separately\"));await api.put(\"/roadmaps/\".concat(roadmapId,\"/nodes\"),{nodes:validNodes});console.log(\"Nodes saved successfully\");}catch(nodeError){var _nodeError$response,_nodeError$response$d;console.error(\"Error saving nodes:\",nodeError);throw new Error(\"Failed to save nodes: \".concat(((_nodeError$response=nodeError.response)===null||_nodeError$response===void 0?void 0:(_nodeError$response$d=_nodeError$response.data)===null||_nodeError$response$d===void 0?void 0:_nodeError$response$d.message)||nodeError.message));}try{// Save edges\nconsole.log(\"Saving \".concat(validEdges.length,\" edges separately\"));await api.put(\"/roadmaps/\".concat(roadmapId,\"/edges\"),{edges:validEdges});console.log(\"Edges saved successfully\");}catch(edgeError){var _edgeError$response,_edgeError$response$d;console.error(\"Error saving edges:\",edgeError);throw new Error(\"Failed to save edges: \".concat(((_edgeError$response=edgeError.response)===null||_edgeError$response===void 0?void 0:(_edgeError$response$d=_edgeError$response.data)===null||_edgeError$response$d===void 0?void 0:_edgeError$response$d.message)||edgeError.message));}// Return updated data\nreturn await getRoadmapById(roadmapId);}}catch(error){console.error(\"Error saving roadmap for course \".concat(courseId,\":\"),error);throw error;}};// Get roadmap by ID directly (not through a course)\nexport const getRoadmapById=async roadmapId=>{try{console.log(\"Fetching roadmap data for ID \".concat(roadmapId));// Get the base roadmap data\nconst roadmapResponse=await api.get(\"/roadmaps/\".concat(roadmapId));const baseRoadmap=roadmapResponse.data;// Get nodes\nconst nodesResponse=await api.get(\"/roadmaps/\".concat(roadmapId,\"/nodes\"));const nodes=nodesResponse.data&&Array.isArray(nodesResponse.data)?transformNodesToClientFormat(nodesResponse.data):[];// Get edges\nconst edgesResponse=await api.get(\"/roadmaps/\".concat(roadmapId,\"/edges\"));const edges=edgesResponse.data&&Array.isArray(edgesResponse.data)?transformEdgesToClientFormat(edgesResponse.data):[];console.log(\"Got \".concat(nodes.length,\" nodes and \").concat(edges.length,\" edges from roadmap \").concat(roadmapId));// Return combined data\nreturn _objectSpread(_objectSpread({},baseRoadmap),{},{nodes,edges});}catch(error){console.error(\"Error fetching roadmap \".concat(roadmapId,\":\"),error);throw error;}};// Create a new course with roadmap data\nexport const createCourseWithRoadmap=async courseData=>{try{console.log(\"Creating new course with roadmap data\");const{nodes,edges}=courseData,courseDetails=_objectWithoutProperties(courseData,_excluded);// Create the course first\nconst courseResponse=await api.post(\"/courses\",courseDetails);const newCourse=courseResponse.data;const courseId=newCourse.id;// Then create and save roadmap if nodes/edges provided\nif(nodes&&nodes.length>0||edges&&edges.length>0){await saveCourseRoadmap(courseId,{nodes,edges});}// Return the full course with roadmap data\nreturn await getCourseRoadmap(courseId);}catch(error){console.error(\"Error creating course with roadmap:\",error);throw error;}};// Transform nodes from server format to client format\nexport const transformNodesToClientFormat=nodes=>{return nodes.map(node=>{try{// If node already has client format, return as is\nif(node.type&&node.position&&node.data){return node;}// Parse the data if it's a string\nlet nodeData=node.data;if(typeof node.data===\"string\"){try{nodeData=JSON.parse(node.data);}catch(e){nodeData={label:node.data};}}return{id:node.nodeIdentifier,type:\"courseNode\",// Default node type\nposition:{x:node.positionX||0,y:node.positionY||0},data:_objectSpread(_objectSpread({},nodeData),{},{id:node.nodeIdentifier})};}catch(error){console.error(\"Error transforming node to client format:\",error,node);return null;}}).filter(Boolean);};// Transform nodes from client format to server format\nexport const transformNodesToServerFormat=nodes=>{if(!Array.isArray(nodes)){console.error(\"Nodes is not an array:\",nodes);return[];}return nodes.map(node=>{try{var _node$position,_node$position2;if(!node){console.warn(\"Null or undefined node found\");return null;}if(!node.id){console.warn(\"Node missing ID:\",node);return null;}// Make sure position exists and has valid x, y values\nconst posX=parseFloat((_node$position=node.position)===null||_node$position===void 0?void 0:_node$position.x)||0;const posY=parseFloat((_node$position2=node.position)===null||_node$position2===void 0?void 0:_node$position2.y)||0;// Process data object\nlet processedData;if(typeof node.data===\"object\"&&node.data!==null){// Make a clean copy without circular references\nconst safeData=_objectSpread(_objectSpread({},node.data||{}),{},{label:node.data.label||node.id});// Remove any potentially problematic properties\ndelete safeData.events;delete safeData.__proto__;delete safeData.constructor;processedData=safeData;}else if(typeof node.data===\"string\"){try{// Try to parse if it's a JSON string\nprocessedData=JSON.parse(node.data);}catch(e){// If not valid JSON, use as label\nprocessedData={label:node.data};}}else{// Default data\nprocessedData={label:node.id};}// Return in the format expected by the server\nreturn{nodeIdentifier:node.id,positionX:posX,positionY:posY,data:JSON.stringify(processedData),courseId:processedData.courseId||node.courseId||null,roadmapId:node.roadmapId||null};}catch(error){console.error(\"Error transforming node to server format:\",error,node);return null;}}).filter(Boolean);};// Transform edges from server format to client format\nexport const transformEdgesToClientFormat=edges=>{return edges.map(edge=>{try{// If edge already has client format, return as is\nif(edge.source&&edge.target&&edge.id){return edge;}// Parse the style if it's a string\nlet edgeStyle={};if(typeof edge.style===\"string\"){try{edgeStyle=JSON.parse(edge.style);}catch(e){edgeStyle={};}}else if(typeof edge.style===\"object\"){edgeStyle=edge.style;}return{id:edge.edgeIdentifier,source:edge.source,target:edge.target,type:edge.type||\"smoothstep\",animated:edge.animated||false,style:edgeStyle};}catch(error){console.error(\"Error transforming edge to client format:\",error,edge);return null;}}).filter(Boolean);};// Transform edges from client format to server format\nexport const transformEdgesToServerFormat=edges=>{if(!Array.isArray(edges)){console.error(\"Edges is not an array:\",edges);return[];}return edges.map(edge=>{try{if(!edge){console.warn(\"Null or undefined edge found\");return null;}if(!edge.id||!edge.source||!edge.target){console.warn(\"Edge missing required properties:\",edge);return null;}// Handle edge style\nlet styleString;if(typeof edge.style===\"object\"&&edge.style!==null){try{// Make a clean copy to avoid circular references\nconst safeStyle=_objectSpread({},edge.style);styleString=JSON.stringify(safeStyle);}catch(styleError){console.warn(\"Could not stringify edge style:\",styleError);styleString=\"{}\";}}else if(typeof edge.style===\"string\"){styleString=edge.style;}else{styleString=\"{}\";}// Return in the format expected by the server\nreturn{edgeIdentifier:edge.id,source:edge.source,target:edge.target,type:edge.type||\"smoothstep\",animated:edge.animated||false,style:styleString,roadmapId:edge.roadmapId||null};}catch(error){console.error(\"Error transforming edge to server format:\",error,edge);return null;}}).filter(Boolean);};export default{getCourseRoadmap,saveCourseRoadmap,getRoadmapById,createCourseWithRoadmap,transformNodesToClientFormat,transformNodesToServerFormat,transformEdgesToClientFormat,transformEdgesToServerFormat};","map":{"version":3,"names":["api","getCourseRoadmap","courseId","console","log","concat","courseResponse","get","courseData","data","roadmapId","roadmapData","createResponse","post","title","description","categoryId","skillId","userId","id","put","_objectSpread","nodes","edges","error","Error","roadmapResponse","baseRoadmap","nodesResponse","Array","isArray","transformNodesToClientFormat","edgesResponse","transformEdgesToClientFormat","length","roadmap","saveCourseRoadmap","isNaN","Number","numericCourseId","processedNodes","map","node","Date","now","Math","random","toString","substring","processedEdges","edge","transformedNodes","transformNodesToServerFormat","transformedEdges","transformEdgesToServerFormat","validNodes","filter","nodeIdentifier","warn","validEdges","edgeIdentifier","source","target","response","status","getRoadmapById","nodeError","_nodeError$response","_nodeError$response$d","message","edgeError","_edgeError$response","_edgeError$response$d","createCourseWithRoadmap","courseDetails","_objectWithoutProperties","_excluded","newCourse","type","position","nodeData","JSON","parse","e","label","x","positionX","y","positionY","Boolean","_node$position","_node$position2","posX","parseFloat","posY","processedData","safeData","events","__proto__","constructor","stringify","edgeStyle","style","animated","styleString","safeStyle","styleError"],"sources":["D:/CyberPath/it-roadmap/client/src/services/courseRoadmapService.js"],"sourcesContent":["import api from \"./api\";\r\n\r\n// Get roadmap data for a course (nodes and edges)\r\nexport const getCourseRoadmap = async (courseId) => {\r\n  try {\r\n    console.log(`Fetching roadmap data for course ${courseId}`);\r\n\r\n    // Get the course data to find associated roadmap\r\n    const courseResponse = await api.get(`/courses/${courseId}`);\r\n    const courseData = courseResponse.data;\r\n\r\n    // Check if this course has an associated roadmap\r\n    let roadmapId = courseData.roadmapId;\r\n    let roadmapData = null;\r\n\r\n    // If no roadmap associated, create one for this course\r\n    if (!roadmapId) {\r\n      console.log(`Course ${courseId} has no associated roadmap, creating one`);\r\n\r\n      try {\r\n        // Create a new roadmap for this course\r\n        const createResponse = await api.post(\"/roadmaps\", {\r\n          title: `Roadmap for ${courseData.title}`,\r\n          description: `Learning roadmap for course: ${courseData.title}`,\r\n          categoryId: courseData.categoryId,\r\n          skillId: courseData.skillId,\r\n          userId: courseData.userId || 1, // Default to user 1 if not specified\r\n        });\r\n\r\n        roadmapId = createResponse.data.id;\r\n\r\n        // Associate the roadmap with the course\r\n        await api.put(`/courses/${courseId}`, {\r\n          roadmapId: roadmapId,\r\n        });\r\n\r\n        console.log(`Created and associated new roadmap ID: ${roadmapId}`);\r\n\r\n        // Initialize with empty roadmap\r\n        roadmapData = {\r\n          ...createResponse.data,\r\n          nodes: [],\r\n          edges: [],\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error creating new roadmap:\", error);\r\n        throw new Error(\"Could not create a roadmap for this course\");\r\n      }\r\n    } else {\r\n      // Fetch the existing roadmap with its nodes and edges\r\n      console.log(\r\n        `Course has roadmap ID: ${roadmapId}, fetching data directly`\r\n      );\r\n      try {\r\n        // Get complete roadmap data\r\n        const roadmapResponse = await api.get(`/roadmaps/${roadmapId}`);\r\n        const baseRoadmap = roadmapResponse.data;\r\n\r\n        // Get nodes\r\n        const nodesResponse = await api.get(`/roadmaps/${roadmapId}/nodes`);\r\n        const nodes =\r\n          nodesResponse.data && Array.isArray(nodesResponse.data)\r\n            ? transformNodesToClientFormat(nodesResponse.data)\r\n            : [];\r\n\r\n        // Get edges\r\n        const edgesResponse = await api.get(`/roadmaps/${roadmapId}/edges`);\r\n        const edges =\r\n          edgesResponse.data && Array.isArray(edgesResponse.data)\r\n            ? transformEdgesToClientFormat(edgesResponse.data)\r\n            : [];\r\n\r\n        console.log(\r\n          `Got ${nodes.length} nodes and ${edges.length} edges from roadmap ${roadmapId}`\r\n        );\r\n\r\n        // Combine roadmap data\r\n        roadmapData = {\r\n          ...baseRoadmap,\r\n          nodes,\r\n          edges,\r\n        };\r\n      } catch (error) {\r\n        console.error(`Error fetching roadmap ${roadmapId} data:`, error);\r\n        throw new Error(`Failed to fetch roadmap ${roadmapId}`);\r\n      }\r\n    }\r\n\r\n    // Return combined data with course info\r\n    return {\r\n      ...courseData,\r\n      roadmap: roadmapData,\r\n      nodes: roadmapData.nodes,\r\n      edges: roadmapData.edges,\r\n    };\r\n  } catch (error) {\r\n    console.error(`Error fetching roadmap for course ${courseId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Save roadmap data directly to roadmap entity\r\nexport const saveCourseRoadmap = async (courseId, roadmapData) => {\r\n  try {\r\n    console.log(`Saving roadmap data for course ${courseId}`);\r\n\r\n    if (!courseId || isNaN(Number(courseId))) {\r\n      throw new Error(`Invalid course ID: ${courseId}`);\r\n    }\r\n\r\n    const numericCourseId = Number(courseId);\r\n    const { nodes = [], edges = [] } = roadmapData;\r\n\r\n    console.log(\"Nodes to save:\", nodes.length);\r\n    console.log(\"Edges to save:\", edges.length);\r\n\r\n    // Validate nodes and edges\r\n    if (!Array.isArray(nodes)) {\r\n      throw new Error(\"Nodes must be an array\");\r\n    }\r\n\r\n    if (!Array.isArray(edges)) {\r\n      throw new Error(\"Edges must be an array\");\r\n    }\r\n\r\n    // Step 1: Get or create a roadmap for this course\r\n    console.log(\r\n      `Step 1: Getting/creating roadmap for course ${numericCourseId}`\r\n    );\r\n    let roadmapId;\r\n\r\n    // First check if course has a roadmap\r\n    const courseResponse = await api.get(`/courses/${numericCourseId}`);\r\n    const courseData = courseResponse.data;\r\n\r\n    if (courseData.roadmapId) {\r\n      roadmapId = courseData.roadmapId;\r\n      console.log(`Using existing roadmap ID: ${roadmapId}`);\r\n    } else {\r\n      // Create new roadmap if course doesn't have one\r\n      const createResponse = await api.post(\"/roadmaps\", {\r\n        title: `Roadmap for ${courseData.title}`,\r\n        description: `Learning roadmap for course: ${courseData.title}`,\r\n        categoryId: courseData.categoryId,\r\n        skillId: courseData.skillId,\r\n        userId: courseData.userId || 1, // Default to user 1 if not specified\r\n      });\r\n\r\n      roadmapId = createResponse.data.id;\r\n\r\n      // Associate roadmap with course\r\n      await api.put(`/courses/${numericCourseId}`, {\r\n        roadmapId: roadmapId,\r\n      });\r\n\r\n      console.log(`Created and associated new roadmap ID: ${roadmapId}`);\r\n    }\r\n\r\n    // Step 2: Transform nodes and edges to server format\r\n    console.log(\r\n      `Step 2: Transforming nodes and edges for roadmap ${roadmapId}`\r\n    );\r\n\r\n    // Ensure each node has required properties\r\n    const processedNodes = nodes.map((node) => {\r\n      if (!node.id) {\r\n        node.id = `node_${Date.now()}_${Math.random()\r\n          .toString(36)\r\n          .substring(2, 9)}`;\r\n      }\r\n      return node;\r\n    });\r\n\r\n    // Ensure each edge has required properties\r\n    const processedEdges = edges.map((edge) => {\r\n      if (!edge.id) {\r\n        edge.id = `edge_${Date.now()}_${Math.random()\r\n          .toString(36)\r\n          .substring(2, 9)}`;\r\n      }\r\n      return edge;\r\n    });\r\n\r\n    const transformedNodes = transformNodesToServerFormat(processedNodes);\r\n    const transformedEdges = transformEdgesToServerFormat(processedEdges);\r\n\r\n    console.log(\r\n      `Transformed ${transformedNodes.length} nodes and ${transformedEdges.length} edges`\r\n    );\r\n\r\n    // Perform a deep validation to ensure no malformed data\r\n    const validNodes = transformedNodes.filter((node) => {\r\n      if (!node.nodeIdentifier) {\r\n        console.warn(\"Skipping node without identifier\");\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n\r\n    const validEdges = transformedEdges.filter((edge) => {\r\n      if (!edge.edgeIdentifier || !edge.source || !edge.target) {\r\n        console.warn(\"Skipping edge with missing properties:\", edge);\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n\r\n    // Step 3: Save nodes to the roadmap\r\n    console.log(\r\n      `Step 3: Saving ${validNodes.length} nodes and ${validEdges.length} edges to roadmap ${roadmapId}`\r\n    );\r\n    try {\r\n      // Method 1: Save both nodes and edges at once using updateNodesAndEdges\r\n      console.log(\"Attempting to save nodes and edges in one request\");\r\n      const response = await api.put(`/roadmaps/${roadmapId}/nodes-edges`, {\r\n        nodes: validNodes,\r\n        edges: validEdges,\r\n      });\r\n\r\n      console.log(\"Nodes and edges saved successfully in one request\");\r\n      console.log(\"Server response:\", response.status);\r\n\r\n      // Return updated data\r\n      return await getRoadmapById(roadmapId);\r\n    } catch (error) {\r\n      console.error(\"Combined update failed:\", error);\r\n\r\n      // Method 2: If direct update fails, fall back to separate endpoints\r\n      console.warn(\"Trying individual updates as fallback\");\r\n\r\n      try {\r\n        // Save nodes\r\n        console.log(`Saving ${validNodes.length} nodes separately`);\r\n        await api.put(`/roadmaps/${roadmapId}/nodes`, {\r\n          nodes: validNodes,\r\n        });\r\n        console.log(`Nodes saved successfully`);\r\n      } catch (nodeError) {\r\n        console.error(\"Error saving nodes:\", nodeError);\r\n        throw new Error(\r\n          `Failed to save nodes: ${\r\n            nodeError.response?.data?.message || nodeError.message\r\n          }`\r\n        );\r\n      }\r\n\r\n      try {\r\n        // Save edges\r\n        console.log(`Saving ${validEdges.length} edges separately`);\r\n        await api.put(`/roadmaps/${roadmapId}/edges`, {\r\n          edges: validEdges,\r\n        });\r\n        console.log(`Edges saved successfully`);\r\n      } catch (edgeError) {\r\n        console.error(\"Error saving edges:\", edgeError);\r\n        throw new Error(\r\n          `Failed to save edges: ${\r\n            edgeError.response?.data?.message || edgeError.message\r\n          }`\r\n        );\r\n      }\r\n\r\n      // Return updated data\r\n      return await getRoadmapById(roadmapId);\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error saving roadmap for course ${courseId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Get roadmap by ID directly (not through a course)\r\nexport const getRoadmapById = async (roadmapId) => {\r\n  try {\r\n    console.log(`Fetching roadmap data for ID ${roadmapId}`);\r\n\r\n    // Get the base roadmap data\r\n    const roadmapResponse = await api.get(`/roadmaps/${roadmapId}`);\r\n    const baseRoadmap = roadmapResponse.data;\r\n\r\n    // Get nodes\r\n    const nodesResponse = await api.get(`/roadmaps/${roadmapId}/nodes`);\r\n    const nodes =\r\n      nodesResponse.data && Array.isArray(nodesResponse.data)\r\n        ? transformNodesToClientFormat(nodesResponse.data)\r\n        : [];\r\n\r\n    // Get edges\r\n    const edgesResponse = await api.get(`/roadmaps/${roadmapId}/edges`);\r\n    const edges =\r\n      edgesResponse.data && Array.isArray(edgesResponse.data)\r\n        ? transformEdgesToClientFormat(edgesResponse.data)\r\n        : [];\r\n\r\n    console.log(\r\n      `Got ${nodes.length} nodes and ${edges.length} edges from roadmap ${roadmapId}`\r\n    );\r\n\r\n    // Return combined data\r\n    return {\r\n      ...baseRoadmap,\r\n      nodes,\r\n      edges,\r\n    };\r\n  } catch (error) {\r\n    console.error(`Error fetching roadmap ${roadmapId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Create a new course with roadmap data\r\nexport const createCourseWithRoadmap = async (courseData) => {\r\n  try {\r\n    console.log(\"Creating new course with roadmap data\");\r\n    const { nodes, edges, ...courseDetails } = courseData;\r\n\r\n    // Create the course first\r\n    const courseResponse = await api.post(\"/courses\", courseDetails);\r\n    const newCourse = courseResponse.data;\r\n    const courseId = newCourse.id;\r\n\r\n    // Then create and save roadmap if nodes/edges provided\r\n    if ((nodes && nodes.length > 0) || (edges && edges.length > 0)) {\r\n      await saveCourseRoadmap(courseId, { nodes, edges });\r\n    }\r\n\r\n    // Return the full course with roadmap data\r\n    return await getCourseRoadmap(courseId);\r\n  } catch (error) {\r\n    console.error(\"Error creating course with roadmap:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Transform nodes from server format to client format\r\nexport const transformNodesToClientFormat = (nodes) => {\r\n  return nodes\r\n    .map((node) => {\r\n      try {\r\n        // If node already has client format, return as is\r\n        if (node.type && node.position && node.data) {\r\n          return node;\r\n        }\r\n\r\n        // Parse the data if it's a string\r\n        let nodeData = node.data;\r\n        if (typeof node.data === \"string\") {\r\n          try {\r\n            nodeData = JSON.parse(node.data);\r\n          } catch (e) {\r\n            nodeData = { label: node.data };\r\n          }\r\n        }\r\n\r\n        return {\r\n          id: node.nodeIdentifier,\r\n          type: \"courseNode\", // Default node type\r\n          position: {\r\n            x: node.positionX || 0,\r\n            y: node.positionY || 0,\r\n          },\r\n          data: {\r\n            ...nodeData,\r\n            id: node.nodeIdentifier,\r\n          },\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming node to client format:\", error, node);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\n// Transform nodes from client format to server format\r\nexport const transformNodesToServerFormat = (nodes) => {\r\n  if (!Array.isArray(nodes)) {\r\n    console.error(\"Nodes is not an array:\", nodes);\r\n    return [];\r\n  }\r\n\r\n  return nodes\r\n    .map((node) => {\r\n      try {\r\n        if (!node) {\r\n          console.warn(\"Null or undefined node found\");\r\n          return null;\r\n        }\r\n\r\n        if (!node.id) {\r\n          console.warn(\"Node missing ID:\", node);\r\n          return null;\r\n        }\r\n\r\n        // Make sure position exists and has valid x, y values\r\n        const posX = parseFloat(node.position?.x) || 0;\r\n        const posY = parseFloat(node.position?.y) || 0;\r\n\r\n        // Process data object\r\n        let processedData;\r\n        if (typeof node.data === \"object\" && node.data !== null) {\r\n          // Make a clean copy without circular references\r\n          const safeData = {\r\n            ...(node.data || {}),\r\n            label: node.data.label || node.id,\r\n          };\r\n\r\n          // Remove any potentially problematic properties\r\n          delete safeData.events;\r\n          delete safeData.__proto__;\r\n          delete safeData.constructor;\r\n\r\n          processedData = safeData;\r\n        } else if (typeof node.data === \"string\") {\r\n          try {\r\n            // Try to parse if it's a JSON string\r\n            processedData = JSON.parse(node.data);\r\n          } catch (e) {\r\n            // If not valid JSON, use as label\r\n            processedData = { label: node.data };\r\n          }\r\n        } else {\r\n          // Default data\r\n          processedData = { label: node.id };\r\n        }\r\n\r\n        // Return in the format expected by the server\r\n        return {\r\n          nodeIdentifier: node.id,\r\n          positionX: posX,\r\n          positionY: posY,\r\n          data: JSON.stringify(processedData),\r\n          courseId: processedData.courseId || node.courseId || null,\r\n          roadmapId: node.roadmapId || null,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming node to server format:\", error, node);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\n// Transform edges from server format to client format\r\nexport const transformEdgesToClientFormat = (edges) => {\r\n  return edges\r\n    .map((edge) => {\r\n      try {\r\n        // If edge already has client format, return as is\r\n        if (edge.source && edge.target && edge.id) {\r\n          return edge;\r\n        }\r\n\r\n        // Parse the style if it's a string\r\n        let edgeStyle = {};\r\n        if (typeof edge.style === \"string\") {\r\n          try {\r\n            edgeStyle = JSON.parse(edge.style);\r\n          } catch (e) {\r\n            edgeStyle = {};\r\n          }\r\n        } else if (typeof edge.style === \"object\") {\r\n          edgeStyle = edge.style;\r\n        }\r\n\r\n        return {\r\n          id: edge.edgeIdentifier,\r\n          source: edge.source,\r\n          target: edge.target,\r\n          type: edge.type || \"smoothstep\",\r\n          animated: edge.animated || false,\r\n          style: edgeStyle,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming edge to client format:\", error, edge);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\n// Transform edges from client format to server format\r\nexport const transformEdgesToServerFormat = (edges) => {\r\n  if (!Array.isArray(edges)) {\r\n    console.error(\"Edges is not an array:\", edges);\r\n    return [];\r\n  }\r\n\r\n  return edges\r\n    .map((edge) => {\r\n      try {\r\n        if (!edge) {\r\n          console.warn(\"Null or undefined edge found\");\r\n          return null;\r\n        }\r\n\r\n        if (!edge.id || !edge.source || !edge.target) {\r\n          console.warn(\"Edge missing required properties:\", edge);\r\n          return null;\r\n        }\r\n\r\n        // Handle edge style\r\n        let styleString;\r\n        if (typeof edge.style === \"object\" && edge.style !== null) {\r\n          try {\r\n            // Make a clean copy to avoid circular references\r\n            const safeStyle = { ...edge.style };\r\n            styleString = JSON.stringify(safeStyle);\r\n          } catch (styleError) {\r\n            console.warn(\"Could not stringify edge style:\", styleError);\r\n            styleString = \"{}\";\r\n          }\r\n        } else if (typeof edge.style === \"string\") {\r\n          styleString = edge.style;\r\n        } else {\r\n          styleString = \"{}\";\r\n        }\r\n\r\n        // Return in the format expected by the server\r\n        return {\r\n          edgeIdentifier: edge.id,\r\n          source: edge.source,\r\n          target: edge.target,\r\n          type: edge.type || \"smoothstep\",\r\n          animated: edge.animated || false,\r\n          style: styleString,\r\n          roadmapId: edge.roadmapId || null,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming edge to server format:\", error, edge);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\nexport default {\r\n  getCourseRoadmap,\r\n  saveCourseRoadmap,\r\n  getRoadmapById,\r\n  createCourseWithRoadmap,\r\n  transformNodesToClientFormat,\r\n  transformNodesToServerFormat,\r\n  transformEdgesToClientFormat,\r\n  transformEdgesToServerFormat,\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}