{"ast":null,"code":"import api from \"./api\";\n\n// Get course with full roadmap data (nodes and edges)\nexport const getCourseRoadmap = async courseId => {\n  try {\n    console.log(`Fetching roadmap data for course ${courseId}`);\n\n    // Get the course data\n    const courseResponse = await api.get(`/courses/${courseId}`);\n    const courseData = courseResponse.data;\n\n    // Check if this course has an associated roadmap\n    let roadmapId = courseData.roadmapId;\n    let nodes = [];\n    let edges = [];\n\n    // If there's a roadmap associated, get its nodes and edges\n    if (roadmapId) {\n      console.log(`Course has roadmap ID: ${roadmapId}, fetching roadmap data`);\n      try {\n        // Get the roadmap data\n        const roadmapResponse = await api.get(`/roadmaps/${roadmapId}`);\n        const roadmapData = roadmapResponse.data;\n\n        // Get nodes from the roadmap\n        const nodesResponse = await api.get(`/roadmaps/${roadmapId}/nodes`);\n        if (nodesResponse.data && Array.isArray(nodesResponse.data)) {\n          nodes = transformNodesToClientFormat(nodesResponse.data);\n        }\n\n        // Get edges from the roadmap\n        const edgesResponse = await api.get(`/roadmaps/${roadmapId}/edges`);\n        if (edgesResponse.data && Array.isArray(edgesResponse.data)) {\n          edges = transformEdgesToClientFormat(edgesResponse.data);\n        }\n        console.log(`Got ${nodes.length} nodes and ${edges.length} edges from roadmap ${roadmapId}`);\n      } catch (error) {\n        console.error(`Error fetching roadmap ${roadmapId} data:`, error);\n        // Continue with empty nodes/edges\n      }\n    } else {\n      console.log(`Course ${courseId} has no associated roadmap yet`);\n    }\n\n    // Combine all data\n    const roadmapData = {\n      ...courseData,\n      nodes,\n      edges\n    };\n    console.log(`Got roadmap data for course ${courseId}:`, roadmapData);\n    return roadmapData;\n  } catch (error) {\n    console.error(`Error fetching roadmap for course ${courseId}:`, error);\n    throw error;\n  }\n};\n\n// Save course roadmap data (nodes and edges)\nexport const saveCourseRoadmap = async (courseId, roadmapData) => {\n  try {\n    console.log(`Saving roadmap data for course ${courseId}`);\n    if (!courseId || isNaN(Number(courseId))) {\n      throw new Error(`Invalid course ID: ${courseId}`);\n    }\n    const numericCourseId = Number(courseId);\n    const {\n      nodes,\n      edges\n    } = roadmapData;\n    console.log(\"Received nodes:\", nodes);\n    console.log(\"Received edges:\", edges);\n\n    // Validate nodes and edges\n    if (!Array.isArray(nodes)) {\n      throw new Error(\"Nodes must be an array\");\n    }\n    if (!Array.isArray(edges)) {\n      throw new Error(\"Edges must be an array\");\n    }\n\n    // Step 1: Check if the course already has a roadmap\n    console.log(`Step 1: Checking if course ${numericCourseId} has a roadmap`);\n    const courseResponse = await api.get(`/courses/${numericCourseId}`);\n    const courseData = courseResponse.data;\n\n    // Step 2: Get or create a roadmap\n    let roadmapId;\n    if (courseData.roadmapId) {\n      roadmapId = courseData.roadmapId;\n      console.log(`Step 2: Using existing roadmap ID: ${roadmapId}`);\n    } else {\n      console.log(`Step 2: Creating new roadmap for course ${numericCourseId}`);\n      // Create a new roadmap for this course\n      const roadmapResponse = await api.post(\"/roadmaps\", {\n        title: `Roadmap for ${courseData.title}`,\n        description: `Learning roadmap for course: ${courseData.title}`,\n        categoryId: courseData.categoryId,\n        skillId: courseData.skillId,\n        userId: courseData.userId || 1 // Default to user 1 if not specified\n      });\n      roadmapId = roadmapResponse.data.id;\n      console.log(`Created new roadmap with ID: ${roadmapId}`);\n\n      // Associate the roadmap with the course\n      console.log(`Associating roadmap ${roadmapId} with course ${numericCourseId}`);\n      await api.put(`/courses/${numericCourseId}`, {\n        roadmapId: roadmapId\n      });\n    }\n\n    // Step 3: Transform nodes and edges\n    console.log(`Step 3: Transforming nodes and edges for roadmap ${roadmapId}`);\n    const transformedNodes = transformNodesToServerFormat(nodes).map(node => ({\n      ...node,\n      roadmapId: roadmapId\n    }));\n    const transformedEdges = transformEdgesToServerFormat(edges).map(edge => ({\n      ...edge,\n      roadmapId: roadmapId\n    }));\n    console.log(\"Transformed nodes with roadmapId:\", transformedNodes);\n    console.log(\"Transformed edges with roadmapId:\", transformedEdges);\n\n    // Step 4: Save nodes to the roadmap\n    console.log(`Step 4: Saving nodes to roadmap ${roadmapId}`);\n    if (transformedNodes.length > 0) {\n      try {\n        const nodesResponse = await api.put(`/roadmaps/${roadmapId}/nodes`, {\n          nodes: transformedNodes\n        });\n        console.log(\"Nodes saved response:\", nodesResponse.data);\n      } catch (error) {\n        var _error$response, _error$response2, _error$response2$data;\n        console.error(\"Error saving nodes:\", ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n        throw new Error(`Failed to save nodes: ${((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || error.message}`);\n      }\n    } else {\n      console.log(\"No nodes to save\");\n    }\n\n    // Step 5: Save edges to the roadmap\n    console.log(`Step 5: Saving edges to roadmap ${roadmapId}`);\n    if (transformedEdges.length > 0) {\n      try {\n        const edgesResponse = await api.put(`/roadmaps/${roadmapId}/edges`, {\n          edges: transformedEdges\n        });\n        console.log(\"Edges saved response:\", edgesResponse.data);\n      } catch (error) {\n        var _error$response3, _error$response4, _error$response4$data;\n        console.error(\"Error saving edges:\", ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.data) || error.message);\n        throw new Error(`Failed to save edges: ${((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.message) || error.message}`);\n      }\n    } else {\n      console.log(\"No edges to save\");\n    }\n    console.log(`Roadmap ${roadmapId} for course ${numericCourseId} saved successfully`);\n\n    // Step 6: Get updated data\n    return await getCourseRoadmap(numericCourseId);\n  } catch (error) {\n    console.error(`Error saving roadmap for course ${courseId}:`, error);\n    throw error;\n  }\n};\n\n// Create a new course with roadmap data\nexport const createCourseWithRoadmap = async courseData => {\n  try {\n    console.log(\"Creating new course with roadmap data\");\n    const {\n      nodes,\n      edges,\n      ...courseDetails\n    } = courseData;\n\n    // Create the course first\n    const courseResponse = await api.post(\"/courses\", courseDetails);\n    const newCourse = courseResponse.data;\n    const courseId = newCourse.id;\n\n    // Then save nodes and edges if provided\n    if (nodes && nodes.length > 0 || edges && edges.length > 0) {\n      await saveCourseRoadmap(courseId, {\n        nodes,\n        edges\n      });\n    }\n\n    // Return the full course with roadmap data\n    return await getCourseRoadmap(courseId);\n  } catch (error) {\n    console.error(\"Error creating course with roadmap:\", error);\n    throw error;\n  }\n};\n\n// Transform nodes from server format to client format\nexport const transformNodesToClientFormat = nodes => {\n  return nodes.map(node => {\n    try {\n      // If node already has client format, return as is\n      if (node.type && node.position && node.data) {\n        return node;\n      }\n\n      // Parse the data if it's a string\n      let nodeData = node.data;\n      if (typeof node.data === \"string\") {\n        try {\n          nodeData = JSON.parse(node.data);\n        } catch (e) {\n          nodeData = {\n            label: node.data\n          };\n        }\n      }\n      return {\n        id: node.nodeIdentifier,\n        type: \"courseNode\",\n        // Default node type\n        position: {\n          x: node.positionX || 0,\n          y: node.positionY || 0\n        },\n        data: {\n          ...nodeData,\n          id: node.nodeIdentifier\n        }\n      };\n    } catch (error) {\n      console.error(\"Error transforming node to client format:\", error, node);\n      return null;\n    }\n  }).filter(Boolean);\n};\n\n// Transform nodes from client format to server format\nexport const transformNodesToServerFormat = nodes => {\n  if (!Array.isArray(nodes)) {\n    console.error(\"Nodes is not an array:\", nodes);\n    return [];\n  }\n  return nodes.map(node => {\n    try {\n      var _node$position, _node$position2;\n      if (!node || !node.id) {\n        console.warn(\"Invalid node object:\", node);\n        return null;\n      }\n\n      // Make sure position exists and has valid x, y values\n      const posX = ((_node$position = node.position) === null || _node$position === void 0 ? void 0 : _node$position.x) || 0;\n      const posY = ((_node$position2 = node.position) === null || _node$position2 === void 0 ? void 0 : _node$position2.y) || 0;\n\n      // Make a copy of data to avoid mutating the original\n      const nodeData = {\n        ...(node.data || {})\n      };\n\n      // Return in the format expected by the server\n      return {\n        nodeIdentifier: node.id,\n        positionX: posX,\n        positionY: posY,\n        data: JSON.stringify(nodeData),\n        courseId: nodeData.courseId || null\n      };\n    } catch (error) {\n      console.error(\"Error transforming node to server format:\", error, node);\n      return null;\n    }\n  }).filter(Boolean);\n};\n\n// Transform edges from server format to client format\nexport const transformEdgesToClientFormat = edges => {\n  return edges.map(edge => {\n    try {\n      // If edge already has client format, return as is\n      if (edge.source && edge.target && edge.id) {\n        return edge;\n      }\n\n      // Parse the style if it's a string\n      let edgeStyle = {};\n      if (typeof edge.style === \"string\") {\n        try {\n          edgeStyle = JSON.parse(edge.style);\n        } catch (e) {\n          edgeStyle = {};\n        }\n      } else if (typeof edge.style === \"object\") {\n        edgeStyle = edge.style;\n      }\n      return {\n        id: edge.edgeIdentifier,\n        source: edge.source,\n        target: edge.target,\n        type: edge.type || \"smoothstep\",\n        animated: edge.animated || false,\n        style: edgeStyle\n      };\n    } catch (error) {\n      console.error(\"Error transforming edge to client format:\", error, edge);\n      return null;\n    }\n  }).filter(Boolean);\n};\n\n// Transform edges from client format to server format\nexport const transformEdgesToServerFormat = edges => {\n  if (!Array.isArray(edges)) {\n    console.error(\"Edges is not an array:\", edges);\n    return [];\n  }\n  return edges.map(edge => {\n    try {\n      if (!edge || !edge.id || !edge.source || !edge.target) {\n        console.warn(\"Invalid edge object:\", edge);\n        return null;\n      }\n\n      // Parse or stringify the style\n      let styleString;\n      if (typeof edge.style === \"object\") {\n        styleString = JSON.stringify(edge.style);\n      } else if (typeof edge.style === \"string\") {\n        styleString = edge.style;\n      } else {\n        styleString = JSON.stringify({});\n      }\n\n      // Return in the format expected by the server\n      return {\n        edgeIdentifier: edge.id,\n        source: edge.source,\n        target: edge.target,\n        type: edge.type || \"smoothstep\",\n        animated: edge.animated || false,\n        style: styleString\n      };\n    } catch (error) {\n      console.error(\"Error transforming edge to server format:\", error, edge);\n      return null;\n    }\n  }).filter(Boolean);\n};\nexport default {\n  getCourseRoadmap,\n  saveCourseRoadmap,\n  createCourseWithRoadmap,\n  transformNodesToClientFormat,\n  transformNodesToServerFormat,\n  transformEdgesToClientFormat,\n  transformEdgesToServerFormat\n};","map":{"version":3,"names":["api","getCourseRoadmap","courseId","console","log","courseResponse","get","courseData","data","roadmapId","nodes","edges","roadmapResponse","roadmapData","nodesResponse","Array","isArray","transformNodesToClientFormat","edgesResponse","transformEdgesToClientFormat","length","error","saveCourseRoadmap","isNaN","Number","Error","numericCourseId","post","title","description","categoryId","skillId","userId","id","put","transformedNodes","transformNodesToServerFormat","map","node","transformedEdges","transformEdgesToServerFormat","edge","_error$response","_error$response2","_error$response2$data","response","message","_error$response3","_error$response4","_error$response4$data","createCourseWithRoadmap","courseDetails","newCourse","type","position","nodeData","JSON","parse","e","label","nodeIdentifier","x","positionX","y","positionY","filter","Boolean","_node$position","_node$position2","warn","posX","posY","stringify","source","target","edgeStyle","style","edgeIdentifier","animated","styleString"],"sources":["D:/CyberPath/it-roadmap/client/src/services/courseRoadmapService.js"],"sourcesContent":["import api from \"./api\";\r\n\r\n// Get course with full roadmap data (nodes and edges)\r\nexport const getCourseRoadmap = async (courseId) => {\r\n  try {\r\n    console.log(`Fetching roadmap data for course ${courseId}`);\r\n\r\n    // Get the course data\r\n    const courseResponse = await api.get(`/courses/${courseId}`);\r\n    const courseData = courseResponse.data;\r\n\r\n    // Check if this course has an associated roadmap\r\n    let roadmapId = courseData.roadmapId;\r\n    let nodes = [];\r\n    let edges = [];\r\n\r\n    // If there's a roadmap associated, get its nodes and edges\r\n    if (roadmapId) {\r\n      console.log(`Course has roadmap ID: ${roadmapId}, fetching roadmap data`);\r\n\r\n      try {\r\n        // Get the roadmap data\r\n        const roadmapResponse = await api.get(`/roadmaps/${roadmapId}`);\r\n        const roadmapData = roadmapResponse.data;\r\n\r\n        // Get nodes from the roadmap\r\n        const nodesResponse = await api.get(`/roadmaps/${roadmapId}/nodes`);\r\n        if (nodesResponse.data && Array.isArray(nodesResponse.data)) {\r\n          nodes = transformNodesToClientFormat(nodesResponse.data);\r\n        }\r\n\r\n        // Get edges from the roadmap\r\n        const edgesResponse = await api.get(`/roadmaps/${roadmapId}/edges`);\r\n        if (edgesResponse.data && Array.isArray(edgesResponse.data)) {\r\n          edges = transformEdgesToClientFormat(edgesResponse.data);\r\n        }\r\n\r\n        console.log(\r\n          `Got ${nodes.length} nodes and ${edges.length} edges from roadmap ${roadmapId}`\r\n        );\r\n      } catch (error) {\r\n        console.error(`Error fetching roadmap ${roadmapId} data:`, error);\r\n        // Continue with empty nodes/edges\r\n      }\r\n    } else {\r\n      console.log(`Course ${courseId} has no associated roadmap yet`);\r\n    }\r\n\r\n    // Combine all data\r\n    const roadmapData = {\r\n      ...courseData,\r\n      nodes,\r\n      edges,\r\n    };\r\n\r\n    console.log(`Got roadmap data for course ${courseId}:`, roadmapData);\r\n    return roadmapData;\r\n  } catch (error) {\r\n    console.error(`Error fetching roadmap for course ${courseId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Save course roadmap data (nodes and edges)\r\nexport const saveCourseRoadmap = async (courseId, roadmapData) => {\r\n  try {\r\n    console.log(`Saving roadmap data for course ${courseId}`);\r\n\r\n    if (!courseId || isNaN(Number(courseId))) {\r\n      throw new Error(`Invalid course ID: ${courseId}`);\r\n    }\r\n\r\n    const numericCourseId = Number(courseId);\r\n    const { nodes, edges } = roadmapData;\r\n\r\n    console.log(\"Received nodes:\", nodes);\r\n    console.log(\"Received edges:\", edges);\r\n\r\n    // Validate nodes and edges\r\n    if (!Array.isArray(nodes)) {\r\n      throw new Error(\"Nodes must be an array\");\r\n    }\r\n\r\n    if (!Array.isArray(edges)) {\r\n      throw new Error(\"Edges must be an array\");\r\n    }\r\n\r\n    // Step 1: Check if the course already has a roadmap\r\n    console.log(`Step 1: Checking if course ${numericCourseId} has a roadmap`);\r\n    const courseResponse = await api.get(`/courses/${numericCourseId}`);\r\n    const courseData = courseResponse.data;\r\n\r\n    // Step 2: Get or create a roadmap\r\n    let roadmapId;\r\n\r\n    if (courseData.roadmapId) {\r\n      roadmapId = courseData.roadmapId;\r\n      console.log(`Step 2: Using existing roadmap ID: ${roadmapId}`);\r\n    } else {\r\n      console.log(`Step 2: Creating new roadmap for course ${numericCourseId}`);\r\n      // Create a new roadmap for this course\r\n      const roadmapResponse = await api.post(\"/roadmaps\", {\r\n        title: `Roadmap for ${courseData.title}`,\r\n        description: `Learning roadmap for course: ${courseData.title}`,\r\n        categoryId: courseData.categoryId,\r\n        skillId: courseData.skillId,\r\n        userId: courseData.userId || 1, // Default to user 1 if not specified\r\n      });\r\n\r\n      roadmapId = roadmapResponse.data.id;\r\n      console.log(`Created new roadmap with ID: ${roadmapId}`);\r\n\r\n      // Associate the roadmap with the course\r\n      console.log(\r\n        `Associating roadmap ${roadmapId} with course ${numericCourseId}`\r\n      );\r\n      await api.put(`/courses/${numericCourseId}`, {\r\n        roadmapId: roadmapId,\r\n      });\r\n    }\r\n\r\n    // Step 3: Transform nodes and edges\r\n    console.log(\r\n      `Step 3: Transforming nodes and edges for roadmap ${roadmapId}`\r\n    );\r\n    const transformedNodes = transformNodesToServerFormat(nodes).map(\r\n      (node) => ({\r\n        ...node,\r\n        roadmapId: roadmapId,\r\n      })\r\n    );\r\n\r\n    const transformedEdges = transformEdgesToServerFormat(edges).map(\r\n      (edge) => ({\r\n        ...edge,\r\n        roadmapId: roadmapId,\r\n      })\r\n    );\r\n\r\n    console.log(\"Transformed nodes with roadmapId:\", transformedNodes);\r\n    console.log(\"Transformed edges with roadmapId:\", transformedEdges);\r\n\r\n    // Step 4: Save nodes to the roadmap\r\n    console.log(`Step 4: Saving nodes to roadmap ${roadmapId}`);\r\n    if (transformedNodes.length > 0) {\r\n      try {\r\n        const nodesResponse = await api.put(`/roadmaps/${roadmapId}/nodes`, {\r\n          nodes: transformedNodes,\r\n        });\r\n        console.log(\"Nodes saved response:\", nodesResponse.data);\r\n      } catch (error) {\r\n        console.error(\r\n          \"Error saving nodes:\",\r\n          error.response?.data || error.message\r\n        );\r\n        throw new Error(\r\n          `Failed to save nodes: ${\r\n            error.response?.data?.message || error.message\r\n          }`\r\n        );\r\n      }\r\n    } else {\r\n      console.log(\"No nodes to save\");\r\n    }\r\n\r\n    // Step 5: Save edges to the roadmap\r\n    console.log(`Step 5: Saving edges to roadmap ${roadmapId}`);\r\n    if (transformedEdges.length > 0) {\r\n      try {\r\n        const edgesResponse = await api.put(`/roadmaps/${roadmapId}/edges`, {\r\n          edges: transformedEdges,\r\n        });\r\n        console.log(\"Edges saved response:\", edgesResponse.data);\r\n      } catch (error) {\r\n        console.error(\r\n          \"Error saving edges:\",\r\n          error.response?.data || error.message\r\n        );\r\n        throw new Error(\r\n          `Failed to save edges: ${\r\n            error.response?.data?.message || error.message\r\n          }`\r\n        );\r\n      }\r\n    } else {\r\n      console.log(\"No edges to save\");\r\n    }\r\n\r\n    console.log(\r\n      `Roadmap ${roadmapId} for course ${numericCourseId} saved successfully`\r\n    );\r\n\r\n    // Step 6: Get updated data\r\n    return await getCourseRoadmap(numericCourseId);\r\n  } catch (error) {\r\n    console.error(`Error saving roadmap for course ${courseId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Create a new course with roadmap data\r\nexport const createCourseWithRoadmap = async (courseData) => {\r\n  try {\r\n    console.log(\"Creating new course with roadmap data\");\r\n    const { nodes, edges, ...courseDetails } = courseData;\r\n\r\n    // Create the course first\r\n    const courseResponse = await api.post(\"/courses\", courseDetails);\r\n    const newCourse = courseResponse.data;\r\n    const courseId = newCourse.id;\r\n\r\n    // Then save nodes and edges if provided\r\n    if ((nodes && nodes.length > 0) || (edges && edges.length > 0)) {\r\n      await saveCourseRoadmap(courseId, { nodes, edges });\r\n    }\r\n\r\n    // Return the full course with roadmap data\r\n    return await getCourseRoadmap(courseId);\r\n  } catch (error) {\r\n    console.error(\"Error creating course with roadmap:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Transform nodes from server format to client format\r\nexport const transformNodesToClientFormat = (nodes) => {\r\n  return nodes\r\n    .map((node) => {\r\n      try {\r\n        // If node already has client format, return as is\r\n        if (node.type && node.position && node.data) {\r\n          return node;\r\n        }\r\n\r\n        // Parse the data if it's a string\r\n        let nodeData = node.data;\r\n        if (typeof node.data === \"string\") {\r\n          try {\r\n            nodeData = JSON.parse(node.data);\r\n          } catch (e) {\r\n            nodeData = { label: node.data };\r\n          }\r\n        }\r\n\r\n        return {\r\n          id: node.nodeIdentifier,\r\n          type: \"courseNode\", // Default node type\r\n          position: {\r\n            x: node.positionX || 0,\r\n            y: node.positionY || 0,\r\n          },\r\n          data: {\r\n            ...nodeData,\r\n            id: node.nodeIdentifier,\r\n          },\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming node to client format:\", error, node);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\n// Transform nodes from client format to server format\r\nexport const transformNodesToServerFormat = (nodes) => {\r\n  if (!Array.isArray(nodes)) {\r\n    console.error(\"Nodes is not an array:\", nodes);\r\n    return [];\r\n  }\r\n\r\n  return nodes\r\n    .map((node) => {\r\n      try {\r\n        if (!node || !node.id) {\r\n          console.warn(\"Invalid node object:\", node);\r\n          return null;\r\n        }\r\n\r\n        // Make sure position exists and has valid x, y values\r\n        const posX = node.position?.x || 0;\r\n        const posY = node.position?.y || 0;\r\n\r\n        // Make a copy of data to avoid mutating the original\r\n        const nodeData = { ...(node.data || {}) };\r\n\r\n        // Return in the format expected by the server\r\n        return {\r\n          nodeIdentifier: node.id,\r\n          positionX: posX,\r\n          positionY: posY,\r\n          data: JSON.stringify(nodeData),\r\n          courseId: nodeData.courseId || null,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming node to server format:\", error, node);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\n// Transform edges from server format to client format\r\nexport const transformEdgesToClientFormat = (edges) => {\r\n  return edges\r\n    .map((edge) => {\r\n      try {\r\n        // If edge already has client format, return as is\r\n        if (edge.source && edge.target && edge.id) {\r\n          return edge;\r\n        }\r\n\r\n        // Parse the style if it's a string\r\n        let edgeStyle = {};\r\n        if (typeof edge.style === \"string\") {\r\n          try {\r\n            edgeStyle = JSON.parse(edge.style);\r\n          } catch (e) {\r\n            edgeStyle = {};\r\n          }\r\n        } else if (typeof edge.style === \"object\") {\r\n          edgeStyle = edge.style;\r\n        }\r\n\r\n        return {\r\n          id: edge.edgeIdentifier,\r\n          source: edge.source,\r\n          target: edge.target,\r\n          type: edge.type || \"smoothstep\",\r\n          animated: edge.animated || false,\r\n          style: edgeStyle,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming edge to client format:\", error, edge);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\n// Transform edges from client format to server format\r\nexport const transformEdgesToServerFormat = (edges) => {\r\n  if (!Array.isArray(edges)) {\r\n    console.error(\"Edges is not an array:\", edges);\r\n    return [];\r\n  }\r\n\r\n  return edges\r\n    .map((edge) => {\r\n      try {\r\n        if (!edge || !edge.id || !edge.source || !edge.target) {\r\n          console.warn(\"Invalid edge object:\", edge);\r\n          return null;\r\n        }\r\n\r\n        // Parse or stringify the style\r\n        let styleString;\r\n        if (typeof edge.style === \"object\") {\r\n          styleString = JSON.stringify(edge.style);\r\n        } else if (typeof edge.style === \"string\") {\r\n          styleString = edge.style;\r\n        } else {\r\n          styleString = JSON.stringify({});\r\n        }\r\n\r\n        // Return in the format expected by the server\r\n        return {\r\n          edgeIdentifier: edge.id,\r\n          source: edge.source,\r\n          target: edge.target,\r\n          type: edge.type || \"smoothstep\",\r\n          animated: edge.animated || false,\r\n          style: styleString,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming edge to server format:\", error, edge);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\nexport default {\r\n  getCourseRoadmap,\r\n  saveCourseRoadmap,\r\n  createCourseWithRoadmap,\r\n  transformNodesToClientFormat,\r\n  transformNodesToServerFormat,\r\n  transformEdgesToClientFormat,\r\n  transformEdgesToServerFormat,\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}