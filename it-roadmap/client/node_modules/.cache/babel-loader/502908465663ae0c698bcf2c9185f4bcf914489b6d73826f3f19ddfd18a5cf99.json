{"ast":null,"code":"import api from \"./api\";\n\n// Get course with full roadmap data (nodes and edges)\nexport const getCourseRoadmap = async courseId => {\n  try {\n    console.log(`Fetching roadmap data for course ${courseId}`);\n\n    // Get the course data with nodes and edges\n    const courseResponse = await api.get(`/courses/${courseId}`);\n    const courseData = courseResponse.data;\n\n    // Get nodes separately for full data\n    const nodesResponse = await api.get(`/courses/${courseId}/nodes`);\n    const nodesData = nodesResponse.data;\n\n    // Get edges separately for full data\n    const edgesResponse = await api.get(`/courses/${courseId}/edges`);\n    const edgesData = edgesResponse.data;\n\n    // Combine all data\n    const roadmapData = {\n      ...courseData,\n      nodes: transformNodesToClientFormat(nodesData || []),\n      edges: transformEdgesToClientFormat(edgesData || [])\n    };\n    console.log(`Got roadmap data for course ${courseId}:`, roadmapData);\n    return roadmapData;\n  } catch (error) {\n    console.error(`Error fetching roadmap for course ${courseId}:`, error);\n    throw error;\n  }\n};\n\n// Save course roadmap data (nodes and edges)\nexport const saveCourseRoadmap = async (courseId, roadmapData) => {\n  try {\n    console.log(`Saving roadmap data for course ${courseId}`);\n    if (!courseId || isNaN(Number(courseId))) {\n      throw new Error(`Invalid course ID: ${courseId}`);\n    }\n    const numericCourseId = Number(courseId);\n    const {\n      nodes,\n      edges\n    } = roadmapData;\n    console.log(\"Received nodes:\", nodes);\n    console.log(\"Received edges:\", edges);\n\n    // Validate nodes and edges\n    if (!Array.isArray(nodes)) {\n      throw new Error(\"Nodes must be an array\");\n    }\n    if (!Array.isArray(edges)) {\n      throw new Error(\"Edges must be an array\");\n    }\n    const transformedNodes = transformNodesToServerFormat(nodes);\n    const transformedEdges = transformEdgesToServerFormat(edges);\n    console.log(\"Transformed nodes:\", transformedNodes);\n    console.log(\"Transformed edges:\", transformedEdges);\n\n    // Save nodes\n    if (transformedNodes.length > 0) {\n      console.log(`Saving ${transformedNodes.length} nodes for course ${numericCourseId}`);\n      await api.put(`/courses/${numericCourseId}/nodes`, {\n        nodes: transformedNodes\n      });\n    } else {\n      console.log(\"No nodes to save, sending empty array\");\n      await api.put(`/courses/${numericCourseId}/nodes`, {\n        nodes: []\n      });\n    }\n\n    // Save edges\n    if (transformedEdges.length > 0) {\n      console.log(`Saving ${transformedEdges.length} edges for course ${numericCourseId}`);\n      await api.put(`/courses/${numericCourseId}/edges`, {\n        edges: transformedEdges\n      });\n    } else {\n      console.log(\"No edges to save, sending empty array\");\n      await api.put(`/courses/${numericCourseId}/edges`, {\n        edges: []\n      });\n    }\n    console.log(\"Successfully saved nodes and edges\");\n\n    // Get updated data\n    return await getCourseRoadmap(numericCourseId);\n  } catch (error) {\n    console.error(`Error saving roadmap for course ${courseId}:`, error);\n    throw error;\n  }\n};\n\n// Create a new course with roadmap data\nexport const createCourseWithRoadmap = async courseData => {\n  try {\n    console.log(\"Creating new course with roadmap data\");\n    const {\n      nodes,\n      edges,\n      ...courseDetails\n    } = courseData;\n\n    // Create the course first\n    const courseResponse = await api.post(\"/courses\", courseDetails);\n    const newCourse = courseResponse.data;\n    const courseId = newCourse.id;\n\n    // Then save nodes and edges if provided\n    if (nodes && nodes.length > 0 || edges && edges.length > 0) {\n      await saveCourseRoadmap(courseId, {\n        nodes,\n        edges\n      });\n    }\n\n    // Return the full course with roadmap data\n    return await getCourseRoadmap(courseId);\n  } catch (error) {\n    console.error(\"Error creating course with roadmap:\", error);\n    throw error;\n  }\n};\n\n// Transform nodes from server format to client format\nexport const transformNodesToClientFormat = nodes => {\n  return nodes.map(node => {\n    try {\n      // If node already has client format, return as is\n      if (node.type && node.position && node.data) {\n        return node;\n      }\n\n      // Parse the data if it's a string\n      let nodeData = node.data;\n      if (typeof node.data === \"string\") {\n        try {\n          nodeData = JSON.parse(node.data);\n        } catch (e) {\n          nodeData = {\n            label: node.data\n          };\n        }\n      }\n      return {\n        id: node.nodeIdentifier,\n        type: \"courseNode\",\n        // Default node type\n        position: {\n          x: node.positionX || 0,\n          y: node.positionY || 0\n        },\n        data: {\n          ...nodeData,\n          id: node.nodeIdentifier\n        }\n      };\n    } catch (error) {\n      console.error(\"Error transforming node to client format:\", error, node);\n      return null;\n    }\n  }).filter(Boolean);\n};\n\n// Transform nodes from client format to server format\nexport const transformNodesToServerFormat = nodes => {\n  if (!Array.isArray(nodes)) {\n    console.error(\"Nodes is not an array:\", nodes);\n    return [];\n  }\n  return nodes.map(node => {\n    try {\n      var _node$position, _node$position2;\n      if (!node || !node.id) {\n        console.warn(\"Invalid node object:\", node);\n        return null;\n      }\n\n      // Make sure position exists and has valid x, y values\n      const posX = ((_node$position = node.position) === null || _node$position === void 0 ? void 0 : _node$position.x) || 0;\n      const posY = ((_node$position2 = node.position) === null || _node$position2 === void 0 ? void 0 : _node$position2.y) || 0;\n\n      // Ensure data is properly converted to string if it's an object\n      let nodeData;\n      if (typeof node.data === \"string\") {\n        nodeData = node.data;\n      } else if (typeof node.data === \"object\") {\n        try {\n          nodeData = JSON.stringify(node.data || {});\n        } catch (e) {\n          console.error(\"Error stringifying node data:\", e);\n          nodeData = JSON.stringify({\n            label: \"Error parsing data\"\n          });\n        }\n      } else {\n        nodeData = JSON.stringify({\n          label: \"Untitled\"\n        });\n      }\n      return {\n        nodeIdentifier: node.id,\n        positionX: posX,\n        positionY: posY,\n        data: nodeData\n      };\n    } catch (error) {\n      console.error(\"Error transforming node to server format:\", error, node);\n      return null;\n    }\n  }).filter(Boolean);\n};\n\n// Transform edges from server format to client format\nexport const transformEdgesToClientFormat = edges => {\n  return edges.map(edge => {\n    try {\n      // If edge already has client format, return as is\n      if (edge.source && edge.target && edge.id) {\n        return edge;\n      }\n\n      // Parse the style if it's a string\n      let style = {};\n      if (edge.style) {\n        try {\n          if (typeof edge.style === \"string\") {\n            style = JSON.parse(edge.style);\n          } else if (typeof edge.style === \"object\") {\n            style = edge.style;\n          }\n        } catch (e) {\n          style = {};\n        }\n      }\n      return {\n        id: edge.edgeIdentifier,\n        source: edge.source,\n        target: edge.target,\n        type: edge.type || \"smoothstep\",\n        animated: edge.animated || false,\n        style: {\n          stroke: style.stroke || \"#6d28d9\",\n          strokeWidth: style.strokeWidth || 1,\n          ...style\n        }\n      };\n    } catch (error) {\n      console.error(\"Error transforming edge to client format:\", error, edge);\n      return null;\n    }\n  }).filter(Boolean);\n};\n\n// Transform edges from client format to server format\nexport const transformEdgesToServerFormat = edges => {\n  if (!Array.isArray(edges)) {\n    console.error(\"Edges is not an array:\", edges);\n    return [];\n  }\n  return edges.map(edge => {\n    try {\n      if (!edge || !edge.id || !edge.source || !edge.target) {\n        console.warn(\"Invalid edge object:\", edge);\n        return null;\n      }\n\n      // Ensure style is properly converted to string if it's an object\n      let edgeStyle;\n      if (typeof edge.style === \"string\") {\n        edgeStyle = edge.style;\n      } else if (typeof edge.style === \"object\") {\n        try {\n          edgeStyle = JSON.stringify(edge.style || {});\n        } catch (e) {\n          console.error(\"Error stringifying edge style:\", e);\n          edgeStyle = JSON.stringify({});\n        }\n      } else {\n        edgeStyle = JSON.stringify({});\n      }\n      return {\n        edgeIdentifier: edge.id,\n        source: edge.source,\n        target: edge.target,\n        type: edge.type || \"smoothstep\",\n        animated: Boolean(edge.animated),\n        style: edgeStyle\n      };\n    } catch (error) {\n      console.error(\"Error transforming edge to server format:\", error, edge);\n      return null;\n    }\n  }).filter(Boolean);\n};\nexport default {\n  getCourseRoadmap,\n  saveCourseRoadmap,\n  createCourseWithRoadmap,\n  transformNodesToClientFormat,\n  transformNodesToServerFormat,\n  transformEdgesToClientFormat,\n  transformEdgesToServerFormat\n};","map":{"version":3,"names":["api","getCourseRoadmap","courseId","console","log","courseResponse","get","courseData","data","nodesResponse","nodesData","edgesResponse","edgesData","roadmapData","nodes","transformNodesToClientFormat","edges","transformEdgesToClientFormat","error","saveCourseRoadmap","isNaN","Number","Error","numericCourseId","Array","isArray","transformedNodes","transformNodesToServerFormat","transformedEdges","transformEdgesToServerFormat","length","put","createCourseWithRoadmap","courseDetails","post","newCourse","id","map","node","type","position","nodeData","JSON","parse","e","label","nodeIdentifier","x","positionX","y","positionY","filter","Boolean","_node$position","_node$position2","warn","posX","posY","stringify","edge","source","target","style","edgeIdentifier","animated","stroke","strokeWidth","edgeStyle"],"sources":["D:/CyberPath/it-roadmap/client/src/services/courseRoadmapService.js"],"sourcesContent":["import api from \"./api\";\r\n\r\n// Get course with full roadmap data (nodes and edges)\r\nexport const getCourseRoadmap = async (courseId) => {\r\n  try {\r\n    console.log(`Fetching roadmap data for course ${courseId}`);\r\n\r\n    // Get the course data with nodes and edges\r\n    const courseResponse = await api.get(`/courses/${courseId}`);\r\n    const courseData = courseResponse.data;\r\n\r\n    // Get nodes separately for full data\r\n    const nodesResponse = await api.get(`/courses/${courseId}/nodes`);\r\n    const nodesData = nodesResponse.data;\r\n\r\n    // Get edges separately for full data\r\n    const edgesResponse = await api.get(`/courses/${courseId}/edges`);\r\n    const edgesData = edgesResponse.data;\r\n\r\n    // Combine all data\r\n    const roadmapData = {\r\n      ...courseData,\r\n      nodes: transformNodesToClientFormat(nodesData || []),\r\n      edges: transformEdgesToClientFormat(edgesData || []),\r\n    };\r\n\r\n    console.log(`Got roadmap data for course ${courseId}:`, roadmapData);\r\n    return roadmapData;\r\n  } catch (error) {\r\n    console.error(`Error fetching roadmap for course ${courseId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Save course roadmap data (nodes and edges)\r\nexport const saveCourseRoadmap = async (courseId, roadmapData) => {\r\n  try {\r\n    console.log(`Saving roadmap data for course ${courseId}`);\r\n\r\n    if (!courseId || isNaN(Number(courseId))) {\r\n      throw new Error(`Invalid course ID: ${courseId}`);\r\n    }\r\n\r\n    const numericCourseId = Number(courseId);\r\n    const { nodes, edges } = roadmapData;\r\n\r\n    console.log(\"Received nodes:\", nodes);\r\n    console.log(\"Received edges:\", edges);\r\n\r\n    // Validate nodes and edges\r\n    if (!Array.isArray(nodes)) {\r\n      throw new Error(\"Nodes must be an array\");\r\n    }\r\n\r\n    if (!Array.isArray(edges)) {\r\n      throw new Error(\"Edges must be an array\");\r\n    }\r\n\r\n    const transformedNodes = transformNodesToServerFormat(nodes);\r\n    const transformedEdges = transformEdgesToServerFormat(edges);\r\n\r\n    console.log(\"Transformed nodes:\", transformedNodes);\r\n    console.log(\"Transformed edges:\", transformedEdges);\r\n\r\n    // Save nodes\r\n    if (transformedNodes.length > 0) {\r\n      console.log(\r\n        `Saving ${transformedNodes.length} nodes for course ${numericCourseId}`\r\n      );\r\n      await api.put(`/courses/${numericCourseId}/nodes`, {\r\n        nodes: transformedNodes,\r\n      });\r\n    } else {\r\n      console.log(\"No nodes to save, sending empty array\");\r\n      await api.put(`/courses/${numericCourseId}/nodes`, { nodes: [] });\r\n    }\r\n\r\n    // Save edges\r\n    if (transformedEdges.length > 0) {\r\n      console.log(\r\n        `Saving ${transformedEdges.length} edges for course ${numericCourseId}`\r\n      );\r\n      await api.put(`/courses/${numericCourseId}/edges`, {\r\n        edges: transformedEdges,\r\n      });\r\n    } else {\r\n      console.log(\"No edges to save, sending empty array\");\r\n      await api.put(`/courses/${numericCourseId}/edges`, { edges: [] });\r\n    }\r\n\r\n    console.log(\"Successfully saved nodes and edges\");\r\n\r\n    // Get updated data\r\n    return await getCourseRoadmap(numericCourseId);\r\n  } catch (error) {\r\n    console.error(`Error saving roadmap for course ${courseId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Create a new course with roadmap data\r\nexport const createCourseWithRoadmap = async (courseData) => {\r\n  try {\r\n    console.log(\"Creating new course with roadmap data\");\r\n    const { nodes, edges, ...courseDetails } = courseData;\r\n\r\n    // Create the course first\r\n    const courseResponse = await api.post(\"/courses\", courseDetails);\r\n    const newCourse = courseResponse.data;\r\n    const courseId = newCourse.id;\r\n\r\n    // Then save nodes and edges if provided\r\n    if ((nodes && nodes.length > 0) || (edges && edges.length > 0)) {\r\n      await saveCourseRoadmap(courseId, { nodes, edges });\r\n    }\r\n\r\n    // Return the full course with roadmap data\r\n    return await getCourseRoadmap(courseId);\r\n  } catch (error) {\r\n    console.error(\"Error creating course with roadmap:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Transform nodes from server format to client format\r\nexport const transformNodesToClientFormat = (nodes) => {\r\n  return nodes\r\n    .map((node) => {\r\n      try {\r\n        // If node already has client format, return as is\r\n        if (node.type && node.position && node.data) {\r\n          return node;\r\n        }\r\n\r\n        // Parse the data if it's a string\r\n        let nodeData = node.data;\r\n        if (typeof node.data === \"string\") {\r\n          try {\r\n            nodeData = JSON.parse(node.data);\r\n          } catch (e) {\r\n            nodeData = { label: node.data };\r\n          }\r\n        }\r\n\r\n        return {\r\n          id: node.nodeIdentifier,\r\n          type: \"courseNode\", // Default node type\r\n          position: {\r\n            x: node.positionX || 0,\r\n            y: node.positionY || 0,\r\n          },\r\n          data: {\r\n            ...nodeData,\r\n            id: node.nodeIdentifier,\r\n          },\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming node to client format:\", error, node);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\n// Transform nodes from client format to server format\r\nexport const transformNodesToServerFormat = (nodes) => {\r\n  if (!Array.isArray(nodes)) {\r\n    console.error(\"Nodes is not an array:\", nodes);\r\n    return [];\r\n  }\r\n\r\n  return nodes\r\n    .map((node) => {\r\n      try {\r\n        if (!node || !node.id) {\r\n          console.warn(\"Invalid node object:\", node);\r\n          return null;\r\n        }\r\n\r\n        // Make sure position exists and has valid x, y values\r\n        const posX = node.position?.x || 0;\r\n        const posY = node.position?.y || 0;\r\n\r\n        // Ensure data is properly converted to string if it's an object\r\n        let nodeData;\r\n        if (typeof node.data === \"string\") {\r\n          nodeData = node.data;\r\n        } else if (typeof node.data === \"object\") {\r\n          try {\r\n            nodeData = JSON.stringify(node.data || {});\r\n          } catch (e) {\r\n            console.error(\"Error stringifying node data:\", e);\r\n            nodeData = JSON.stringify({ label: \"Error parsing data\" });\r\n          }\r\n        } else {\r\n          nodeData = JSON.stringify({ label: \"Untitled\" });\r\n        }\r\n\r\n        return {\r\n          nodeIdentifier: node.id,\r\n          positionX: posX,\r\n          positionY: posY,\r\n          data: nodeData,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming node to server format:\", error, node);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\n// Transform edges from server format to client format\r\nexport const transformEdgesToClientFormat = (edges) => {\r\n  return edges\r\n    .map((edge) => {\r\n      try {\r\n        // If edge already has client format, return as is\r\n        if (edge.source && edge.target && edge.id) {\r\n          return edge;\r\n        }\r\n\r\n        // Parse the style if it's a string\r\n        let style = {};\r\n        if (edge.style) {\r\n          try {\r\n            if (typeof edge.style === \"string\") {\r\n              style = JSON.parse(edge.style);\r\n            } else if (typeof edge.style === \"object\") {\r\n              style = edge.style;\r\n            }\r\n          } catch (e) {\r\n            style = {};\r\n          }\r\n        }\r\n\r\n        return {\r\n          id: edge.edgeIdentifier,\r\n          source: edge.source,\r\n          target: edge.target,\r\n          type: edge.type || \"smoothstep\",\r\n          animated: edge.animated || false,\r\n          style: {\r\n            stroke: style.stroke || \"#6d28d9\",\r\n            strokeWidth: style.strokeWidth || 1,\r\n            ...style,\r\n          },\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming edge to client format:\", error, edge);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\n// Transform edges from client format to server format\r\nexport const transformEdgesToServerFormat = (edges) => {\r\n  if (!Array.isArray(edges)) {\r\n    console.error(\"Edges is not an array:\", edges);\r\n    return [];\r\n  }\r\n\r\n  return edges\r\n    .map((edge) => {\r\n      try {\r\n        if (!edge || !edge.id || !edge.source || !edge.target) {\r\n          console.warn(\"Invalid edge object:\", edge);\r\n          return null;\r\n        }\r\n\r\n        // Ensure style is properly converted to string if it's an object\r\n        let edgeStyle;\r\n        if (typeof edge.style === \"string\") {\r\n          edgeStyle = edge.style;\r\n        } else if (typeof edge.style === \"object\") {\r\n          try {\r\n            edgeStyle = JSON.stringify(edge.style || {});\r\n          } catch (e) {\r\n            console.error(\"Error stringifying edge style:\", e);\r\n            edgeStyle = JSON.stringify({});\r\n          }\r\n        } else {\r\n          edgeStyle = JSON.stringify({});\r\n        }\r\n\r\n        return {\r\n          edgeIdentifier: edge.id,\r\n          source: edge.source,\r\n          target: edge.target,\r\n          type: edge.type || \"smoothstep\",\r\n          animated: Boolean(edge.animated),\r\n          style: edgeStyle,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"Error transforming edge to server format:\", error, edge);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n};\r\n\r\nexport default {\r\n  getCourseRoadmap,\r\n  saveCourseRoadmap,\r\n  createCourseWithRoadmap,\r\n  transformNodesToClientFormat,\r\n  transformNodesToServerFormat,\r\n  transformEdgesToClientFormat,\r\n  transformEdgesToServerFormat,\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}