{"ast":null,"code":"import api from \"./api\";\n\n// Get all roadmaps\nexport const getRoadmaps = async () => {\n  const response = await api.get(\"/roadmaps\");\n  return response.data;\n};\n\n// Get roadmaps by category ID\nexport const getRoadmapsByCategory = async categoryId => {\n  if (!categoryId) {\n    return getRoadmaps(); // 如果没有提供类别ID，则返回所有路线图\n  }\n  try {\n    const response = await api.get(`/roadmaps?categoryId=${categoryId}`);\n    return response.data;\n  } catch (error) {\n    console.error(\"Error fetching roadmaps by category:\", error);\n    throw error;\n  }\n};\n\n// Get roadmap by ID\nexport const getRoadmapById = async id => {\n  const response = await api.get(`/roadmaps/${id}`);\n  // Format data to ensure consistent properties\n  const roadmapData = response.data;\n\n  // Make sure categoryName is available\n  if (roadmapData.category && !roadmapData.categoryName) {\n    roadmapData.categoryName = roadmapData.category.name;\n  }\n\n  // Make sure author info is available for backward compatibility\n  if (roadmapData.user && !roadmapData.author) {\n    roadmapData.author = roadmapData.user.username;\n  }\n  return roadmapData;\n};\n\n// Create new roadmap\nexport const createRoadmap = async roadmapData => {\n  const response = await api.post(\"/roadmaps\", roadmapData);\n  return response.data;\n};\n\n// Update roadmap\nexport const updateRoadmap = async (id, roadmapData) => {\n  const response = await api.put(`/roadmaps/${id}`, roadmapData);\n  return response.data;\n};\n\n// Delete roadmap\nexport const deleteRoadmap = async id => {\n  const response = await api.delete(`/roadmaps/${id}`);\n  return response.data;\n};\n\n// Get roadmap nodes - including course connections\nexport const getRoadmapNodes = async id => {\n  try {\n    var _response$data, _response$data2;\n    console.log(`Fetching nodes for roadmap ${id}`);\n    const response = await api.get(`/roadmaps/${id}/nodes`);\n    console.log(`[FETCH NODES] Raw server response:`, {\n      status: response.status,\n      dataLength: ((_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.length) || 0,\n      firstNode: ((_response$data2 = response.data) === null || _response$data2 === void 0 ? void 0 : _response$data2[0]) || \"none\"\n    });\n\n    // Transform server-side node format to client-side format\n    const transformedNodes = response.data.map(node => {\n      try {\n        // Parse the JSON data field\n        const nodeData = node.data ? JSON.parse(node.data) : {};\n\n        // Check if this node is linked to a course\n        let courseDetails = {};\n        if (node.courseId) {\n          // In a real implementation, you might fetch course details here\n          // or have them included in the node response\n          courseDetails = {\n            courseId: node.courseId\n            // Other course properties would be added here\n          };\n        }\n        return {\n          id: node.nodeIdentifier,\n          type: \"courseNode\",\n          // Default type for all nodes\n          position: {\n            x: node.positionX,\n            y: node.positionY\n          },\n          data: {\n            id: node.nodeIdentifier,\n            label: nodeData.label || \"\",\n            code: nodeData.code || \"\",\n            description: nodeData.description || \"\",\n            category: nodeData.category || \"\",\n            categoryId: nodeData.categoryId || null,\n            difficulty: nodeData.difficulty || \"beginner\",\n            credits: nodeData.credits || 0,\n            completed: nodeData.completed || false,\n            nodeColor: nodeData.nodeColor,\n            nodeBgColor: nodeData.nodeBgColor,\n            textColor: nodeData.textColor,\n            fontSize: nodeData.fontSize,\n            prerequisites: nodeData.prerequisites || \"\",\n            documentation: nodeData.documentation || \"\",\n            ...courseDetails\n          }\n        };\n      } catch (error) {\n        console.error(\"Error parsing node data:\", error, node);\n        return null;\n      }\n    }).filter(node => node !== null);\n    console.log(`Transformed ${transformedNodes.length} nodes`);\n    if (transformedNodes.length > 0) {\n      var _transformedNodes$0$d;\n      console.log(`[FETCH NODES] First transformed node:`, {\n        id: transformedNodes[0].id,\n        type: transformedNodes[0].type,\n        position: transformedNodes[0].position,\n        label: (_transformedNodes$0$d = transformedNodes[0].data) === null || _transformedNodes$0$d === void 0 ? void 0 : _transformedNodes$0$d.label\n      });\n    }\n    return transformedNodes;\n  } catch (error) {\n    console.error(\"Error fetching roadmap nodes:\", error);\n    throw error;\n  }\n};\n\n// Update roadmap nodes\nexport const updateRoadmapNodes = async (id, nodes) => {\n  try {\n    var _nodes;\n    console.log(`[API] Updating ${((_nodes = nodes) === null || _nodes === void 0 ? void 0 : _nodes.length) || 0} nodes for roadmap ${id}`);\n    console.log(`[API] Nodes data type:`, typeof nodes, Array.isArray(nodes));\n\n    // Đảm bảo nodes là mảng hợp lệ\n    if (!nodes) {\n      console.error(\"[API] Nodes is null or undefined\");\n      nodes = [];\n    }\n    if (!Array.isArray(nodes)) {\n      console.error(\"[API] Invalid nodes data - not an array:\", typeof nodes);\n      // Cố gắng chuyển đổi thành mảng nếu có thể\n      try {\n        if (typeof nodes === \"object\" && nodes !== null) {\n          nodes = Object.values(nodes);\n          console.log(\"[API] Converted object to array, length:\", nodes.length);\n        } else {\n          nodes = [];\n        }\n      } catch (conversionError) {\n        console.error(\"[API] Conversion error:\", conversionError);\n        nodes = [];\n      }\n    }\n    if (nodes.length === 0) {\n      console.warn(\"[API] Warning: Empty nodes array provided\");\n    }\n\n    // Transform to server format\n    const serverNodes = nodes.map(node => {\n      var _node$position, _node$position2, _node$data, _serverNode$data, _serverNode$data2;\n      // Ensure all required node properties exist\n      if (!(node !== null && node !== void 0 && node.id)) {\n        console.error(\"[UPDATE] Node missing id:\", node);\n        // Skip this node\n        return null;\n      }\n      if (!node.position) {\n        console.warn(`[UPDATE] Node ${node.id} missing position, using default`);\n        node.position = {\n          x: 0,\n          y: 0\n        };\n      }\n\n      // Ensure node data is well-formed JSON\n      let nodeDataString;\n      try {\n        if (typeof node.data === \"object\" && node.data !== null) {\n          nodeDataString = JSON.stringify(node.data);\n        } else if (typeof node.data === \"string\") {\n          // Validate that it's already valid JSON\n          try {\n            JSON.parse(node.data); // Just testing if this works\n            nodeDataString = node.data;\n          } catch (e) {\n            console.error(`[UPDATE] Invalid JSON data for node ${node.id}:`, e);\n            nodeDataString = JSON.stringify({\n              label: node.data || \"Unknown\"\n            });\n          }\n        } else {\n          nodeDataString = JSON.stringify({\n            label: \"Unknown\"\n          });\n        }\n      } catch (jsonError) {\n        console.error(`[UPDATE] Error stringifying data for node ${node.id}:`, jsonError);\n        nodeDataString = JSON.stringify({\n          label: \"Unknown\"\n        });\n      }\n\n      // Create properly formatted server node\n      const serverNode = {\n        nodeIdentifier: node.id,\n        positionX: ((_node$position = node.position) === null || _node$position === void 0 ? void 0 : _node$position.x) || 0,\n        positionY: ((_node$position2 = node.position) === null || _node$position2 === void 0 ? void 0 : _node$position2.y) || 0,\n        data: nodeDataString,\n        courseId: ((_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.courseId) || null\n      };\n      console.log(`[UPDATE] Transformed node ${node.id} for server:`, {\n        nodeIdentifier: serverNode.nodeIdentifier,\n        positionX: serverNode.positionX,\n        positionY: serverNode.positionY,\n        dataLength: (_serverNode$data = serverNode.data) === null || _serverNode$data === void 0 ? void 0 : _serverNode$data.length,\n        dataPreview: (_serverNode$data2 = serverNode.data) === null || _serverNode$data2 === void 0 ? void 0 : _serverNode$data2.substring(0, 50),\n        courseId: serverNode.courseId\n      });\n      return serverNode;\n    }).filter(node => node !== null); // Lọc bỏ các node null\n\n    console.log(`[API] Sending ${serverNodes.length} nodes to server`);\n    const response = await api.put(`/roadmaps/${id}/nodes`, {\n      nodes: serverNodes\n    });\n    console.log(`[API] Server response for nodes update:`, response.status, response.statusText);\n    console.log(`[API] Response data:`, response.data);\n    return response.data;\n  } catch (error) {\n    console.error(`[API ERROR] Failed to update nodes:`, error);\n    if (error.response) {\n      console.error(`[API ERROR] Response status:`, error.response.status);\n      console.error(`[API ERROR] Response data:`, error.response.data);\n    }\n    throw error;\n  }\n};\n\n// Get roadmap edges\nexport const getRoadmapEdges = async id => {\n  try {\n    var _response$data3, _response$data4;\n    console.log(`Fetching edges for roadmap ${id}`);\n    const response = await api.get(`/roadmaps/${id}/edges`);\n    console.log(`[FETCH EDGES] Raw server response:`, {\n      status: response.status,\n      dataLength: ((_response$data3 = response.data) === null || _response$data3 === void 0 ? void 0 : _response$data3.length) || 0,\n      firstEdge: ((_response$data4 = response.data) === null || _response$data4 === void 0 ? void 0 : _response$data4[0]) || \"none\"\n    });\n\n    // Transform server-side edge format to client-side format\n    const transformedEdges = response.data.map(edge => {\n      try {\n        // Parse the JSON style field\n        const edgeStyle = edge.style ? JSON.parse(edge.style) : {};\n        console.log(`[FETCH EDGES] Processing edge: ID=${edge.edgeIdentifier}, Source=${edge.source}, Target=${edge.target}`);\n        return {\n          id: edge.edgeIdentifier,\n          source: edge.source,\n          target: edge.target,\n          type: edge.type || \"smoothstep\",\n          animated: edge.animated || false,\n          // 保留源句柄和目标句柄信息\n          sourceHandle: edge.sourceHandle || null,\n          targetHandle: edge.targetHandle || null,\n          style: {\n            stroke: edgeStyle.stroke || \"#6d28d9\",\n            strokeWidth: edgeStyle.strokeWidth || 1\n          },\n          // 确保保留连接类型和其他数据\n          data: {\n            connectionType: edge.connectionType || \"arrow\",\n            ...(edge.data || {})\n          },\n          // 如果有方向箭头信息，也需要保留\n          ...(edge.connectionType === \"arrow\" && {\n            markerEnd: {\n              type: \"arrowclosed\",\n              width: 20,\n              height: 20,\n              color: \"#6d28d9\"\n            }\n          })\n        };\n      } catch (error) {\n        console.error(\"Error parsing edge data:\", error, edge);\n        return null;\n      }\n    }).filter(edge => edge !== null);\n    console.log(`Transformed ${transformedEdges.length} edges`);\n    if (transformedEdges.length > 0) {\n      console.log(`[FETCH EDGES] First transformed edge:`, {\n        id: transformedEdges[0].id,\n        source: transformedEdges[0].source,\n        target: transformedEdges[0].target,\n        sourceHandle: transformedEdges[0].sourceHandle,\n        targetHandle: transformedEdges[0].targetHandle\n      });\n    }\n    return transformedEdges;\n  } catch (error) {\n    console.error(\"Error fetching roadmap edges:\", error);\n    throw error;\n  }\n};\n\n// Update roadmap edges\nexport const updateRoadmapEdges = async (id, edges) => {\n  try {\n    var _edges;\n    console.log(`[API] Updating ${((_edges = edges) === null || _edges === void 0 ? void 0 : _edges.length) || 0} edges for roadmap ${id}`);\n    console.log(`[API] Edges data type:`, typeof edges, Array.isArray(edges));\n\n    // 确保edges是数组\n    if (!edges) {\n      console.error(\"[API] Edges is null or undefined\");\n      edges = [];\n    }\n    if (!Array.isArray(edges)) {\n      console.error(\"[API] Invalid edges data - not an array:\", typeof edges);\n      // 尝试转换为数组\n      try {\n        if (typeof edges === \"object\" && edges !== null) {\n          edges = Object.values(edges);\n          console.log(\"[API] Converted object to array, length:\", edges.length);\n        } else {\n          edges = [];\n        }\n      } catch (conversionError) {\n        console.error(\"[API] Conversion error:\", conversionError);\n        edges = [];\n      }\n    }\n    if (edges.length === 0) {\n      console.warn(\"[API] Warning: Empty edges array provided\");\n    }\n\n    // Log每个边缘的详细信息，确保source和target正确\n    edges.forEach((edge, index) => {\n      console.log(`[API] Edge ${index}: ID=${edge.id}, Source=${edge.source}, Target=${edge.target}, \n        SourceHandle=${edge.sourceHandle}, TargetHandle=${edge.targetHandle}`);\n    });\n\n    // Transform to server format\n    const serverEdges = edges.map(edge => {\n      var _edge$data;\n      // Validate required edge properties\n      if (!(edge !== null && edge !== void 0 && edge.id) || !(edge !== null && edge !== void 0 && edge.source) || !(edge !== null && edge !== void 0 && edge.target)) {\n        console.error(\"[UPDATE] Edge missing required properties:\", edge);\n        // Skip this edge instead of throwing an error\n        return null;\n      }\n\n      // Ensure style is well-formed JSON\n      let styleString;\n      if (typeof edge.style === \"object\" && edge.style !== null) {\n        try {\n          styleString = JSON.stringify(edge.style);\n        } catch (e) {\n          console.error(`[UPDATE] Error stringifying style for edge ${edge.id}:`, e);\n          styleString = JSON.stringify({\n            stroke: \"#999\"\n          });\n        }\n      } else if (typeof edge.style === \"string\") {\n        // Validate that it's already valid JSON\n        try {\n          JSON.parse(edge.style); // Just testing if this works\n          styleString = edge.style;\n        } catch (e) {\n          console.error(`[UPDATE] Invalid JSON style for edge ${edge.id}:`, e);\n          styleString = JSON.stringify({\n            stroke: \"#999\"\n          });\n        }\n      } else {\n        styleString = JSON.stringify({\n          stroke: \"#999\"\n        });\n      }\n\n      // 创建正确格式化的服务器边缘\n      const serverEdge = {\n        edgeIdentifier: edge.id,\n        source: edge.source,\n        target: edge.target,\n        // 保存句柄信息\n        sourceHandle: edge.sourceHandle || null,\n        targetHandle: edge.targetHandle || null,\n        type: edge.type || \"smoothstep\",\n        animated: edge.animated || false,\n        style: styleString,\n        // 保存连接类型\n        connectionType: ((_edge$data = edge.data) === null || _edge$data === void 0 ? void 0 : _edge$data.connectionType) || \"arrow\",\n        // 保存其他数据\n        data: edge.data ? JSON.stringify(edge.data) : null\n      };\n      console.log(`[UPDATE] Transformed edge ${edge.id} for server:`, {\n        edgeIdentifier: serverEdge.edgeIdentifier,\n        source: serverEdge.source,\n        target: serverEdge.target,\n        sourceHandle: serverEdge.sourceHandle,\n        targetHandle: serverEdge.targetHandle,\n        type: serverEdge.type\n      });\n      return serverEdge;\n    }).filter(edge => edge !== null); // 过滤掉无效边缘\n\n    console.log(`[API] Sending ${serverEdges.length} edges to server`);\n    const response = await api.put(`/roadmaps/${id}/edges`, {\n      edges: serverEdges\n    });\n    console.log(`[API] Server response for edges update:`, response.status, response.statusText);\n    console.log(`[API] Response data:`, response.data);\n    return response.data;\n  } catch (error) {\n    console.error(`[API ERROR] Failed to update edges:`, error);\n    if (error.response) {\n      console.error(`[API ERROR] Response status:`, error.response.status);\n      console.error(`[API ERROR] Response data:`, error.response.data);\n    }\n    throw error;\n  }\n};\n\n// Toggle favorite roadmap\nexport const toggleFavoriteRoadmap = async id => {\n  const response = await api.post(`/roadmaps/${id}/favorite`);\n  return response.data;\n};\n\n// Get user favorites\nexport const getUserFavorites = async () => {\n  const response = await api.get(\"/roadmaps/favorites\");\n  return response.data;\n};\n\n// Link a course to a roadmap node\nexport const linkCourseToNode = async (roadmapId, nodeId, courseId) => {\n  try {\n    const response = await api.post(`/roadmaps/${roadmapId}/nodes/${nodeId}/link-course`, {\n      courseId: Number(courseId)\n    });\n    return response.data;\n  } catch (error) {\n    console.error(\"Error linking course to node:\", error);\n    throw error;\n  }\n};","map":{"version":3,"names":["api","getRoadmaps","response","get","data","getRoadmapsByCategory","categoryId","error","console","getRoadmapById","id","roadmapData","category","categoryName","name","user","author","username","createRoadmap","post","updateRoadmap","put","deleteRoadmap","delete","getRoadmapNodes","_response$data","_response$data2","log","status","dataLength","length","firstNode","transformedNodes","map","node","nodeData","JSON","parse","courseDetails","courseId","nodeIdentifier","type","position","x","positionX","y","positionY","label","code","description","difficulty","credits","completed","nodeColor","nodeBgColor","textColor","fontSize","prerequisites","documentation","filter","_transformedNodes$0$d","updateRoadmapNodes","nodes","_nodes","Array","isArray","Object","values","conversionError","warn","serverNodes","_node$position","_node$position2","_node$data","_serverNode$data","_serverNode$data2","nodeDataString","stringify","e","jsonError","serverNode","dataPreview","substring","statusText","getRoadmapEdges","_response$data3","_response$data4","firstEdge","transformedEdges","edge","edgeStyle","style","edgeIdentifier","source","target","animated","sourceHandle","targetHandle","stroke","strokeWidth","connectionType","markerEnd","width","height","color","updateRoadmapEdges","edges","_edges","forEach","index","serverEdges","_edge$data","styleString","serverEdge","toggleFavoriteRoadmap","getUserFavorites","linkCourseToNode","roadmapId","nodeId","Number"],"sources":["D:/demo/DACS-jules_wip_16596734084587186652/it-roadmap/client/src/services/roadmapService.js"],"sourcesContent":["import api from \"./api\";\r\n\r\n// Get all roadmaps\r\nexport const getRoadmaps = async () => {\r\n  const response = await api.get(\"/roadmaps\");\r\n  return response.data;\r\n};\r\n\r\n// Get roadmaps by category ID\r\nexport const getRoadmapsByCategory = async (categoryId) => {\r\n  if (!categoryId) {\r\n    return getRoadmaps(); // 如果没有提供类别ID，则返回所有路线图\r\n  }\r\n  try {\r\n    const response = await api.get(`/roadmaps?categoryId=${categoryId}`);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error(\"Error fetching roadmaps by category:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Get roadmap by ID\r\nexport const getRoadmapById = async (id) => {\r\n  const response = await api.get(`/roadmaps/${id}`);\r\n  // Format data to ensure consistent properties\r\n  const roadmapData = response.data;\r\n\r\n  // Make sure categoryName is available\r\n  if (roadmapData.category && !roadmapData.categoryName) {\r\n    roadmapData.categoryName = roadmapData.category.name;\r\n  }\r\n\r\n  // Make sure author info is available for backward compatibility\r\n  if (roadmapData.user && !roadmapData.author) {\r\n    roadmapData.author = roadmapData.user.username;\r\n  }\r\n\r\n  return roadmapData;\r\n};\r\n\r\n// Create new roadmap\r\nexport const createRoadmap = async (roadmapData) => {\r\n  const response = await api.post(\"/roadmaps\", roadmapData);\r\n  return response.data;\r\n};\r\n\r\n// Update roadmap\r\nexport const updateRoadmap = async (id, roadmapData) => {\r\n  const response = await api.put(`/roadmaps/${id}`, roadmapData);\r\n  return response.data;\r\n};\r\n\r\n// Delete roadmap\r\nexport const deleteRoadmap = async (id) => {\r\n  const response = await api.delete(`/roadmaps/${id}`);\r\n  return response.data;\r\n};\r\n\r\n// Get roadmap nodes - including course connections\r\nexport const getRoadmapNodes = async (id) => {\r\n  try {\r\n    console.log(`Fetching nodes for roadmap ${id}`);\r\n    const response = await api.get(`/roadmaps/${id}/nodes`);\r\n\r\n    console.log(`[FETCH NODES] Raw server response:`, {\r\n      status: response.status,\r\n      dataLength: response.data?.length || 0,\r\n      firstNode: response.data?.[0] || \"none\",\r\n    });\r\n\r\n    // Transform server-side node format to client-side format\r\n    const transformedNodes = response.data\r\n      .map((node) => {\r\n        try {\r\n          // Parse the JSON data field\r\n          const nodeData = node.data ? JSON.parse(node.data) : {};\r\n\r\n          // Check if this node is linked to a course\r\n          let courseDetails = {};\r\n          if (node.courseId) {\r\n            // In a real implementation, you might fetch course details here\r\n            // or have them included in the node response\r\n            courseDetails = {\r\n              courseId: node.courseId,\r\n              // Other course properties would be added here\r\n            };\r\n          }\r\n\r\n          return {\r\n            id: node.nodeIdentifier,\r\n            type: \"courseNode\", // Default type for all nodes\r\n            position: {\r\n              x: node.positionX,\r\n              y: node.positionY,\r\n            },\r\n            data: {\r\n              id: node.nodeIdentifier,\r\n              label: nodeData.label || \"\",\r\n              code: nodeData.code || \"\",\r\n              description: nodeData.description || \"\",\r\n              category: nodeData.category || \"\",\r\n              categoryId: nodeData.categoryId || null,\r\n              difficulty: nodeData.difficulty || \"beginner\",\r\n              credits: nodeData.credits || 0,\r\n              completed: nodeData.completed || false,\r\n              nodeColor: nodeData.nodeColor,\r\n              nodeBgColor: nodeData.nodeBgColor,\r\n              textColor: nodeData.textColor,\r\n              fontSize: nodeData.fontSize,\r\n              prerequisites: nodeData.prerequisites || \"\",\r\n              documentation: nodeData.documentation || \"\",\r\n              ...courseDetails,\r\n            },\r\n          };\r\n        } catch (error) {\r\n          console.error(\"Error parsing node data:\", error, node);\r\n          return null;\r\n        }\r\n      })\r\n      .filter((node) => node !== null);\r\n\r\n    console.log(`Transformed ${transformedNodes.length} nodes`);\r\n    if (transformedNodes.length > 0) {\r\n      console.log(`[FETCH NODES] First transformed node:`, {\r\n        id: transformedNodes[0].id,\r\n        type: transformedNodes[0].type,\r\n        position: transformedNodes[0].position,\r\n        label: transformedNodes[0].data?.label,\r\n      });\r\n    }\r\n\r\n    return transformedNodes;\r\n  } catch (error) {\r\n    console.error(\"Error fetching roadmap nodes:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Update roadmap nodes\r\nexport const updateRoadmapNodes = async (id, nodes) => {\r\n  try {\r\n    console.log(`[API] Updating ${nodes?.length || 0} nodes for roadmap ${id}`);\r\n    console.log(`[API] Nodes data type:`, typeof nodes, Array.isArray(nodes));\r\n\r\n    // Đảm bảo nodes là mảng hợp lệ\r\n    if (!nodes) {\r\n      console.error(\"[API] Nodes is null or undefined\");\r\n      nodes = [];\r\n    }\r\n\r\n    if (!Array.isArray(nodes)) {\r\n      console.error(\"[API] Invalid nodes data - not an array:\", typeof nodes);\r\n      // Cố gắng chuyển đổi thành mảng nếu có thể\r\n      try {\r\n        if (typeof nodes === \"object\" && nodes !== null) {\r\n          nodes = Object.values(nodes);\r\n          console.log(\"[API] Converted object to array, length:\", nodes.length);\r\n        } else {\r\n          nodes = [];\r\n        }\r\n      } catch (conversionError) {\r\n        console.error(\"[API] Conversion error:\", conversionError);\r\n        nodes = [];\r\n      }\r\n    }\r\n\r\n    if (nodes.length === 0) {\r\n      console.warn(\"[API] Warning: Empty nodes array provided\");\r\n    }\r\n\r\n    // Transform to server format\r\n    const serverNodes = nodes\r\n      .map((node) => {\r\n        // Ensure all required node properties exist\r\n        if (!node?.id) {\r\n          console.error(\"[UPDATE] Node missing id:\", node);\r\n          // Skip this node\r\n          return null;\r\n        }\r\n\r\n        if (!node.position) {\r\n          console.warn(\r\n            `[UPDATE] Node ${node.id} missing position, using default`\r\n          );\r\n          node.position = { x: 0, y: 0 };\r\n        }\r\n\r\n        // Ensure node data is well-formed JSON\r\n        let nodeDataString;\r\n        try {\r\n          if (typeof node.data === \"object\" && node.data !== null) {\r\n            nodeDataString = JSON.stringify(node.data);\r\n          } else if (typeof node.data === \"string\") {\r\n            // Validate that it's already valid JSON\r\n            try {\r\n              JSON.parse(node.data); // Just testing if this works\r\n              nodeDataString = node.data;\r\n            } catch (e) {\r\n              console.error(\r\n                `[UPDATE] Invalid JSON data for node ${node.id}:`,\r\n                e\r\n              );\r\n              nodeDataString = JSON.stringify({\r\n                label: node.data || \"Unknown\",\r\n              });\r\n            }\r\n          } else {\r\n            nodeDataString = JSON.stringify({ label: \"Unknown\" });\r\n          }\r\n        } catch (jsonError) {\r\n          console.error(\r\n            `[UPDATE] Error stringifying data for node ${node.id}:`,\r\n            jsonError\r\n          );\r\n          nodeDataString = JSON.stringify({ label: \"Unknown\" });\r\n        }\r\n\r\n        // Create properly formatted server node\r\n        const serverNode = {\r\n          nodeIdentifier: node.id,\r\n          positionX: node.position?.x || 0,\r\n          positionY: node.position?.y || 0,\r\n          data: nodeDataString,\r\n          courseId: node.data?.courseId || null,\r\n        };\r\n\r\n        console.log(`[UPDATE] Transformed node ${node.id} for server:`, {\r\n          nodeIdentifier: serverNode.nodeIdentifier,\r\n          positionX: serverNode.positionX,\r\n          positionY: serverNode.positionY,\r\n          dataLength: serverNode.data?.length,\r\n          dataPreview: serverNode.data?.substring(0, 50),\r\n          courseId: serverNode.courseId,\r\n        });\r\n\r\n        return serverNode;\r\n      })\r\n      .filter((node) => node !== null); // Lọc bỏ các node null\r\n\r\n    console.log(`[API] Sending ${serverNodes.length} nodes to server`);\r\n\r\n    const response = await api.put(`/roadmaps/${id}/nodes`, {\r\n      nodes: serverNodes,\r\n    });\r\n\r\n    console.log(\r\n      `[API] Server response for nodes update:`,\r\n      response.status,\r\n      response.statusText\r\n    );\r\n    console.log(`[API] Response data:`, response.data);\r\n\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error(`[API ERROR] Failed to update nodes:`, error);\r\n    if (error.response) {\r\n      console.error(`[API ERROR] Response status:`, error.response.status);\r\n      console.error(`[API ERROR] Response data:`, error.response.data);\r\n    }\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Get roadmap edges\r\nexport const getRoadmapEdges = async (id) => {\r\n  try {\r\n    console.log(`Fetching edges for roadmap ${id}`);\r\n    const response = await api.get(`/roadmaps/${id}/edges`);\r\n\r\n    console.log(`[FETCH EDGES] Raw server response:`, {\r\n      status: response.status,\r\n      dataLength: response.data?.length || 0,\r\n      firstEdge: response.data?.[0] || \"none\",\r\n    });\r\n\r\n    // Transform server-side edge format to client-side format\r\n    const transformedEdges = response.data\r\n      .map((edge) => {\r\n        try {\r\n          // Parse the JSON style field\r\n          const edgeStyle = edge.style ? JSON.parse(edge.style) : {};\r\n\r\n          console.log(\r\n            `[FETCH EDGES] Processing edge: ID=${edge.edgeIdentifier}, Source=${edge.source}, Target=${edge.target}`\r\n          );\r\n\r\n          return {\r\n            id: edge.edgeIdentifier,\r\n            source: edge.source,\r\n            target: edge.target,\r\n            type: edge.type || \"smoothstep\",\r\n            animated: edge.animated || false,\r\n            // 保留源句柄和目标句柄信息\r\n            sourceHandle: edge.sourceHandle || null,\r\n            targetHandle: edge.targetHandle || null,\r\n            style: {\r\n              stroke: edgeStyle.stroke || \"#6d28d9\",\r\n              strokeWidth: edgeStyle.strokeWidth || 1,\r\n            },\r\n            // 确保保留连接类型和其他数据\r\n            data: {\r\n              connectionType: edge.connectionType || \"arrow\",\r\n              ...(edge.data || {}),\r\n            },\r\n            // 如果有方向箭头信息，也需要保留\r\n            ...(edge.connectionType === \"arrow\" && {\r\n              markerEnd: {\r\n                type: \"arrowclosed\",\r\n                width: 20,\r\n                height: 20,\r\n                color: \"#6d28d9\",\r\n              },\r\n            }),\r\n          };\r\n        } catch (error) {\r\n          console.error(\"Error parsing edge data:\", error, edge);\r\n          return null;\r\n        }\r\n      })\r\n      .filter((edge) => edge !== null);\r\n\r\n    console.log(`Transformed ${transformedEdges.length} edges`);\r\n    if (transformedEdges.length > 0) {\r\n      console.log(`[FETCH EDGES] First transformed edge:`, {\r\n        id: transformedEdges[0].id,\r\n        source: transformedEdges[0].source,\r\n        target: transformedEdges[0].target,\r\n        sourceHandle: transformedEdges[0].sourceHandle,\r\n        targetHandle: transformedEdges[0].targetHandle,\r\n      });\r\n    }\r\n\r\n    return transformedEdges;\r\n  } catch (error) {\r\n    console.error(\"Error fetching roadmap edges:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Update roadmap edges\r\nexport const updateRoadmapEdges = async (id, edges) => {\r\n  try {\r\n    console.log(`[API] Updating ${edges?.length || 0} edges for roadmap ${id}`);\r\n    console.log(`[API] Edges data type:`, typeof edges, Array.isArray(edges));\r\n\r\n    // 确保edges是数组\r\n    if (!edges) {\r\n      console.error(\"[API] Edges is null or undefined\");\r\n      edges = [];\r\n    }\r\n\r\n    if (!Array.isArray(edges)) {\r\n      console.error(\"[API] Invalid edges data - not an array:\", typeof edges);\r\n      // 尝试转换为数组\r\n      try {\r\n        if (typeof edges === \"object\" && edges !== null) {\r\n          edges = Object.values(edges);\r\n          console.log(\"[API] Converted object to array, length:\", edges.length);\r\n        } else {\r\n          edges = [];\r\n        }\r\n      } catch (conversionError) {\r\n        console.error(\"[API] Conversion error:\", conversionError);\r\n        edges = [];\r\n      }\r\n    }\r\n\r\n    if (edges.length === 0) {\r\n      console.warn(\"[API] Warning: Empty edges array provided\");\r\n    }\r\n\r\n    // Log每个边缘的详细信息，确保source和target正确\r\n    edges.forEach((edge, index) => {\r\n      console.log(`[API] Edge ${index}: ID=${edge.id}, Source=${edge.source}, Target=${edge.target}, \r\n        SourceHandle=${edge.sourceHandle}, TargetHandle=${edge.targetHandle}`);\r\n    });\r\n\r\n    // Transform to server format\r\n    const serverEdges = edges\r\n      .map((edge) => {\r\n        // Validate required edge properties\r\n        if (!edge?.id || !edge?.source || !edge?.target) {\r\n          console.error(\"[UPDATE] Edge missing required properties:\", edge);\r\n          // Skip this edge instead of throwing an error\r\n          return null;\r\n        }\r\n\r\n        // Ensure style is well-formed JSON\r\n        let styleString;\r\n        if (typeof edge.style === \"object\" && edge.style !== null) {\r\n          try {\r\n            styleString = JSON.stringify(edge.style);\r\n          } catch (e) {\r\n            console.error(\r\n              `[UPDATE] Error stringifying style for edge ${edge.id}:`,\r\n              e\r\n            );\r\n            styleString = JSON.stringify({ stroke: \"#999\" });\r\n          }\r\n        } else if (typeof edge.style === \"string\") {\r\n          // Validate that it's already valid JSON\r\n          try {\r\n            JSON.parse(edge.style); // Just testing if this works\r\n            styleString = edge.style;\r\n          } catch (e) {\r\n            console.error(\r\n              `[UPDATE] Invalid JSON style for edge ${edge.id}:`,\r\n              e\r\n            );\r\n            styleString = JSON.stringify({ stroke: \"#999\" });\r\n          }\r\n        } else {\r\n          styleString = JSON.stringify({ stroke: \"#999\" });\r\n        }\r\n\r\n        // 创建正确格式化的服务器边缘\r\n        const serverEdge = {\r\n          edgeIdentifier: edge.id,\r\n          source: edge.source,\r\n          target: edge.target,\r\n          // 保存句柄信息\r\n          sourceHandle: edge.sourceHandle || null,\r\n          targetHandle: edge.targetHandle || null,\r\n          type: edge.type || \"smoothstep\",\r\n          animated: edge.animated || false,\r\n          style: styleString,\r\n          // 保存连接类型\r\n          connectionType: edge.data?.connectionType || \"arrow\",\r\n          // 保存其他数据\r\n          data: edge.data ? JSON.stringify(edge.data) : null,\r\n        };\r\n\r\n        console.log(`[UPDATE] Transformed edge ${edge.id} for server:`, {\r\n          edgeIdentifier: serverEdge.edgeIdentifier,\r\n          source: serverEdge.source,\r\n          target: serverEdge.target,\r\n          sourceHandle: serverEdge.sourceHandle,\r\n          targetHandle: serverEdge.targetHandle,\r\n          type: serverEdge.type,\r\n        });\r\n\r\n        return serverEdge;\r\n      })\r\n      .filter((edge) => edge !== null); // 过滤掉无效边缘\r\n\r\n    console.log(`[API] Sending ${serverEdges.length} edges to server`);\r\n\r\n    const response = await api.put(`/roadmaps/${id}/edges`, {\r\n      edges: serverEdges,\r\n    });\r\n\r\n    console.log(\r\n      `[API] Server response for edges update:`,\r\n      response.status,\r\n      response.statusText\r\n    );\r\n    console.log(`[API] Response data:`, response.data);\r\n\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error(`[API ERROR] Failed to update edges:`, error);\r\n    if (error.response) {\r\n      console.error(`[API ERROR] Response status:`, error.response.status);\r\n      console.error(`[API ERROR] Response data:`, error.response.data);\r\n    }\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Toggle favorite roadmap\r\nexport const toggleFavoriteRoadmap = async (id) => {\r\n  const response = await api.post(`/roadmaps/${id}/favorite`);\r\n  return response.data;\r\n};\r\n\r\n// Get user favorites\r\nexport const getUserFavorites = async () => {\r\n  const response = await api.get(\"/roadmaps/favorites\");\r\n  return response.data;\r\n};\r\n\r\n// Link a course to a roadmap node\r\nexport const linkCourseToNode = async (roadmapId, nodeId, courseId) => {\r\n  try {\r\n    const response = await api.post(\r\n      `/roadmaps/${roadmapId}/nodes/${nodeId}/link-course`,\r\n      {\r\n        courseId: Number(courseId),\r\n      }\r\n    );\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error(\"Error linking course to node:\", error);\r\n    throw error;\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}