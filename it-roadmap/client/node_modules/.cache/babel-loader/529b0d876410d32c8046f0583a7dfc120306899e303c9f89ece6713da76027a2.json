{"ast":null,"code":"\"use client\";\n\nvar _jsxFileName = \"D:\\\\demo\\\\DACS-jules_wip_16596734084587186652\\\\it-roadmap\\\\client\\\\src\\\\components\\\\RoadmapView.jsx\",\n  _s = $RefreshSig$();\nimport { useState, useCallback, useEffect, useRef } from \"react\";\nimport ReactFlow, { MiniMap, Controls, Background, useNodesState, useEdgesState, addEdge, Panel, ReactFlowProvider, useReactFlow, MarkerType, Connection } from \"reactflow\";\nimport \"reactflow/dist/style.css\";\nimport { Tabs, TabsList, TabsTrigger } from \"./ui/tabs\";\nimport { Button } from \"./ui/button\";\nimport { useToast } from \"./ui/use-toast\";\nimport { PlusCircle, Save, Trash, Plus, X, Link as LinkIcon, LinkOff, Palette } from \"lucide-react\";\nimport CourseNode from \"./CourseNode\";\nimport CourseInfoPanel from \"./CourseInfoPanel\";\nimport AddCourseDialog from \"./AddCourseDialog\";\nimport RoadmapEditorPanel from \"./RoadmapEditorPanel\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst nodeTypes = {\n  courseNode: CourseNode\n};\nfunction RoadmapViewInner({\n  id,\n  initialNodes = [],\n  initialEdges = [],\n  isEditing = false,\n  readOnly = false,\n  onSave,\n  onInternalUpdate\n}) {\n  _s();\n  const {\n    toast\n  } = useToast();\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n  const [selectedNode, setSelectedNode] = useState(null);\n  const [selectedCategory, setSelectedCategory] = useState(\"all\");\n  const [isAddCourseOpen, setIsAddCourseOpen] = useState(false);\n  const [editMode, setEditMode] = useState(\"select\"); // select, connect, add, delete\n  const [connectionType, setConnectionType] = useState(\"arrow\"); // arrow, none\n  const [showEditorPanel, setShowEditorPanel] = useState(true);\n  const reactFlowWrapper = useRef(null);\n  const reactFlowInstance = useReactFlow();\n  const [undoStack, setUndoStack] = useState([]);\n  const [redoStack, setRedoStack] = useState([]);\n  const isInitialMount = useRef(true);\n  // Keep track of manually added nodes to prevent them from being lost\n  const addedNodesRef = useRef([]);\n\n  // Define handleCompleteToggle before it's used\n  const handleCompleteToggle = useCallback((nodeId, completed) => {\n    var _nodes$find;\n    if (readOnly) return;\n\n    // Get the current timestamp\n    const completedAt = completed ? new Date().toISOString() : null;\n    setNodes(nds => nds.map(node => {\n      if (node.id === nodeId) {\n        return {\n          ...node,\n          data: {\n            ...node.data,\n            completed,\n            completedAt\n          }\n        };\n      }\n      return node;\n    }));\n    toast({\n      title: completed ? \"Course marked as completed\" : \"Course marked as incomplete\",\n      description: `You've ${completed ? \"completed\" : \"unmarked\"} ${(_nodes$find = nodes.find(n => n.id === nodeId)) === null || _nodes$find === void 0 ? void 0 : _nodes$find.data.label}`\n    });\n  }, [nodes, setNodes, toast, readOnly]);\n\n  // Set initial nodes and edges when they change\n  useEffect(() => {\n    // Skip effect if no initial data\n    if (!(initialNodes !== null && initialNodes !== void 0 && initialNodes.length) && !(initialEdges !== null && initialEdges !== void 0 && initialEdges.length)) {\n      return;\n    }\n\n    // Only run once during initial mount to avoid re-render cycles\n    if (isInitialMount.current) {\n      console.log(\"[FLOW] Initial setup with nodes:\", initialNodes === null || initialNodes === void 0 ? void 0 : initialNodes.length);\n      if ((initialNodes === null || initialNodes === void 0 ? void 0 : initialNodes.length) > 0) {\n        // Process nodes once with required properties for display\n        const processedNodes = initialNodes.map(node => {\n          var _node$data;\n          return {\n            ...node,\n            type: \"courseNode\",\n            position: node.position || {\n              x: Math.random() * 500,\n              y: Math.random() * 300\n            },\n            data: {\n              ...node.data,\n              showQuickToggle: true,\n              onQuickToggle: handleCompleteToggle,\n              label: ((_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.label) || \"Untitled Node\"\n            }\n          };\n        });\n\n        // Initialize with the processed nodes\n        setNodes(processedNodes);\n        // Store initial nodes in our ref for tracking\n        addedNodesRef.current = [...processedNodes];\n      }\n\n      // Process edges only after nodes are set\n      if ((initialEdges === null || initialEdges === void 0 ? void 0 : initialEdges.length) > 0) {\n        console.log(\"[FLOW] Setting initial edges:\", initialEdges.length);\n\n        // Create a map of node IDs for quick lookup\n        const nodeMap = new Map(initialNodes.map(node => [node.id, node]));\n\n        // Validate edges against existing nodes to ensure they connect to valid nodes\n        const validEdges = initialEdges.filter(edge => {\n          // Check that both source and target nodes exist\n          const sourceExists = nodeMap.has(edge.source);\n          const targetExists = nodeMap.has(edge.target);\n          if (!sourceExists || !targetExists) {\n            console.warn(`[FLOW] Skipping invalid edge: Source exists: ${sourceExists}, Target exists: ${targetExists}`, edge);\n            return false;\n          }\n          return true;\n        });\n\n        // Log the handle positions found in the data\n        console.log(\"[FLOW] Edge handle data:\", validEdges.map(edge => {\n          var _edge$data, _edge$data2;\n          return {\n            id: edge.id,\n            sourceHandle: edge.sourceHandle || ((_edge$data = edge.data) === null || _edge$data === void 0 ? void 0 : _edge$data.sourceHandle),\n            targetHandle: edge.targetHandle || ((_edge$data2 = edge.data) === null || _edge$data2 === void 0 ? void 0 : _edge$data2.targetHandle)\n          };\n        }));\n\n        // Process edges with additional data\n        const processedEdges = validEdges.map(edge => {\n          var _edge$data3, _edge$data4, _edge$data5, _edge$data6;\n          // Extract handle information from wherever it might be stored\n          const sourceHandle = edge.sourceHandle || ((_edge$data3 = edge.data) === null || _edge$data3 === void 0 ? void 0 : _edge$data3.sourceHandle) || null;\n          const targetHandle = edge.targetHandle || ((_edge$data4 = edge.data) === null || _edge$data4 === void 0 ? void 0 : _edge$data4.targetHandle) || null;\n\n          // Generate a consistent ID based on all connection points\n          const edgeId = edge.id || `edge-${edge.source}-${sourceHandle || \"default\"}-${edge.target}-${targetHandle || \"default\"}`;\n          return {\n            ...edge,\n            // Ensure edge has required properties\n            id: edgeId,\n            type: edge.type || \"smoothstep\",\n            animated: edge.animated !== undefined ? edge.animated : true,\n            style: edge.style || {\n              stroke: \"hsl(var(--muted-foreground))\"\n            },\n            // Ensure handle positions are preserved\n            sourceHandle: sourceHandle,\n            targetHandle: targetHandle,\n            // Add class names for CSS targeting\n            className: `custom-edge source-${sourceHandle || \"default\"} target-${targetHandle || \"default\"}`,\n            // Store explicit connection information in data\n            data: {\n              ...(edge.data || {}),\n              sourceId: edge.source,\n              targetId: edge.target,\n              // Store handle positions in data for redundancy\n              sourceHandle: sourceHandle,\n              targetHandle: targetHandle,\n              // Store handle types for better visualization\n              sourceHandleType: sourceHandle || \"default\",\n              targetHandleType: targetHandle || \"default\",\n              connectionType: ((_edge$data5 = edge.data) === null || _edge$data5 === void 0 ? void 0 : _edge$data5.connectionType) || \"arrow\"\n            },\n            // Ensure markerEnd if using arrow type\n            ...(!edge.markerEnd && ((_edge$data6 = edge.data) === null || _edge$data6 === void 0 ? void 0 : _edge$data6.connectionType) !== \"none\" && {\n              markerEnd: {\n                type: MarkerType.ArrowClosed,\n                width: 20,\n                height: 20,\n                color: \"hsl(var(--primary))\"\n              }\n            })\n          };\n        });\n        console.log(\"[FLOW] Processed edges:\", processedEdges.length);\n        setEdges(processedEdges);\n      }\n\n      // Mark as initialized to prevent future re-processing\n      isInitialMount.current = false;\n    }\n  }, [initialNodes, initialEdges, setNodes, setEdges, handleCompleteToggle]);\n\n  // Update parent component with internal changes - optimized for fewer updates\n  useEffect(() => {\n    // Skip during initial render or if no update function provided\n    if (isInitialMount.current || !onInternalUpdate) return;\n\n    // Use a debounce to avoid too frequent updates\n    const timer = setTimeout(() => {\n      console.log(`[FLOW] Debounced parent update: ${nodes.length} nodes`);\n      onInternalUpdate(nodes, edges);\n    }, 500);\n    return () => clearTimeout(timer);\n  }, [nodes, edges, onInternalUpdate]);\n\n  // Simplify the node preservation effect\n  useEffect(() => {\n    if (addedNodesRef.current.length > 0 && nodes.length === 0) {\n      // Only restore if we've lost ALL nodes (prevents loops)\n      console.log(\"[FLOW] Lost all nodes, restoring from ref\");\n      setNodes(addedNodesRef.current);\n    }\n  }, [nodes.length, setNodes]);\n\n  // Save current state for undo feature\n  const saveCurrentState = useCallback(() => {\n    setUndoStack(prev => [...prev, {\n      nodes: [...nodes],\n      edges: [...edges]\n    }]);\n    setRedoStack([]);\n  }, [nodes, edges]);\n  const onConnect = useCallback(params => {\n    saveCurrentState();\n\n    // Generate a more stable ID using source, target and handle positions\n    // This ensures each unique connection point combination has its own ID\n    const edgeId = `edge-${params.source}-${params.sourceHandle || \"default\"}-${params.target}-${params.targetHandle || \"default\"}`;\n\n    // Log detail about the connection being made\n    console.log(\"[FLOW] Creating connection:\", {\n      source: params.source,\n      sourceHandle: params.sourceHandle,\n      target: params.target,\n      targetHandle: params.targetHandle,\n      edgeId: edgeId\n    });\n\n    // Add marker and apply current edge style settings\n    const newEdge = {\n      ...params,\n      id: edgeId,\n      type: \"smoothstep\",\n      animated: true,\n      style: {\n        stroke: \"hsl(var(--muted-foreground))\"\n      },\n      // Store handle positions explicitly\n      sourceHandle: params.sourceHandle,\n      targetHandle: params.targetHandle,\n      // Add data attributes directly to the edge DOM element\n      className: `custom-edge source-${params.sourceHandle || \"default\"} target-${params.targetHandle || \"default\"}`,\n      // Only add marker if connection type is arrow\n      ...(connectionType === \"arrow\" && {\n        markerEnd: {\n          type: MarkerType.ArrowClosed,\n          width: 20,\n          height: 20,\n          color: \"hsl(var(--primary))\"\n        }\n      }),\n      data: {\n        connectionType,\n        // Store source and target information explicitly\n        sourceId: params.source,\n        targetId: params.target,\n        // Store handle positions in data as well for redundancy\n        sourceHandle: params.sourceHandle,\n        targetHandle: params.targetHandle,\n        // Store handle types for better visualization\n        sourceHandleType: params.sourceHandle || \"default\",\n        targetHandleType: params.targetHandle || \"default\"\n      }\n    };\n    setEdges(eds => {\n      // Check if this exact connection already exists (same nodes and same handles)\n      const existingEdgeIndex = eds.findIndex(e => e.source === params.source && e.target === params.target && e.sourceHandle === params.sourceHandle && e.targetHandle === params.targetHandle);\n\n      // If connection exists, update it rather than adding a new one\n      if (existingEdgeIndex >= 0) {\n        const updatedEdges = [...eds];\n        updatedEdges[existingEdgeIndex] = newEdge;\n        console.log(\"[FLOW] Updated existing edge:\", newEdge);\n        return updatedEdges;\n      } else {\n        const newEdges = addEdge(newEdge, eds);\n        console.log(\"[FLOW] Edge added:\", newEdge);\n        console.log(\"[FLOW] Current edges count:\", newEdges.length);\n        return newEdges;\n      }\n    });\n    toast({\n      title: \"Connection added\",\n      description: \"A new connection has been created between nodes\"\n    });\n  }, [setEdges, saveCurrentState, toast, connectionType]);\n  const onNodeClick = useCallback((event, node) => {\n    event.stopPropagation();\n    if (editMode === \"delete\") {\n      // Delete mode: remove the node\n      saveCurrentState();\n      setNodes(nodes.filter(n => n.id !== node.id));\n      // Also remove any connected edges\n      setEdges(edges.filter(e => e.source !== node.id && e.target !== node.id));\n      toast({\n        title: \"Node deleted\",\n        description: `${node.data.label} has been removed from the roadmap`\n      });\n    } else if (editMode === \"connect\" && selectedNode) {\n      // Connect mode: create an edge between selectedNode and this node\n      if (selectedNode.id !== node.id) {\n        const newEdge = {\n          id: `edge-${Date.now()}`,\n          source: selectedNode.id,\n          target: node.id,\n          type: \"smoothstep\",\n          animated: true,\n          style: {\n            stroke: \"hsl(var(--muted-foreground))\"\n          },\n          ...(connectionType === \"arrow\" && {\n            markerEnd: {\n              type: MarkerType.ArrowClosed,\n              width: 20,\n              height: 20,\n              color: \"hsl(var(--primary))\"\n            }\n          }),\n          data: {\n            connectionType\n          }\n        };\n        saveCurrentState();\n        setEdges(eds => [...eds, newEdge]);\n        setSelectedNode(null);\n        setEditMode(\"select\");\n        toast({\n          title: \"Connection created\",\n          description: `Connected ${selectedNode.data.label} to ${node.data.label}`\n        });\n      }\n    } else if (editMode === \"select\") {\n      // Regular select mode: show node details\n      setSelectedNode(node);\n    }\n  }, [editMode, selectedNode, nodes, edges, setNodes, setEdges, saveCurrentState, toast]);\n  const onPaneClick = useCallback(() => {\n    // In regular mode, clicking the pane should deselect the node\n    setSelectedNode(null);\n\n    // If in connect mode but no node selected, return to select mode\n    if (editMode === \"connect\" && selectedNode) {\n      setEditMode(\"select\");\n      setSelectedNode(null);\n      toast({\n        title: \"Connection cancelled\",\n        description: \"Node connection has been cancelled\"\n      });\n    }\n  }, [editMode, selectedNode, toast]);\n  const handleSaveRoadmap = useCallback(() => {\n    if (onSave) {\n      console.log(\"[VIEW] Starting roadmap save process\");\n      console.log(\"[VIEW] Current nodes:\", nodes.length);\n      console.log(\"[VIEW] Current edges:\", edges.length);\n\n      // Debug: log thông tin an toàn về nodes và edges\n      try {\n        if (nodes.length > 0) {\n          var _nodes$, _nodes$2, _nodes$3, _nodes$4, _nodes$4$data;\n          console.log(\"[VIEW] First node sample:\", {\n            id: (_nodes$ = nodes[0]) === null || _nodes$ === void 0 ? void 0 : _nodes$.id,\n            type: (_nodes$2 = nodes[0]) === null || _nodes$2 === void 0 ? void 0 : _nodes$2.type,\n            position: (_nodes$3 = nodes[0]) !== null && _nodes$3 !== void 0 && _nodes$3.position ? {\n              ...nodes[0].position\n            } : null,\n            label: (_nodes$4 = nodes[0]) === null || _nodes$4 === void 0 ? void 0 : (_nodes$4$data = _nodes$4.data) === null || _nodes$4$data === void 0 ? void 0 : _nodes$4$data.label\n          });\n        }\n        if (edges.length > 0) {\n          var _edges$, _edges$2, _edges$3, _edges$4;\n          console.log(\"[VIEW] First edge sample:\", {\n            id: (_edges$ = edges[0]) === null || _edges$ === void 0 ? void 0 : _edges$.id,\n            source: (_edges$2 = edges[0]) === null || _edges$2 === void 0 ? void 0 : _edges$2.source,\n            target: (_edges$3 = edges[0]) === null || _edges$3 === void 0 ? void 0 : _edges$3.target,\n            type: (_edges$4 = edges[0]) === null || _edges$4 === void 0 ? void 0 : _edges$4.type\n          });\n        }\n      } catch (logError) {\n        console.error(\"[VIEW] Error logging node/edge details:\", logError);\n      }\n\n      // Lọc bỏ các nodes không hợp lệ\n      const validNodes = nodes.filter(node => {\n        if (!node || !node.id) {\n          console.warn(\"[VIEW] Skipping invalid node without ID\");\n          return false;\n        }\n        return true;\n      });\n\n      // Ensure no node is missing important data\n      const cleanedNodes = validNodes.map(node => {\n        var _node$position, _node$position2, _node$data2, _node$data3, _node$data4, _node$data5, _node$data6, _node$data7, _node$data8, _node$data9, _node$data0, _node$data1, _node$data10;\n        if (!node.position) {\n          console.error(\"[VIEW] Node missing position:\", node);\n          // Default position\n          node.position = {\n            x: 0,\n            y: 0\n          };\n        }\n        if (!node.data) {\n          console.error(\"[VIEW] Node missing data:\", node);\n          // Default minimal data\n          node.data = {\n            label: \"Node \" + node.id\n          };\n        }\n\n        // Tạo một node sạch không chứa các tham chiếu React/DOM\n        return {\n          id: node.id,\n          type: node.type || \"courseNode\",\n          // Default node type\n          position: {\n            x: ((_node$position = node.position) === null || _node$position === void 0 ? void 0 : _node$position.x) || 0,\n            y: ((_node$position2 = node.position) === null || _node$position2 === void 0 ? void 0 : _node$position2.y) || 0\n          },\n          data: {\n            id: node.id,\n            label: ((_node$data2 = node.data) === null || _node$data2 === void 0 ? void 0 : _node$data2.label) || \"Untitled\",\n            description: (_node$data3 = node.data) === null || _node$data3 === void 0 ? void 0 : _node$data3.description,\n            category: (_node$data4 = node.data) === null || _node$data4 === void 0 ? void 0 : _node$data4.category,\n            categoryId: (_node$data5 = node.data) === null || _node$data5 === void 0 ? void 0 : _node$data5.categoryId,\n            difficulty: (_node$data6 = node.data) === null || _node$data6 === void 0 ? void 0 : _node$data6.difficulty,\n            completed: ((_node$data7 = node.data) === null || _node$data7 === void 0 ? void 0 : _node$data7.completed) || false,\n            courseId: (_node$data8 = node.data) === null || _node$data8 === void 0 ? void 0 : _node$data8.courseId,\n            nodeColor: (_node$data9 = node.data) === null || _node$data9 === void 0 ? void 0 : _node$data9.nodeColor,\n            nodeBgColor: (_node$data0 = node.data) === null || _node$data0 === void 0 ? void 0 : _node$data0.nodeBgColor,\n            textColor: (_node$data1 = node.data) === null || _node$data1 === void 0 ? void 0 : _node$data1.textColor,\n            fontSize: (_node$data10 = node.data) === null || _node$data10 === void 0 ? void 0 : _node$data10.fontSize\n          }\n        };\n      });\n\n      // Remove any invalid edges\n      const nodeIdMap = new Set(cleanedNodes.map(node => node.id));\n\n      // Lọc bỏ các edges không hợp lệ\n      const validEdges = edges.filter(edge => {\n        if (!edge || !edge.id || !edge.source || !edge.target) {\n          console.warn(\"[VIEW] Skipping invalid edge missing id/source/target\");\n          return false;\n        }\n        return true;\n      });\n\n      // Clean edges - make sure they connect to existing nodes\n      const cleanedEdges = validEdges.filter(edge => {\n        // Check if source and target nodes exist\n        const sourceExists = nodeIdMap.has(edge.source);\n        const targetExists = nodeIdMap.has(edge.target);\n        if (!sourceExists || !targetExists) {\n          console.warn(`[VIEW] Removing invalid edge - Source exists: ${sourceExists}, Target exists: ${targetExists}`, edge);\n          return false;\n        }\n        return true;\n      }).map(edge => {\n        var _edge$data7;\n        // Tạo một edge sạch không chứa các tham chiếu React/DOM\n        return {\n          id: edge.id,\n          source: edge.source,\n          target: edge.target,\n          type: edge.type || \"smoothstep\",\n          animated: edge.animated || false,\n          sourceHandle: edge.sourceHandle || null,\n          targetHandle: edge.targetHandle || null,\n          style: edge.style ? {\n            ...edge.style\n          } : {\n            stroke: \"#999\"\n          },\n          data: {\n            connectionType: ((_edge$data7 = edge.data) === null || _edge$data7 === void 0 ? void 0 : _edge$data7.connectionType) || \"arrow\"\n          }\n        };\n      });\n      console.log(\"[VIEW] Cleaned nodes count:\", cleanedNodes.length);\n      console.log(\"[VIEW] Cleaned edges count:\", cleanedEdges.length);\n\n      // Debug: kiểm tra kiểu dữ liệu trước khi gọi callback\n      console.log(\"[VIEW] Cleaned nodes type:\", Array.isArray(cleanedNodes) ? \"Array\" : typeof cleanedNodes);\n      console.log(\"[VIEW] Cleaned edges type:\", Array.isArray(cleanedEdges) ? \"Array\" : typeof cleanedEdges);\n      console.log(\"[VIEW] First node in cleaned array:\", cleanedNodes[0]);\n\n      // Đảm bảo dữ liệu luôn là mảng\n      const finalNodes = Array.isArray(cleanedNodes) ? cleanedNodes : [];\n      const finalEdges = Array.isArray(cleanedEdges) ? cleanedEdges : [];\n\n      // Gọi callback để lưu dữ liệu đã được làm sạch\n      console.log(\"[VIEW] Calling onSave with:\", finalNodes.length, \"nodes and\", finalEdges.length, \"edges\");\n      onSave(finalNodes, finalEdges);\n    }\n  }, [nodes, edges, onSave]);\n  const handleAddCourse = useCallback(courseData => {\n    saveCurrentState();\n\n    // Generate a unique node ID with timestamp for guaranteed uniqueness\n    const newNodeId = `node-${Date.now()}-${Math.floor(Math.random() * 1000000)}`;\n\n    // Simple positioning math to ensure nodes don't overlap\n    const nodeOffsets = [{\n      x: 0,\n      y: 0\n    }, {\n      x: 250,\n      y: 0\n    }, {\n      x: 0,\n      y: 150\n    }, {\n      x: 250,\n      y: 150\n    }, {\n      x: -250,\n      y: 0\n    }, {\n      x: -250,\n      y: 150\n    }];\n\n    // Base position starts at center if possible\n    let baseX = 0,\n      baseY = 0;\n    if (reactFlowInstance) {\n      const viewport = reactFlowInstance.getViewport();\n      const screenCenter = reactFlowInstance.screenToFlowPosition({\n        x: window.innerWidth / 2,\n        y: window.innerHeight / 2\n      });\n      baseX = screenCenter.x;\n      baseY = screenCenter.y;\n    }\n\n    // Choose offset based on node count (cycle through positions)\n    const offset = nodeOffsets[nodes.length % nodeOffsets.length];\n\n    // Final position\n    const position = {\n      x: baseX + offset.x,\n      y: baseY + offset.y\n    };\n    console.log(`[FLOW] Creating new node at position: x=${position.x}, y=${position.y}`);\n\n    // Create the node with all required data\n    const newNode = {\n      id: newNodeId,\n      type: \"courseNode\",\n      position,\n      data: {\n        ...courseData,\n        id: newNodeId,\n        completed: false,\n        completedAt: null,\n        showQuickToggle: true,\n        onQuickToggle: handleCompleteToggle\n      }\n    };\n\n    // Add node directly to state and tracking ref\n    setNodes(currentNodes => [...currentNodes, newNode]);\n    addedNodesRef.current = [...addedNodesRef.current, newNode];\n\n    // Close dialog and show confirmation\n    setIsAddCourseOpen(false);\n    toast({\n      title: \"Course added\",\n      description: `${courseData.label} has been added to the roadmap`\n    });\n\n    // Ensure newly added node is visible\n    setTimeout(() => {\n      if (reactFlowInstance) {\n        reactFlowInstance.fitView({\n          padding: 0.5,\n          includeHiddenNodes: false,\n          minZoom: 0.5,\n          maxZoom: 1.5\n        });\n      }\n    }, 100);\n  }, [setNodes, toast, reactFlowInstance, nodes.length, handleCompleteToggle, saveCurrentState]);\n\n  // Ensure manually added nodes are preserved during state updates\n  useEffect(() => {\n    if (addedNodesRef.current.length > 0 && nodes.length > 0) {\n      // Get IDs of current nodes\n      const currentIds = new Set(nodes.map(n => n.id));\n\n      // Find manually added nodes that are missing from current nodes\n      const missingNodes = addedNodesRef.current.filter(n => !currentIds.has(n.id));\n\n      // If any manually added nodes are missing, add them back\n      if (missingNodes.length > 0) {\n        console.log(`[FLOW] Restoring ${missingNodes.length} manually added nodes that were lost`);\n        setNodes(currentNodes => [...currentNodes, ...missingNodes]);\n      }\n    }\n  }, [nodes, setNodes]);\n  const handleDeleteNode = useCallback(nodeId => {\n    saveCurrentState();\n\n    // Remove the node from state\n    setNodes(nds => nds.filter(node => node.id !== nodeId));\n\n    // Remove the node from our tracking ref\n    addedNodesRef.current = addedNodesRef.current.filter(node => node.id !== nodeId);\n\n    // Remove connected edges\n    setEdges(eds => eds.filter(edge => edge.source !== nodeId && edge.target !== nodeId));\n\n    // Clear selection\n    setSelectedNode(null);\n    toast({\n      title: \"Node deleted\",\n      description: \"The node has been removed from the roadmap\"\n    });\n\n    // Update view after deletion\n    setTimeout(() => {\n      if (reactFlowInstance) {\n        reactFlowInstance.fitView({\n          padding: 0.5\n        });\n      }\n    }, 100);\n  }, [setNodes, setEdges, toast, saveCurrentState, reactFlowInstance]);\n  const handleUpdateNodeStyle = useCallback((nodeId, style) => {\n    setNodes(nds => nds.map(node => {\n      if (node.id === nodeId) {\n        return {\n          ...node,\n          data: {\n            ...node.data,\n            ...style\n          }\n        };\n      }\n      return node;\n    }));\n  }, [setNodes]);\n  const onEdgeClick = useCallback((event, edge) => {\n    if (editMode === \"delete\") {\n      saveCurrentState();\n\n      // Delete the edge\n      setEdges(eds => eds.filter(e => e.id !== edge.id));\n      toast({\n        title: \"Connection removed\",\n        description: \"The connection between nodes has been removed\"\n      });\n    }\n  }, [setEdges, editMode, saveCurrentState, toast]);\n  const handleUndo = useCallback(() => {\n    if (undoStack.length === 0) return;\n    const currentState = {\n      nodes: [...nodes],\n      edges: [...edges]\n    };\n    const previousState = undoStack[undoStack.length - 1];\n    setRedoStack(prev => [...prev, currentState]);\n    setUndoStack(prev => prev.slice(0, -1));\n    setNodes(previousState.nodes);\n    setEdges(previousState.edges);\n    toast({\n      title: \"Undo\",\n      description: \"Previous action undone\"\n    });\n  }, [undoStack, redoStack, nodes, edges, setNodes, setEdges, toast]);\n  const handleRedo = useCallback(() => {\n    if (redoStack.length === 0) return;\n    const currentState = {\n      nodes: [...nodes],\n      edges: [...edges]\n    };\n    const nextState = redoStack[redoStack.length - 1];\n    setUndoStack(prev => [...prev, currentState]);\n    setRedoStack(prev => prev.slice(0, -1));\n    setNodes(nextState.nodes);\n    setEdges(nextState.edges);\n    toast({\n      title: \"Redo\",\n      description: \"Action redone\"\n    });\n  }, [undoStack, redoStack, nodes, edges, setNodes, setEdges, toast]);\n\n  // Update node positions when they are dragged\n  const onNodeDragStop = useCallback(() => {\n    if (isEditing) {\n      saveCurrentState();\n    }\n  }, [isEditing, saveCurrentState]);\n\n  // Handle category filtering\n  const filteredNodes = useCallback(() => {\n    if (selectedCategory === \"all\") {\n      return nodes;\n    }\n    return nodes.filter(node => {\n      var _node$data$category;\n      return ((_node$data$category = node.data.category) === null || _node$data$category === void 0 ? void 0 : _node$data$category.toLowerCase()) === selectedCategory.toLowerCase();\n    });\n  }, [nodes, selectedCategory]);\n  const handleStyleChange = useCallback(styles => {\n    // Apply styles to selected node or default edge options\n    if (selectedNode) {\n      handleUpdateNodeStyle(selectedNode.id, styles.nodeStyle);\n    }\n\n    // Update default edge options\n    // (would be implemented in a full version)\n  }, [selectedNode, handleUpdateNodeStyle]);\n  const handleConnectionTypeChange = useCallback(type => {\n    setConnectionType(type);\n  }, []);\n\n  // Ngăn chặn cảnh báo ResizeObserver\n  useEffect(() => {\n    // Chỉ áp dụng trong môi trường phát triển\n    if (process.env.NODE_ENV !== \"production\") {\n      // Instead of suppressing errors, let's implement a proper fix\n      let resizeObserverLoopErrCount = 0;\n      const debouncedResizeObserverCallback = debounce(() => {\n        resizeObserverLoopErrCount = 0;\n      }, 200);\n      const originalError = console.error;\n      console.error = (...args) => {\n        var _args$, _args$$includes, _args$2, _args$2$message, _args$2$message$inclu;\n        if ((_args$ = args[0]) !== null && _args$ !== void 0 && (_args$$includes = _args$.includes) !== null && _args$$includes !== void 0 && _args$$includes.call(_args$, \"ResizeObserver loop\") || (_args$2 = args[0]) !== null && _args$2 !== void 0 && (_args$2$message = _args$2.message) !== null && _args$2$message !== void 0 && (_args$2$message$inclu = _args$2$message.includes) !== null && _args$2$message$inclu !== void 0 && _args$2$message$inclu.call(_args$2$message, \"ResizeObserver loop\")) {\n          // Increment counter and invoke debounced callback\n          resizeObserverLoopErrCount += 1;\n          if (resizeObserverLoopErrCount <= 1) {\n            debouncedResizeObserverCallback();\n          }\n          // Suppress the error\n          return;\n        }\n        originalError.apply(console, args);\n      };\n      return () => {\n        console.error = originalError;\n      };\n    }\n\n    // Helper function for debounce\n    function debounce(fn, delay) {\n      let timeoutId;\n      return function () {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => fn.apply(this, arguments), delay);\n      };\n    }\n  }, []);\n\n  // Optimize edge rendering and enhance edge interaction\n  useEffect(() => {\n    // Configure ReactFlow for improved edge connection\n    const reactFlowEl = document.querySelector(\".react-flow\");\n    if (reactFlowEl) {\n      // Add custom class for better edge interaction\n      reactFlowEl.classList.add(\"improved-edge-connection\");\n    }\n    return () => {\n      if (reactFlowEl) {\n        reactFlowEl.classList.remove(\"improved-edge-connection\");\n      }\n    };\n  }, []);\n\n  // Ensure nodes are visible in the viewport\n  useEffect(() => {\n    if (!isInitialMount.current && nodes.length > 0 && reactFlowInstance) {\n      // Wait for rendering to complete, then fit view\n      const timeoutId = setTimeout(() => {\n        console.log(\"[FLOW] Fitting view to ensure nodes are visible\");\n        reactFlowInstance.fitView({\n          padding: 0.5,\n          includeHiddenNodes: true,\n          minZoom: 0.5,\n          maxZoom: 1.5\n        });\n      }, 500);\n      return () => clearTimeout(timeoutId);\n    }\n  }, [nodes.length, reactFlowInstance]);\n\n  // Add a debug useEffect to log whenever nodes change\n  useEffect(() => {\n    if (nodes.length > 0) {\n      console.log(\"[FLOW] Nodes changed, current count:\", nodes.length);\n    }\n  }, [nodes]);\n\n  // Cleanup on unmount to prevent memory leaks\n  useEffect(() => {\n    return () => {\n      // Clear any timeouts that might be pending\n      const viewportEl = document.querySelector(\".react-flow__viewport\");\n      if (viewportEl) {\n        viewportEl.style.transitionProperty = \"\";\n        viewportEl.style.transitionDuration = \"\";\n      }\n      console.log(\"[FLOW] Component unmounting, performing cleanup\");\n    };\n  }, []);\n\n  // Add special effect to prevent excessive console logging during development\n  useEffect(() => {\n    if (process.env.NODE_ENV === \"development\") {\n      const originalConsoleLog = console.log;\n      const flowLogPattern = /^\\[FLOW\\]/;\n\n      // Filter out excessive flow logs in development\n      console.log = (...args) => {\n        if (typeof args[0] === \"string\" && flowLogPattern.test(args[0])) {\n          // Only log important flow messages or when explicitly debugging\n          if (args[0].includes(\"error\") || args[0].includes(\"Creating\") || args[0].includes(\"deleted\")) {\n            originalConsoleLog.apply(console, args);\n          }\n        } else {\n          originalConsoleLog.apply(console, args);\n        }\n      };\n      return () => {\n        console.log = originalConsoleLog;\n      };\n    }\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: reactFlowWrapper,\n    className: \"h-full w-full\",\n    children: [isEditing && showEditorPanel && /*#__PURE__*/_jsxDEV(Panel, {\n      position: \"right\",\n      className: \"w-72 mr-2\",\n      children: /*#__PURE__*/_jsxDEV(RoadmapEditorPanel, {\n        onStyleChange: handleStyleChange,\n        onConnectionTypeChange: handleConnectionTypeChange,\n        activeEdgeStyle: connectionType,\n        editMode: editMode,\n        onEditModeChange: mode => {\n          setEditMode(mode);\n          if (mode === \"connect\") {\n            toast({\n              title: \"Connect mode\",\n              description: \"Click on a source node, then click on a target node to create a connection\"\n            });\n          } else if (mode === \"delete\") {\n            toast({\n              title: \"Delete mode\",\n              description: \"Click on a node or connection to delete it\"\n            });\n          }\n        },\n        onAddNodeClick: () => setIsAddCourseOpen(true)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 971,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 970,\n      columnNumber: 9\n    }, this), isEditing && /*#__PURE__*/_jsxDEV(Panel, {\n      position: \"top-right\",\n      className: \"bg-card p-3 rounded-sm border border-[hsl(var(--border))] shadow-md mb-4\" // Updated Panel classes, kept mr-[300px] for now\n      ,\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"flex gap-2 justify-end\",\n        children: [/*#__PURE__*/_jsxDEV(Button, {\n          size: \"sm\",\n          variant: \"outline\" // Changed to variant\n          ,\n          onClick: handleUndo,\n          disabled: undoStack.length === 0,\n          children: \"Undo\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1002,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(Button, {\n          size: \"sm\",\n          variant: \"outline\" // Changed to variant\n          ,\n          onClick: handleRedo,\n          disabled: redoStack.length === 0,\n          children: \"Redo\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1010,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(Button, {\n          variant: \"default\" // Changed to variant\n          ,\n          size: \"sm\",\n          onClick: handleSaveRoadmap,\n          children: [/*#__PURE__*/_jsxDEV(Save, {\n            className: \"h-4 w-4 mr-1\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1023,\n            columnNumber: 15\n          }, this), \" Save\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1018,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1001,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 997,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"h-full\",\n      children: /*#__PURE__*/_jsxDEV(ReactFlow, {\n        nodes: filteredNodes(),\n        edges: edges,\n        onNodesChange: isEditing ? onNodesChange : undefined,\n        onEdgesChange: isEditing ? onEdgesChange : undefined,\n        onConnect: isEditing ? onConnect : undefined,\n        onNodeClick: onNodeClick,\n        onEdgeClick: onEdgeClick,\n        onPaneClick: onPaneClick,\n        nodeTypes: nodeTypes,\n        onNodeDragStop: onNodeDragStop,\n        nodesDraggable: isEditing,\n        nodesConnectable: isEditing && editMode === \"connect\",\n        elementsSelectable: !readOnly,\n        defaultEdgeOptions: {\n          type: \"smoothstep\",\n          style: {\n            stroke: \"hsl(var(--muted-foreground))\"\n          },\n          // Updated stroke color\n          animated: true,\n          ...(connectionType === \"arrow\" && {\n            markerEnd: {\n              type: MarkerType.ArrowClosed,\n              width: 20,\n              height: 20,\n              color: \"hsl(var(--primary))\" // Updated marker color\n            }\n          }),\n          data: {\n            connectionType\n          }\n        },\n        fitView: true,\n        fitViewOptions: {\n          padding: 0.5,\n          includeHiddenNodes: true,\n          minZoom: 0.5,\n          maxZoom: 1.5\n        },\n        minZoom: 0.2,\n        maxZoom: 4,\n        snapToGrid: true,\n        snapGrid: [10, 10],\n        nodeExtent: [[-2000, -2000], [2000, 2000]],\n        proOptions: {\n          hideAttribution: true\n        },\n        disableKeyboardA11y: true,\n        autoPanOnNodeDrag: false,\n        elevateEdgesOnSelect: false,\n        onInit: instance => {\n          // Use setTimeout to ensure proper initialization\n          setTimeout(() => {\n            if (nodes.length > 0) {\n              instance.fitView({\n                padding: 0.5\n              });\n              console.log(\"[FLOW] Flow initialized with nodes:\", nodes.length);\n            }\n          }, 300);\n        }\n        // Add custom edge rendering to set data attributes based on handle positions\n        ,\n        edgeUpdaterRadius: 10,\n        edgesUpdatable: true,\n        edgesFocusable: true,\n        onEdgeUpdate: (oldEdge, newConnection) => {\n          setEdges(els => els.map(edge => {\n            if (edge.id === oldEdge.id) {\n              // Generate new ID based on new connection points\n              const newId = `edge-${newConnection.source}-${newConnection.sourceHandle || \"default\"}-${newConnection.target}-${newConnection.targetHandle || \"default\"}`;\n              return {\n                ...edge,\n                id: newId,\n                source: newConnection.source,\n                target: newConnection.target,\n                sourceHandle: newConnection.sourceHandle,\n                targetHandle: newConnection.targetHandle,\n                data: {\n                  ...edge.data,\n                  sourceId: newConnection.source,\n                  targetId: newConnection.target,\n                  sourceHandle: newConnection.sourceHandle,\n                  targetHandle: newConnection.targetHandle,\n                  sourceHandleType: newConnection.sourceHandle || \"default\",\n                  targetHandleType: newConnection.targetHandle || \"default\"\n                }\n              };\n            }\n            return edge;\n          }));\n          return true;\n        },\n        children: [/*#__PURE__*/_jsxDEV(Controls, {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1130,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(MiniMap, {\n          nodeStrokeWidth: 3,\n          zoomable: true,\n          pannable: true\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1131,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(Background, {\n          variant: \"dots\",\n          gap: 12,\n          size: 1,\n          color: \"hsl(var(--border))\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1132,\n          columnNumber: 11\n        }, this), \" \", edges.map(edge => /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            display: \"none\"\n          },\n          children: /*#__PURE__*/_jsxDEV(\"div\", {\n            \"data-edgeid\": edge.id,\n            \"data-sourcehandle\": edge.sourceHandle || \"default\",\n            \"data-targethandle\": edge.targetHandle || \"default\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1142,\n            columnNumber: 15\n          }, this)\n        }, `handle-${edge.id}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1141,\n          columnNumber: 13\n        }, this))]\n      }, `flow-${id}-${nodes.length}`, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1030,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1029,\n      columnNumber: 7\n    }, this), selectedNode && /*#__PURE__*/_jsxDEV(CourseInfoPanel, {\n      node: selectedNode,\n      onClose: () => setSelectedNode(null),\n      onCompleteToggle: handleCompleteToggle,\n      onDelete: isEditing ? handleDeleteNode : undefined,\n      onUpdateStyle: handleUpdateNodeStyle,\n      isAdmin: isEditing,\n      readOnly: readOnly\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1153,\n      columnNumber: 9\n    }, this), isAddCourseOpen && /*#__PURE__*/_jsxDEV(AddCourseDialog, {\n      open: isAddCourseOpen,\n      onClose: () => setIsAddCourseOpen(false),\n      onAdd: handleAddCourse\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1165,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 968,\n    columnNumber: 5\n  }, this);\n}\n_s(RoadmapViewInner, \"9J2GfLW/fDMIc0SGbvVXQ53UpuA=\", false, function () {\n  return [useToast, useNodesState, useEdgesState, useReactFlow];\n});\n_c = RoadmapViewInner;\nexport default function RoadmapView(props) {\n  var _props$initialNodes, _props$initialEdges;\n  console.log(\"[FLOW] RoadmapView wrapper rendering with props:\", {\n    id: props.id,\n    nodesCount: (_props$initialNodes = props.initialNodes) === null || _props$initialNodes === void 0 ? void 0 : _props$initialNodes.length,\n    edgesCount: (_props$initialEdges = props.initialEdges) === null || _props$initialEdges === void 0 ? void 0 : _props$initialEdges.length\n  });\n  return /*#__PURE__*/_jsxDEV(ReactFlowProvider, {\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"w-full h-full\",\n      children: /*#__PURE__*/_jsxDEV(RoadmapViewInner, {\n        ...props\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1185,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1184,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1183,\n    columnNumber: 5\n  }, this);\n}\n_c2 = RoadmapView;\nvar _c, _c2;\n$RefreshReg$(_c, \"RoadmapViewInner\");\n$RefreshReg$(_c2, \"RoadmapView\");","map":{"version":3,"names":["_jsxFileName","_s","$RefreshSig$","useState","useCallback","useEffect","useRef","ReactFlow","MiniMap","Controls","Background","useNodesState","useEdgesState","addEdge","Panel","ReactFlowProvider","useReactFlow","MarkerType","Connection","Tabs","TabsList","TabsTrigger","Button","useToast","PlusCircle","Save","Trash","Plus","X","Link","LinkIcon","LinkOff","Palette","CourseNode","CourseInfoPanel","AddCourseDialog","RoadmapEditorPanel","jsxDEV","_jsxDEV","nodeTypes","courseNode","RoadmapViewInner","id","initialNodes","initialEdges","isEditing","readOnly","onSave","onInternalUpdate","toast","nodes","setNodes","onNodesChange","edges","setEdges","onEdgesChange","selectedNode","setSelectedNode","selectedCategory","setSelectedCategory","isAddCourseOpen","setIsAddCourseOpen","editMode","setEditMode","connectionType","setConnectionType","showEditorPanel","setShowEditorPanel","reactFlowWrapper","reactFlowInstance","undoStack","setUndoStack","redoStack","setRedoStack","isInitialMount","addedNodesRef","handleCompleteToggle","nodeId","completed","_nodes$find","completedAt","Date","toISOString","nds","map","node","data","title","description","find","n","label","length","current","console","log","processedNodes","_node$data","type","position","x","Math","random","y","showQuickToggle","onQuickToggle","nodeMap","Map","validEdges","filter","edge","sourceExists","has","source","targetExists","target","warn","_edge$data","_edge$data2","sourceHandle","targetHandle","processedEdges","_edge$data3","_edge$data4","_edge$data5","_edge$data6","edgeId","animated","undefined","style","stroke","className","sourceId","targetId","sourceHandleType","targetHandleType","markerEnd","ArrowClosed","width","height","color","timer","setTimeout","clearTimeout","saveCurrentState","prev","onConnect","params","newEdge","eds","existingEdgeIndex","findIndex","e","updatedEdges","newEdges","onNodeClick","event","stopPropagation","now","onPaneClick","handleSaveRoadmap","_nodes$","_nodes$2","_nodes$3","_nodes$4","_nodes$4$data","_edges$","_edges$2","_edges$3","_edges$4","logError","error","validNodes","cleanedNodes","_node$position","_node$position2","_node$data2","_node$data3","_node$data4","_node$data5","_node$data6","_node$data7","_node$data8","_node$data9","_node$data0","_node$data1","_node$data10","category","categoryId","difficulty","courseId","nodeColor","nodeBgColor","textColor","fontSize","nodeIdMap","Set","cleanedEdges","_edge$data7","Array","isArray","finalNodes","finalEdges","handleAddCourse","courseData","newNodeId","floor","nodeOffsets","baseX","baseY","viewport","getViewport","screenCenter","screenToFlowPosition","window","innerWidth","innerHeight","offset","newNode","currentNodes","fitView","padding","includeHiddenNodes","minZoom","maxZoom","currentIds","missingNodes","handleDeleteNode","handleUpdateNodeStyle","onEdgeClick","handleUndo","currentState","previousState","slice","handleRedo","nextState","onNodeDragStop","filteredNodes","_node$data$category","toLowerCase","handleStyleChange","styles","nodeStyle","handleConnectionTypeChange","process","env","NODE_ENV","resizeObserverLoopErrCount","debouncedResizeObserverCallback","debounce","originalError","args","_args$","_args$$includes","_args$2","_args$2$message","_args$2$message$inclu","includes","call","message","apply","fn","delay","timeoutId","arguments","reactFlowEl","document","querySelector","classList","add","remove","viewportEl","transitionProperty","transitionDuration","originalConsoleLog","flowLogPattern","test","ref","children","onStyleChange","onConnectionTypeChange","activeEdgeStyle","onEditModeChange","mode","onAddNodeClick","fileName","lineNumber","columnNumber","size","variant","onClick","disabled","nodesDraggable","nodesConnectable","elementsSelectable","defaultEdgeOptions","fitViewOptions","snapToGrid","snapGrid","nodeExtent","proOptions","hideAttribution","disableKeyboardA11y","autoPanOnNodeDrag","elevateEdgesOnSelect","onInit","instance","edgeUpdaterRadius","edgesUpdatable","edgesFocusable","onEdgeUpdate","oldEdge","newConnection","els","newId","nodeStrokeWidth","zoomable","pannable","gap","display","onClose","onCompleteToggle","onDelete","onUpdateStyle","isAdmin","open","onAdd","_c","RoadmapView","props","_props$initialNodes","_props$initialEdges","nodesCount","edgesCount","_c2","$RefreshReg$"],"sources":["D:/demo/DACS-jules_wip_16596734084587186652/it-roadmap/client/src/components/RoadmapView.jsx"],"sourcesContent":["\"use client\";\r\n\r\nimport { useState, useCallback, useEffect, useRef } from \"react\";\r\nimport ReactFlow, {\r\n  MiniMap,\r\n  Controls,\r\n  Background,\r\n  useNodesState,\r\n  useEdgesState,\r\n  addEdge,\r\n  Panel,\r\n  ReactFlowProvider,\r\n  useReactFlow,\r\n  MarkerType,\r\n  Connection,\r\n} from \"reactflow\";\r\nimport \"reactflow/dist/style.css\";\r\nimport { Tabs, TabsList, TabsTrigger } from \"./ui/tabs\";\r\nimport { Button } from \"./ui/button\";\r\nimport { useToast } from \"./ui/use-toast\";\r\nimport {\r\n  PlusCircle,\r\n  Save,\r\n  Trash,\r\n  Plus,\r\n  X,\r\n  Link as LinkIcon,\r\n  LinkOff,\r\n  Palette,\r\n} from \"lucide-react\";\r\nimport CourseNode from \"./CourseNode\";\r\nimport CourseInfoPanel from \"./CourseInfoPanel\";\r\nimport AddCourseDialog from \"./AddCourseDialog\";\r\nimport RoadmapEditorPanel from \"./RoadmapEditorPanel\";\r\n\r\nconst nodeTypes = {\r\n  courseNode: CourseNode,\r\n};\r\n\r\nfunction RoadmapViewInner({\r\n  id,\r\n  initialNodes = [],\r\n  initialEdges = [],\r\n  isEditing = false,\r\n  readOnly = false,\r\n  onSave,\r\n  onInternalUpdate,\r\n}) {\r\n  const { toast } = useToast();\r\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\r\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\r\n  const [selectedNode, setSelectedNode] = useState(null);\r\n  const [selectedCategory, setSelectedCategory] = useState(\"all\");\r\n  const [isAddCourseOpen, setIsAddCourseOpen] = useState(false);\r\n  const [editMode, setEditMode] = useState(\"select\"); // select, connect, add, delete\r\n  const [connectionType, setConnectionType] = useState(\"arrow\"); // arrow, none\r\n  const [showEditorPanel, setShowEditorPanel] = useState(true);\r\n  const reactFlowWrapper = useRef(null);\r\n  const reactFlowInstance = useReactFlow();\r\n  const [undoStack, setUndoStack] = useState([]);\r\n  const [redoStack, setRedoStack] = useState([]);\r\n  const isInitialMount = useRef(true);\r\n  // Keep track of manually added nodes to prevent them from being lost\r\n  const addedNodesRef = useRef([]);\r\n\r\n  // Define handleCompleteToggle before it's used\r\n  const handleCompleteToggle = useCallback(\r\n    (nodeId, completed) => {\r\n      if (readOnly) return;\r\n\r\n      // Get the current timestamp\r\n      const completedAt = completed ? new Date().toISOString() : null;\r\n\r\n      setNodes((nds) =>\r\n        nds.map((node) => {\r\n          if (node.id === nodeId) {\r\n            return {\r\n              ...node,\r\n              data: {\r\n                ...node.data,\r\n                completed,\r\n                completedAt,\r\n              },\r\n            };\r\n          }\r\n          return node;\r\n        })\r\n      );\r\n\r\n      toast({\r\n        title: completed\r\n          ? \"Course marked as completed\"\r\n          : \"Course marked as incomplete\",\r\n        description: `You've ${completed ? \"completed\" : \"unmarked\"} ${\r\n          nodes.find((n) => n.id === nodeId)?.data.label\r\n        }`,\r\n      });\r\n    },\r\n    [nodes, setNodes, toast, readOnly]\r\n  );\r\n\r\n  // Set initial nodes and edges when they change\r\n  useEffect(() => {\r\n    // Skip effect if no initial data\r\n    if (!initialNodes?.length && !initialEdges?.length) {\r\n      return;\r\n    }\r\n\r\n    // Only run once during initial mount to avoid re-render cycles\r\n    if (isInitialMount.current) {\r\n      console.log(\"[FLOW] Initial setup with nodes:\", initialNodes?.length);\r\n\r\n      if (initialNodes?.length > 0) {\r\n        // Process nodes once with required properties for display\r\n        const processedNodes = initialNodes.map((node) => ({\r\n          ...node,\r\n          type: \"courseNode\",\r\n          position: node.position || {\r\n            x: Math.random() * 500,\r\n            y: Math.random() * 300,\r\n          },\r\n          data: {\r\n            ...node.data,\r\n            showQuickToggle: true,\r\n            onQuickToggle: handleCompleteToggle,\r\n            label: node.data?.label || \"Untitled Node\",\r\n          },\r\n        }));\r\n\r\n        // Initialize with the processed nodes\r\n        setNodes(processedNodes);\r\n        // Store initial nodes in our ref for tracking\r\n        addedNodesRef.current = [...processedNodes];\r\n      }\r\n\r\n      // Process edges only after nodes are set\r\n      if (initialEdges?.length > 0) {\r\n        console.log(\"[FLOW] Setting initial edges:\", initialEdges.length);\r\n\r\n        // Create a map of node IDs for quick lookup\r\n        const nodeMap = new Map(initialNodes.map((node) => [node.id, node]));\r\n\r\n        // Validate edges against existing nodes to ensure they connect to valid nodes\r\n        const validEdges = initialEdges.filter((edge) => {\r\n          // Check that both source and target nodes exist\r\n          const sourceExists = nodeMap.has(edge.source);\r\n          const targetExists = nodeMap.has(edge.target);\r\n\r\n          if (!sourceExists || !targetExists) {\r\n            console.warn(\r\n              `[FLOW] Skipping invalid edge: Source exists: ${sourceExists}, Target exists: ${targetExists}`,\r\n              edge\r\n            );\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n\r\n        // Log the handle positions found in the data\r\n        console.log(\r\n          \"[FLOW] Edge handle data:\",\r\n          validEdges.map((edge) => ({\r\n            id: edge.id,\r\n            sourceHandle: edge.sourceHandle || edge.data?.sourceHandle,\r\n            targetHandle: edge.targetHandle || edge.data?.targetHandle,\r\n          }))\r\n        );\r\n\r\n        // Process edges with additional data\r\n        const processedEdges = validEdges.map((edge) => {\r\n          // Extract handle information from wherever it might be stored\r\n          const sourceHandle =\r\n            edge.sourceHandle || edge.data?.sourceHandle || null;\r\n          const targetHandle =\r\n            edge.targetHandle || edge.data?.targetHandle || null;\r\n\r\n          // Generate a consistent ID based on all connection points\r\n          const edgeId =\r\n            edge.id ||\r\n            `edge-${edge.source}-${sourceHandle || \"default\"}-${edge.target}-${\r\n              targetHandle || \"default\"\r\n            }`;\r\n\r\n          return {\r\n            ...edge,\r\n            // Ensure edge has required properties\r\n            id: edgeId,\r\n            type: edge.type || \"smoothstep\",\r\n            animated: edge.animated !== undefined ? edge.animated : true,\r\n            style: edge.style || { stroke: \"hsl(var(--muted-foreground))\" },\r\n            // Ensure handle positions are preserved\r\n            sourceHandle: sourceHandle,\r\n            targetHandle: targetHandle,\r\n            // Add class names for CSS targeting\r\n            className: `custom-edge source-${\r\n              sourceHandle || \"default\"\r\n            } target-${targetHandle || \"default\"}`,\r\n            // Store explicit connection information in data\r\n            data: {\r\n              ...(edge.data || {}),\r\n              sourceId: edge.source,\r\n              targetId: edge.target,\r\n              // Store handle positions in data for redundancy\r\n              sourceHandle: sourceHandle,\r\n              targetHandle: targetHandle,\r\n              // Store handle types for better visualization\r\n              sourceHandleType: sourceHandle || \"default\",\r\n              targetHandleType: targetHandle || \"default\",\r\n              connectionType: edge.data?.connectionType || \"arrow\",\r\n            },\r\n            // Ensure markerEnd if using arrow type\r\n            ...(!edge.markerEnd &&\r\n              edge.data?.connectionType !== \"none\" && {\r\n                markerEnd: {\r\n                  type: MarkerType.ArrowClosed,\r\n                  width: 20,\r\n                  height: 20,\r\n                  color: \"hsl(var(--primary))\",\r\n                },\r\n              }),\r\n          };\r\n        });\r\n\r\n        console.log(\"[FLOW] Processed edges:\", processedEdges.length);\r\n        setEdges(processedEdges);\r\n      }\r\n\r\n      // Mark as initialized to prevent future re-processing\r\n      isInitialMount.current = false;\r\n    }\r\n  }, [initialNodes, initialEdges, setNodes, setEdges, handleCompleteToggle]);\r\n\r\n  // Update parent component with internal changes - optimized for fewer updates\r\n  useEffect(() => {\r\n    // Skip during initial render or if no update function provided\r\n    if (isInitialMount.current || !onInternalUpdate) return;\r\n\r\n    // Use a debounce to avoid too frequent updates\r\n    const timer = setTimeout(() => {\r\n      console.log(`[FLOW] Debounced parent update: ${nodes.length} nodes`);\r\n      onInternalUpdate(nodes, edges);\r\n    }, 500);\r\n\r\n    return () => clearTimeout(timer);\r\n  }, [nodes, edges, onInternalUpdate]);\r\n\r\n  // Simplify the node preservation effect\r\n  useEffect(() => {\r\n    if (addedNodesRef.current.length > 0 && nodes.length === 0) {\r\n      // Only restore if we've lost ALL nodes (prevents loops)\r\n      console.log(\"[FLOW] Lost all nodes, restoring from ref\");\r\n      setNodes(addedNodesRef.current);\r\n    }\r\n  }, [nodes.length, setNodes]);\r\n\r\n  // Save current state for undo feature\r\n  const saveCurrentState = useCallback(() => {\r\n    setUndoStack((prev) => [...prev, { nodes: [...nodes], edges: [...edges] }]);\r\n    setRedoStack([]);\r\n  }, [nodes, edges]);\r\n\r\n  const onConnect = useCallback(\r\n    (params) => {\r\n      saveCurrentState();\r\n\r\n      // Generate a more stable ID using source, target and handle positions\r\n      // This ensures each unique connection point combination has its own ID\r\n      const edgeId = `edge-${params.source}-${\r\n        params.sourceHandle || \"default\"\r\n      }-${params.target}-${params.targetHandle || \"default\"}`;\r\n\r\n      // Log detail about the connection being made\r\n      console.log(\"[FLOW] Creating connection:\", {\r\n        source: params.source,\r\n        sourceHandle: params.sourceHandle,\r\n        target: params.target,\r\n        targetHandle: params.targetHandle,\r\n        edgeId: edgeId,\r\n      });\r\n\r\n      // Add marker and apply current edge style settings\r\n      const newEdge = {\r\n        ...params,\r\n        id: edgeId,\r\n        type: \"smoothstep\",\r\n        animated: true,\r\n        style: { stroke: \"hsl(var(--muted-foreground))\" },\r\n        // Store handle positions explicitly\r\n        sourceHandle: params.sourceHandle,\r\n        targetHandle: params.targetHandle,\r\n        // Add data attributes directly to the edge DOM element\r\n        className: `custom-edge source-${\r\n          params.sourceHandle || \"default\"\r\n        } target-${params.targetHandle || \"default\"}`,\r\n        // Only add marker if connection type is arrow\r\n        ...(connectionType === \"arrow\" && {\r\n          markerEnd: {\r\n            type: MarkerType.ArrowClosed,\r\n            width: 20,\r\n            height: 20,\r\n            color: \"hsl(var(--primary))\",\r\n          },\r\n        }),\r\n        data: {\r\n          connectionType,\r\n          // Store source and target information explicitly\r\n          sourceId: params.source,\r\n          targetId: params.target,\r\n          // Store handle positions in data as well for redundancy\r\n          sourceHandle: params.sourceHandle,\r\n          targetHandle: params.targetHandle,\r\n          // Store handle types for better visualization\r\n          sourceHandleType: params.sourceHandle || \"default\",\r\n          targetHandleType: params.targetHandle || \"default\",\r\n        },\r\n      };\r\n\r\n      setEdges((eds) => {\r\n        // Check if this exact connection already exists (same nodes and same handles)\r\n        const existingEdgeIndex = eds.findIndex(\r\n          (e) =>\r\n            e.source === params.source &&\r\n            e.target === params.target &&\r\n            e.sourceHandle === params.sourceHandle &&\r\n            e.targetHandle === params.targetHandle\r\n        );\r\n\r\n        // If connection exists, update it rather than adding a new one\r\n        if (existingEdgeIndex >= 0) {\r\n          const updatedEdges = [...eds];\r\n          updatedEdges[existingEdgeIndex] = newEdge;\r\n          console.log(\"[FLOW] Updated existing edge:\", newEdge);\r\n          return updatedEdges;\r\n        } else {\r\n          const newEdges = addEdge(newEdge, eds);\r\n          console.log(\"[FLOW] Edge added:\", newEdge);\r\n          console.log(\"[FLOW] Current edges count:\", newEdges.length);\r\n          return newEdges;\r\n        }\r\n      });\r\n\r\n      toast({\r\n        title: \"Connection added\",\r\n        description: \"A new connection has been created between nodes\",\r\n      });\r\n    },\r\n    [setEdges, saveCurrentState, toast, connectionType]\r\n  );\r\n\r\n  const onNodeClick = useCallback(\r\n    (event, node) => {\r\n      event.stopPropagation();\r\n\r\n      if (editMode === \"delete\") {\r\n        // Delete mode: remove the node\r\n        saveCurrentState();\r\n        setNodes(nodes.filter((n) => n.id !== node.id));\r\n        // Also remove any connected edges\r\n        setEdges(\r\n          edges.filter((e) => e.source !== node.id && e.target !== node.id)\r\n        );\r\n\r\n        toast({\r\n          title: \"Node deleted\",\r\n          description: `${node.data.label} has been removed from the roadmap`,\r\n        });\r\n      } else if (editMode === \"connect\" && selectedNode) {\r\n        // Connect mode: create an edge between selectedNode and this node\r\n        if (selectedNode.id !== node.id) {\r\n          const newEdge = {\r\n            id: `edge-${Date.now()}`,\r\n            source: selectedNode.id,\r\n            target: node.id,\r\n            type: \"smoothstep\",\r\n            animated: true,\r\n            style: { stroke: \"hsl(var(--muted-foreground))\" },\r\n            ...(connectionType === \"arrow\" && {\r\n              markerEnd: {\r\n                type: MarkerType.ArrowClosed,\r\n                width: 20,\r\n                height: 20,\r\n                color: \"hsl(var(--primary))\",\r\n              },\r\n            }),\r\n            data: {\r\n              connectionType,\r\n            },\r\n          };\r\n\r\n          saveCurrentState();\r\n          setEdges((eds) => [...eds, newEdge]);\r\n          setSelectedNode(null);\r\n          setEditMode(\"select\");\r\n\r\n          toast({\r\n            title: \"Connection created\",\r\n            description: `Connected ${selectedNode.data.label} to ${node.data.label}`,\r\n          });\r\n        }\r\n      } else if (editMode === \"select\") {\r\n        // Regular select mode: show node details\r\n        setSelectedNode(node);\r\n      }\r\n    },\r\n    [\r\n      editMode,\r\n      selectedNode,\r\n      nodes,\r\n      edges,\r\n      setNodes,\r\n      setEdges,\r\n      saveCurrentState,\r\n      toast,\r\n    ]\r\n  );\r\n\r\n  const onPaneClick = useCallback(() => {\r\n    // In regular mode, clicking the pane should deselect the node\r\n    setSelectedNode(null);\r\n\r\n    // If in connect mode but no node selected, return to select mode\r\n    if (editMode === \"connect\" && selectedNode) {\r\n      setEditMode(\"select\");\r\n      setSelectedNode(null);\r\n      toast({\r\n        title: \"Connection cancelled\",\r\n        description: \"Node connection has been cancelled\",\r\n      });\r\n    }\r\n  }, [editMode, selectedNode, toast]);\r\n\r\n  const handleSaveRoadmap = useCallback(() => {\r\n    if (onSave) {\r\n      console.log(\"[VIEW] Starting roadmap save process\");\r\n      console.log(\"[VIEW] Current nodes:\", nodes.length);\r\n      console.log(\"[VIEW] Current edges:\", edges.length);\r\n\r\n      // Debug: log thông tin an toàn về nodes và edges\r\n      try {\r\n        if (nodes.length > 0) {\r\n          console.log(\"[VIEW] First node sample:\", {\r\n            id: nodes[0]?.id,\r\n            type: nodes[0]?.type,\r\n            position: nodes[0]?.position ? { ...nodes[0].position } : null,\r\n            label: nodes[0]?.data?.label,\r\n          });\r\n        }\r\n\r\n        if (edges.length > 0) {\r\n          console.log(\"[VIEW] First edge sample:\", {\r\n            id: edges[0]?.id,\r\n            source: edges[0]?.source,\r\n            target: edges[0]?.target,\r\n            type: edges[0]?.type,\r\n          });\r\n        }\r\n      } catch (logError) {\r\n        console.error(\"[VIEW] Error logging node/edge details:\", logError);\r\n      }\r\n\r\n      // Lọc bỏ các nodes không hợp lệ\r\n      const validNodes = nodes.filter((node) => {\r\n        if (!node || !node.id) {\r\n          console.warn(\"[VIEW] Skipping invalid node without ID\");\r\n          return false;\r\n        }\r\n        return true;\r\n      });\r\n\r\n      // Ensure no node is missing important data\r\n      const cleanedNodes = validNodes.map((node) => {\r\n        if (!node.position) {\r\n          console.error(\"[VIEW] Node missing position:\", node);\r\n          // Default position\r\n          node.position = { x: 0, y: 0 };\r\n        }\r\n\r\n        if (!node.data) {\r\n          console.error(\"[VIEW] Node missing data:\", node);\r\n          // Default minimal data\r\n          node.data = { label: \"Node \" + node.id };\r\n        }\r\n\r\n        // Tạo một node sạch không chứa các tham chiếu React/DOM\r\n        return {\r\n          id: node.id,\r\n          type: node.type || \"courseNode\", // Default node type\r\n          position: {\r\n            x: node.position?.x || 0,\r\n            y: node.position?.y || 0,\r\n          },\r\n          data: {\r\n            id: node.id,\r\n            label: node.data?.label || \"Untitled\",\r\n            description: node.data?.description,\r\n            category: node.data?.category,\r\n            categoryId: node.data?.categoryId,\r\n            difficulty: node.data?.difficulty,\r\n            completed: node.data?.completed || false,\r\n            courseId: node.data?.courseId,\r\n            nodeColor: node.data?.nodeColor,\r\n            nodeBgColor: node.data?.nodeBgColor,\r\n            textColor: node.data?.textColor,\r\n            fontSize: node.data?.fontSize,\r\n          },\r\n        };\r\n      });\r\n\r\n      // Remove any invalid edges\r\n      const nodeIdMap = new Set(cleanedNodes.map((node) => node.id));\r\n\r\n      // Lọc bỏ các edges không hợp lệ\r\n      const validEdges = edges.filter((edge) => {\r\n        if (!edge || !edge.id || !edge.source || !edge.target) {\r\n          console.warn(\"[VIEW] Skipping invalid edge missing id/source/target\");\r\n          return false;\r\n        }\r\n        return true;\r\n      });\r\n\r\n      // Clean edges - make sure they connect to existing nodes\r\n      const cleanedEdges = validEdges\r\n        .filter((edge) => {\r\n          // Check if source and target nodes exist\r\n          const sourceExists = nodeIdMap.has(edge.source);\r\n          const targetExists = nodeIdMap.has(edge.target);\r\n\r\n          if (!sourceExists || !targetExists) {\r\n            console.warn(\r\n              `[VIEW] Removing invalid edge - Source exists: ${sourceExists}, Target exists: ${targetExists}`,\r\n              edge\r\n            );\r\n            return false;\r\n          }\r\n          return true;\r\n        })\r\n        .map((edge) => {\r\n          // Tạo một edge sạch không chứa các tham chiếu React/DOM\r\n          return {\r\n            id: edge.id,\r\n            source: edge.source,\r\n            target: edge.target,\r\n            type: edge.type || \"smoothstep\",\r\n            animated: edge.animated || false,\r\n            sourceHandle: edge.sourceHandle || null,\r\n            targetHandle: edge.targetHandle || null,\r\n            style: edge.style ? { ...edge.style } : { stroke: \"#999\" },\r\n            data: {\r\n              connectionType: edge.data?.connectionType || \"arrow\",\r\n            },\r\n          };\r\n        });\r\n\r\n      console.log(\"[VIEW] Cleaned nodes count:\", cleanedNodes.length);\r\n      console.log(\"[VIEW] Cleaned edges count:\", cleanedEdges.length);\r\n\r\n      // Debug: kiểm tra kiểu dữ liệu trước khi gọi callback\r\n      console.log(\r\n        \"[VIEW] Cleaned nodes type:\",\r\n        Array.isArray(cleanedNodes) ? \"Array\" : typeof cleanedNodes\r\n      );\r\n      console.log(\r\n        \"[VIEW] Cleaned edges type:\",\r\n        Array.isArray(cleanedEdges) ? \"Array\" : typeof cleanedEdges\r\n      );\r\n      console.log(\"[VIEW] First node in cleaned array:\", cleanedNodes[0]);\r\n\r\n      // Đảm bảo dữ liệu luôn là mảng\r\n      const finalNodes = Array.isArray(cleanedNodes) ? cleanedNodes : [];\r\n      const finalEdges = Array.isArray(cleanedEdges) ? cleanedEdges : [];\r\n\r\n      // Gọi callback để lưu dữ liệu đã được làm sạch\r\n      console.log(\r\n        \"[VIEW] Calling onSave with:\",\r\n        finalNodes.length,\r\n        \"nodes and\",\r\n        finalEdges.length,\r\n        \"edges\"\r\n      );\r\n      onSave(finalNodes, finalEdges);\r\n    }\r\n  }, [nodes, edges, onSave]);\r\n\r\n  const handleAddCourse = useCallback(\r\n    (courseData) => {\r\n      saveCurrentState();\r\n\r\n      // Generate a unique node ID with timestamp for guaranteed uniqueness\r\n      const newNodeId = `node-${Date.now()}-${Math.floor(\r\n        Math.random() * 1000000\r\n      )}`;\r\n\r\n      // Simple positioning math to ensure nodes don't overlap\r\n      const nodeOffsets = [\r\n        { x: 0, y: 0 },\r\n        { x: 250, y: 0 },\r\n        { x: 0, y: 150 },\r\n        { x: 250, y: 150 },\r\n        { x: -250, y: 0 },\r\n        { x: -250, y: 150 },\r\n      ];\r\n\r\n      // Base position starts at center if possible\r\n      let baseX = 0,\r\n        baseY = 0;\r\n\r\n      if (reactFlowInstance) {\r\n        const viewport = reactFlowInstance.getViewport();\r\n        const screenCenter = reactFlowInstance.screenToFlowPosition({\r\n          x: window.innerWidth / 2,\r\n          y: window.innerHeight / 2,\r\n        });\r\n        baseX = screenCenter.x;\r\n        baseY = screenCenter.y;\r\n      }\r\n\r\n      // Choose offset based on node count (cycle through positions)\r\n      const offset = nodeOffsets[nodes.length % nodeOffsets.length];\r\n\r\n      // Final position\r\n      const position = {\r\n        x: baseX + offset.x,\r\n        y: baseY + offset.y,\r\n      };\r\n\r\n      console.log(\r\n        `[FLOW] Creating new node at position: x=${position.x}, y=${position.y}`\r\n      );\r\n\r\n      // Create the node with all required data\r\n      const newNode = {\r\n        id: newNodeId,\r\n        type: \"courseNode\",\r\n        position,\r\n        data: {\r\n          ...courseData,\r\n          id: newNodeId,\r\n          completed: false,\r\n          completedAt: null,\r\n          showQuickToggle: true,\r\n          onQuickToggle: handleCompleteToggle,\r\n        },\r\n      };\r\n\r\n      // Add node directly to state and tracking ref\r\n      setNodes((currentNodes) => [...currentNodes, newNode]);\r\n      addedNodesRef.current = [...addedNodesRef.current, newNode];\r\n\r\n      // Close dialog and show confirmation\r\n      setIsAddCourseOpen(false);\r\n      toast({\r\n        title: \"Course added\",\r\n        description: `${courseData.label} has been added to the roadmap`,\r\n      });\r\n\r\n      // Ensure newly added node is visible\r\n      setTimeout(() => {\r\n        if (reactFlowInstance) {\r\n          reactFlowInstance.fitView({\r\n            padding: 0.5,\r\n            includeHiddenNodes: false,\r\n            minZoom: 0.5,\r\n            maxZoom: 1.5,\r\n          });\r\n        }\r\n      }, 100);\r\n    },\r\n    [\r\n      setNodes,\r\n      toast,\r\n      reactFlowInstance,\r\n      nodes.length,\r\n      handleCompleteToggle,\r\n      saveCurrentState,\r\n    ]\r\n  );\r\n\r\n  // Ensure manually added nodes are preserved during state updates\r\n  useEffect(() => {\r\n    if (addedNodesRef.current.length > 0 && nodes.length > 0) {\r\n      // Get IDs of current nodes\r\n      const currentIds = new Set(nodes.map((n) => n.id));\r\n\r\n      // Find manually added nodes that are missing from current nodes\r\n      const missingNodes = addedNodesRef.current.filter(\r\n        (n) => !currentIds.has(n.id)\r\n      );\r\n\r\n      // If any manually added nodes are missing, add them back\r\n      if (missingNodes.length > 0) {\r\n        console.log(\r\n          `[FLOW] Restoring ${missingNodes.length} manually added nodes that were lost`\r\n        );\r\n        setNodes((currentNodes) => [...currentNodes, ...missingNodes]);\r\n      }\r\n    }\r\n  }, [nodes, setNodes]);\r\n\r\n  const handleDeleteNode = useCallback(\r\n    (nodeId) => {\r\n      saveCurrentState();\r\n\r\n      // Remove the node from state\r\n      setNodes((nds) => nds.filter((node) => node.id !== nodeId));\r\n\r\n      // Remove the node from our tracking ref\r\n      addedNodesRef.current = addedNodesRef.current.filter(\r\n        (node) => node.id !== nodeId\r\n      );\r\n\r\n      // Remove connected edges\r\n      setEdges((eds) =>\r\n        eds.filter((edge) => edge.source !== nodeId && edge.target !== nodeId)\r\n      );\r\n\r\n      // Clear selection\r\n      setSelectedNode(null);\r\n\r\n      toast({\r\n        title: \"Node deleted\",\r\n        description: \"The node has been removed from the roadmap\",\r\n      });\r\n\r\n      // Update view after deletion\r\n      setTimeout(() => {\r\n        if (reactFlowInstance) {\r\n          reactFlowInstance.fitView({ padding: 0.5 });\r\n        }\r\n      }, 100);\r\n    },\r\n    [setNodes, setEdges, toast, saveCurrentState, reactFlowInstance]\r\n  );\r\n\r\n  const handleUpdateNodeStyle = useCallback(\r\n    (nodeId, style) => {\r\n      setNodes((nds) =>\r\n        nds.map((node) => {\r\n          if (node.id === nodeId) {\r\n            return {\r\n              ...node,\r\n              data: {\r\n                ...node.data,\r\n                ...style,\r\n              },\r\n            };\r\n          }\r\n          return node;\r\n        })\r\n      );\r\n    },\r\n    [setNodes]\r\n  );\r\n\r\n  const onEdgeClick = useCallback(\r\n    (event, edge) => {\r\n      if (editMode === \"delete\") {\r\n        saveCurrentState();\r\n\r\n        // Delete the edge\r\n        setEdges((eds) => eds.filter((e) => e.id !== edge.id));\r\n\r\n        toast({\r\n          title: \"Connection removed\",\r\n          description: \"The connection between nodes has been removed\",\r\n        });\r\n      }\r\n    },\r\n    [setEdges, editMode, saveCurrentState, toast]\r\n  );\r\n\r\n  const handleUndo = useCallback(() => {\r\n    if (undoStack.length === 0) return;\r\n\r\n    const currentState = { nodes: [...nodes], edges: [...edges] };\r\n    const previousState = undoStack[undoStack.length - 1];\r\n\r\n    setRedoStack((prev) => [...prev, currentState]);\r\n    setUndoStack((prev) => prev.slice(0, -1));\r\n\r\n    setNodes(previousState.nodes);\r\n    setEdges(previousState.edges);\r\n\r\n    toast({\r\n      title: \"Undo\",\r\n      description: \"Previous action undone\",\r\n    });\r\n  }, [undoStack, redoStack, nodes, edges, setNodes, setEdges, toast]);\r\n\r\n  const handleRedo = useCallback(() => {\r\n    if (redoStack.length === 0) return;\r\n\r\n    const currentState = { nodes: [...nodes], edges: [...edges] };\r\n    const nextState = redoStack[redoStack.length - 1];\r\n\r\n    setUndoStack((prev) => [...prev, currentState]);\r\n    setRedoStack((prev) => prev.slice(0, -1));\r\n\r\n    setNodes(nextState.nodes);\r\n    setEdges(nextState.edges);\r\n\r\n    toast({\r\n      title: \"Redo\",\r\n      description: \"Action redone\",\r\n    });\r\n  }, [undoStack, redoStack, nodes, edges, setNodes, setEdges, toast]);\r\n\r\n  // Update node positions when they are dragged\r\n  const onNodeDragStop = useCallback(() => {\r\n    if (isEditing) {\r\n      saveCurrentState();\r\n    }\r\n  }, [isEditing, saveCurrentState]);\r\n\r\n  // Handle category filtering\r\n  const filteredNodes = useCallback(() => {\r\n    if (selectedCategory === \"all\") {\r\n      return nodes;\r\n    }\r\n    return nodes.filter(\r\n      (node) =>\r\n        node.data.category?.toLowerCase() === selectedCategory.toLowerCase()\r\n    );\r\n  }, [nodes, selectedCategory]);\r\n\r\n  const handleStyleChange = useCallback(\r\n    (styles) => {\r\n      // Apply styles to selected node or default edge options\r\n      if (selectedNode) {\r\n        handleUpdateNodeStyle(selectedNode.id, styles.nodeStyle);\r\n      }\r\n\r\n      // Update default edge options\r\n      // (would be implemented in a full version)\r\n    },\r\n    [selectedNode, handleUpdateNodeStyle]\r\n  );\r\n\r\n  const handleConnectionTypeChange = useCallback((type) => {\r\n    setConnectionType(type);\r\n  }, []);\r\n\r\n  // Ngăn chặn cảnh báo ResizeObserver\r\n  useEffect(() => {\r\n    // Chỉ áp dụng trong môi trường phát triển\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      // Instead of suppressing errors, let's implement a proper fix\r\n      let resizeObserverLoopErrCount = 0;\r\n      const debouncedResizeObserverCallback = debounce(() => {\r\n        resizeObserverLoopErrCount = 0;\r\n      }, 200);\r\n\r\n      const originalError = console.error;\r\n      console.error = (...args) => {\r\n        if (\r\n          args[0]?.includes?.(\"ResizeObserver loop\") ||\r\n          args[0]?.message?.includes?.(\"ResizeObserver loop\")\r\n        ) {\r\n          // Increment counter and invoke debounced callback\r\n          resizeObserverLoopErrCount += 1;\r\n          if (resizeObserverLoopErrCount <= 1) {\r\n            debouncedResizeObserverCallback();\r\n          }\r\n          // Suppress the error\r\n          return;\r\n        }\r\n        originalError.apply(console, args);\r\n      };\r\n\r\n      return () => {\r\n        console.error = originalError;\r\n      };\r\n    }\r\n\r\n    // Helper function for debounce\r\n    function debounce(fn, delay) {\r\n      let timeoutId;\r\n      return function () {\r\n        clearTimeout(timeoutId);\r\n        timeoutId = setTimeout(() => fn.apply(this, arguments), delay);\r\n      };\r\n    }\r\n  }, []);\r\n\r\n  // Optimize edge rendering and enhance edge interaction\r\n  useEffect(() => {\r\n    // Configure ReactFlow for improved edge connection\r\n    const reactFlowEl = document.querySelector(\".react-flow\");\r\n    if (reactFlowEl) {\r\n      // Add custom class for better edge interaction\r\n      reactFlowEl.classList.add(\"improved-edge-connection\");\r\n    }\r\n\r\n    return () => {\r\n      if (reactFlowEl) {\r\n        reactFlowEl.classList.remove(\"improved-edge-connection\");\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // Ensure nodes are visible in the viewport\r\n  useEffect(() => {\r\n    if (!isInitialMount.current && nodes.length > 0 && reactFlowInstance) {\r\n      // Wait for rendering to complete, then fit view\r\n      const timeoutId = setTimeout(() => {\r\n        console.log(\"[FLOW] Fitting view to ensure nodes are visible\");\r\n        reactFlowInstance.fitView({\r\n          padding: 0.5,\r\n          includeHiddenNodes: true,\r\n          minZoom: 0.5,\r\n          maxZoom: 1.5,\r\n        });\r\n      }, 500);\r\n\r\n      return () => clearTimeout(timeoutId);\r\n    }\r\n  }, [nodes.length, reactFlowInstance]);\r\n\r\n  // Add a debug useEffect to log whenever nodes change\r\n  useEffect(() => {\r\n    if (nodes.length > 0) {\r\n      console.log(\"[FLOW] Nodes changed, current count:\", nodes.length);\r\n    }\r\n  }, [nodes]);\r\n\r\n  // Cleanup on unmount to prevent memory leaks\r\n  useEffect(() => {\r\n    return () => {\r\n      // Clear any timeouts that might be pending\r\n      const viewportEl = document.querySelector(\".react-flow__viewport\");\r\n      if (viewportEl) {\r\n        viewportEl.style.transitionProperty = \"\";\r\n        viewportEl.style.transitionDuration = \"\";\r\n      }\r\n\r\n      console.log(\"[FLOW] Component unmounting, performing cleanup\");\r\n    };\r\n  }, []);\r\n\r\n  // Add special effect to prevent excessive console logging during development\r\n  useEffect(() => {\r\n    if (process.env.NODE_ENV === \"development\") {\r\n      const originalConsoleLog = console.log;\r\n      const flowLogPattern = /^\\[FLOW\\]/;\r\n\r\n      // Filter out excessive flow logs in development\r\n      console.log = (...args) => {\r\n        if (typeof args[0] === \"string\" && flowLogPattern.test(args[0])) {\r\n          // Only log important flow messages or when explicitly debugging\r\n          if (\r\n            args[0].includes(\"error\") ||\r\n            args[0].includes(\"Creating\") ||\r\n            args[0].includes(\"deleted\")\r\n          ) {\r\n            originalConsoleLog.apply(console, args);\r\n          }\r\n        } else {\r\n          originalConsoleLog.apply(console, args);\r\n        }\r\n      };\r\n\r\n      return () => {\r\n        console.log = originalConsoleLog;\r\n      };\r\n    }\r\n  }, []);\r\n\r\n  return (\r\n    <div ref={reactFlowWrapper} className=\"h-full w-full\">\r\n      {isEditing && showEditorPanel && (\r\n        <Panel position=\"right\" className=\"w-72 mr-2\">\r\n          <RoadmapEditorPanel\r\n            onStyleChange={handleStyleChange}\r\n            onConnectionTypeChange={handleConnectionTypeChange}\r\n            activeEdgeStyle={connectionType}\r\n            editMode={editMode}\r\n            onEditModeChange={(mode) => {\r\n              setEditMode(mode);\r\n              if (mode === \"connect\") {\r\n                toast({\r\n                  title: \"Connect mode\",\r\n                  description:\r\n                    \"Click on a source node, then click on a target node to create a connection\",\r\n                });\r\n              } else if (mode === \"delete\") {\r\n                toast({\r\n                  title: \"Delete mode\",\r\n                  description: \"Click on a node or connection to delete it\",\r\n                });\r\n              }\r\n            }}\r\n            onAddNodeClick={() => setIsAddCourseOpen(true)}\r\n          />\r\n        </Panel>\r\n      )}\r\n\r\n      {isEditing && (\r\n        <Panel\r\n          position=\"top-right\"\r\n          className=\"bg-card p-3 rounded-sm border border-[hsl(var(--border))] shadow-md mb-4\" // Updated Panel classes, kept mr-[300px] for now\r\n        >\r\n          <div className=\"flex gap-2 justify-end\">\r\n            <Button\r\n              size=\"sm\"\r\n              variant=\"outline\" // Changed to variant\r\n              onClick={handleUndo}\r\n              disabled={undoStack.length === 0}\r\n            >\r\n              Undo\r\n            </Button>\r\n            <Button\r\n              size=\"sm\"\r\n              variant=\"outline\" // Changed to variant\r\n              onClick={handleRedo}\r\n              disabled={redoStack.length === 0}\r\n            >\r\n              Redo\r\n            </Button>\r\n            <Button\r\n              variant=\"default\" // Changed to variant\r\n              size=\"sm\"\r\n              onClick={handleSaveRoadmap}\r\n            >\r\n              <Save className=\"h-4 w-4 mr-1\" /> Save\r\n            </Button>\r\n          </div>\r\n        </Panel>\r\n      )}\r\n\r\n      <div className=\"h-full\">\r\n        <ReactFlow\r\n          key={`flow-${id}-${nodes.length}`}\r\n          nodes={filteredNodes()}\r\n          edges={edges}\r\n          onNodesChange={isEditing ? onNodesChange : undefined}\r\n          onEdgesChange={isEditing ? onEdgesChange : undefined}\r\n          onConnect={isEditing ? onConnect : undefined}\r\n          onNodeClick={onNodeClick}\r\n          onEdgeClick={onEdgeClick}\r\n          onPaneClick={onPaneClick}\r\n          nodeTypes={nodeTypes}\r\n          onNodeDragStop={onNodeDragStop}\r\n          nodesDraggable={isEditing}\r\n          nodesConnectable={isEditing && editMode === \"connect\"}\r\n          elementsSelectable={!readOnly}\r\n          defaultEdgeOptions={{\r\n            type: \"smoothstep\",\r\n            style: { stroke: \"hsl(var(--muted-foreground))\" }, // Updated stroke color\r\n            animated: true,\r\n            ...(connectionType === \"arrow\" && {\r\n              markerEnd: {\r\n                type: MarkerType.ArrowClosed,\r\n                width: 20,\r\n                height: 20,\r\n                color: \"hsl(var(--primary))\", // Updated marker color\r\n              },\r\n            }),\r\n            data: {\r\n              connectionType,\r\n            },\r\n          }}\r\n          fitView\r\n          fitViewOptions={{\r\n            padding: 0.5,\r\n            includeHiddenNodes: true,\r\n            minZoom: 0.5,\r\n            maxZoom: 1.5,\r\n          }}\r\n          minZoom={0.2}\r\n          maxZoom={4}\r\n          snapToGrid={true}\r\n          snapGrid={[10, 10]}\r\n          nodeExtent={[\r\n            [-2000, -2000],\r\n            [2000, 2000],\r\n          ]}\r\n          proOptions={{ hideAttribution: true }}\r\n          disableKeyboardA11y={true}\r\n          autoPanOnNodeDrag={false}\r\n          elevateEdgesOnSelect={false}\r\n          onInit={(instance) => {\r\n            // Use setTimeout to ensure proper initialization\r\n            setTimeout(() => {\r\n              if (nodes.length > 0) {\r\n                instance.fitView({ padding: 0.5 });\r\n                console.log(\r\n                  \"[FLOW] Flow initialized with nodes:\",\r\n                  nodes.length\r\n                );\r\n              }\r\n            }, 300);\r\n          }}\r\n          // Add custom edge rendering to set data attributes based on handle positions\r\n          edgeUpdaterRadius={10}\r\n          edgesUpdatable={true}\r\n          edgesFocusable={true}\r\n          onEdgeUpdate={(oldEdge, newConnection) => {\r\n            setEdges((els) =>\r\n              els.map((edge) => {\r\n                if (edge.id === oldEdge.id) {\r\n                  // Generate new ID based on new connection points\r\n                  const newId = `edge-${newConnection.source}-${\r\n                    newConnection.sourceHandle || \"default\"\r\n                  }-${newConnection.target}-${\r\n                    newConnection.targetHandle || \"default\"\r\n                  }`;\r\n                  return {\r\n                    ...edge,\r\n                    id: newId,\r\n                    source: newConnection.source,\r\n                    target: newConnection.target,\r\n                    sourceHandle: newConnection.sourceHandle,\r\n                    targetHandle: newConnection.targetHandle,\r\n                    data: {\r\n                      ...edge.data,\r\n                      sourceId: newConnection.source,\r\n                      targetId: newConnection.target,\r\n                      sourceHandle: newConnection.sourceHandle,\r\n                      targetHandle: newConnection.targetHandle,\r\n                      sourceHandleType: newConnection.sourceHandle || \"default\",\r\n                      targetHandleType: newConnection.targetHandle || \"default\",\r\n                    },\r\n                  };\r\n                }\r\n                return edge;\r\n              })\r\n            );\r\n            return true;\r\n          }}\r\n        >\r\n          <Controls />\r\n          <MiniMap nodeStrokeWidth={3} zoomable pannable />\r\n          <Background\r\n            variant=\"dots\"\r\n            gap={12}\r\n            size={1}\r\n            color=\"hsl(var(--border))\"\r\n          />{\" \"}\r\n          {/* Updated Background color */}\r\n          {/* Add custom edge styles for colored connections */}\r\n          {edges.map((edge) => (\r\n            <div key={`handle-${edge.id}`} style={{ display: \"none\" }}>\r\n              <div\r\n                data-edgeid={edge.id}\r\n                data-sourcehandle={edge.sourceHandle || \"default\"}\r\n                data-targethandle={edge.targetHandle || \"default\"}\r\n              />\r\n            </div>\r\n          ))}\r\n        </ReactFlow>\r\n      </div>\r\n\r\n      {selectedNode && (\r\n        <CourseInfoPanel\r\n          node={selectedNode}\r\n          onClose={() => setSelectedNode(null)}\r\n          onCompleteToggle={handleCompleteToggle}\r\n          onDelete={isEditing ? handleDeleteNode : undefined}\r\n          onUpdateStyle={handleUpdateNodeStyle}\r\n          isAdmin={isEditing}\r\n          readOnly={readOnly}\r\n        />\r\n      )}\r\n\r\n      {isAddCourseOpen && (\r\n        <AddCourseDialog\r\n          open={isAddCourseOpen}\r\n          onClose={() => setIsAddCourseOpen(false)}\r\n          onAdd={handleAddCourse}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default function RoadmapView(props) {\r\n  console.log(\"[FLOW] RoadmapView wrapper rendering with props:\", {\r\n    id: props.id,\r\n    nodesCount: props.initialNodes?.length,\r\n    edgesCount: props.initialEdges?.length,\r\n  });\r\n\r\n  return (\r\n    <ReactFlowProvider>\r\n      <div className=\"w-full h-full\">\r\n        <RoadmapViewInner {...props} />\r\n      </div>\r\n    </ReactFlowProvider>\r\n  );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}